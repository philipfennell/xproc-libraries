<apidoc:module name="SearchBuiltins" category="SearchBuiltins" lib="cts" xmlns:apidoc="http://marklogic.com/xdmp/apidoc"><apidoc:summary access="public" category="SearchBuiltins" subcategory="Search" lib="cts">
<p xmlns="http://www.w3.org/1999/xhtml">The search built-in functions are XQuery functions used to perform text 
searches. The search functions are designed for use with XML structured text.
Searches that use these functions use the indexes and are designed
to return fast.</p>
<p xmlns="http://www.w3.org/1999/xhtml">There are built-in functions to search through documents 
(<a href="#cts:search">cts:search</a>, <a href="#cts:contains">cts:contains</a>
 and <a href="#cts:highlight">cts:highlight</a>); 
there is a function to tokenize text into different types 
(<a href="#cts:tokenize">cts:tokenize</a>), and there are functions 
to retrieve result characteristics (for example 
<a href="#cts:quality">cts:quality</a> and <a href="#cts:score">cts:score</a>). 
There are also built-in functions to browse word and value lexicons
(<a href="#cts:words">cts:words</a>, 
<a href="#cts:element-values">cts:element-values</a>, and so on.) The lexicon 
built-in functions require the appropriate lexicons to be enabled in the 
Admin interface.</p>
<p xmlns="http://www.w3.org/1999/xhtml">There are also functions to compose a <code>cts:query</code>, 
as well as accessor functions to retrieve the parameter values 
from a <code>cts:query</code>. These functions are documented in the 
<a href="apidocs.xqy?fname=cts:query Constructors">cts:query 
Constructors</a> section.
</p>

</apidoc:summary><apidoc:summary access="public" category="SearchBuiltins" subcategory="cts:query Constructors" lib="cts">
<p xmlns="http://www.w3.org/1999/xhtml">The <code>cts:query</code> constructor functions allow you to build
arbitrarily complex <code>cts:query</code> specifications. Each 
<code>cts:query</code> constructor function has corresponding accessor 
functions, which are used to get the values of parameters in a
<code>cts:query</code>.</p>
<p xmlns="http://www.w3.org/1999/xhtml">Included in the <code>cts:query</code> functions is the 
<a href="#cts:registered-query">cts:registered-query</a> function, which
provides a mechanism to precompute and store in the cache unfiltered 
<code>cts:query</code> result primitives.</p>

</apidoc:summary><apidoc:summary access="public" category="SearchBuiltins" subcategory="Lexicon" lib="cts">
<p xmlns="http://www.w3.org/1999/xhtml">MarkLogic Server allows you to create <em>lexicons</em>, which are lists 
of unique words or values, either throughout an entire database (words only) 
or within named elements or attributes (words or values). Also, you can 
define lexicons that allow quick access to the document and collection 
URIs in the database, and you can create word lexicons on named 
fields. </p>
<p xmlns="http://www.w3.org/1999/xhtml">A <em>word lexicon</em> stores all of the unique, case-sensitive, 
diacritic-sensitive words, either in a database, in an element 
defined by a QName, or in an attribute defined by a QName. A 
<em>value lexicon</em> stores all of the unique values for an element 
or an attribute defined by a QName (that is, the entire and exact contents 
of the specified element or attribute). A 
<em>value co-occurrences lexicon</em> stores all of the pairs of 
values that appear in the same fragment. A 
<em>geospatial lexicon</em> returns geospatial values from the geospatial
index. A <em>range lexicon</em> stores buckets of values that occur
within a specified range of values. A <em>URI lexicon</em> stores the 
URIs of the documents in a database, and a 
<em>collection lexicon</em> stores the URIs of all collections 
in a database.</p>
<p xmlns="http://www.w3.org/1999/xhtml">This section describes the lexicon APIs.</p>
</apidoc:summary><apidoc:summary access="public" category="SearchBuiltins" subcategory="Geospatial Lexicon" lib="cts">
<p xmlns="http://www.w3.org/1999/xhtml">MarkLogic Server allows you to create <em>geospatial lexicons</em>, which 
are lists of unique values of geospatial data. </p>
<p xmlns="http://www.w3.org/1999/xhtml"> A <em>geospatial lexicon</em> returns geospatial values from the geospatial
index. The geospatial index is required for using the geospatial lexicon
functions.</p>
<p xmlns="http://www.w3.org/1999/xhtml">This section describes the geospatial lexicon APIs.</p>
</apidoc:summary><apidoc:function name="and-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a query specifying the intersection
  of the matches specified by the sub-queries.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="queries" type="cts:query*" optional="false">
    A sequence of sub-queries.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ordered"</dt>
        <dd>An ordered and-query, which specifies that the sub-query matches
            must occur in the order of the specified sub-queries.  For example,
            if the sub-queries are "cat" and "dog", an ordered
            query will only match fragments where both "cat" and "dog" occur, 
            and where "cat" comes before "dog" in the fragment.</dd>
        <dt>"unordered"</dt>
        <dd>An unordered and-query, which specifies that the sub-query matches 
        can occur in any order. </dd>
     </dl></blockquote> 
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:and-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">If the options parameter contains neither "ordered" nor "unordered",
  then the default is "unordered".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If you specify the empty sequence for the <code>queries</code> parameter 
  to <code>cts:and-query</code>, you will get a match for every document in
  the database.  For example, the following query always returns true:</p>
 <pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">   cts:contains(collection(), cts:and-query(()))</pre>
 <p xmlns="http://www.w3.org/1999/xhtml"> In order to match a <code>cts:and-query</code>, the matches 
  from each of the specified sub-queries must all occur in the same 
  fragment.
 </p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//PLAY,
    cts:and-query((
      cts:word-query("to be or"),
      cts:word-query("or not to be"))))
  =&gt; .. a sequence of 'PLAY' elements which are
  ancestors (or self) of some node whose text content
  contains the phrase 'to be or' AND some node
  whose text content contains the phrase 'or not to be'.
  With high probability this intersection contains only 
  one 'PLAY' element, namely,
    
    PLAY/TITLE = 
      "The Tragedy of Hamlet, Prince of Denmark".
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="and-query-queries" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a sequence of the queries that were used to construct the specified
  query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:and-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:and-query-queries($query)
  =&gt; ... a sequence of the queries used to 
            construct this query
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := 
  cts:and-query((
    cts:word-query("to be or"), 
    cts:word-query("or not to be")))
return cts:and-query-queries($query)
  =&gt; (cts:word-query("to be or", (), 1) 
         cts:word-query("or not to be", (), 1))
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="and-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:and-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:and-query-options($query)
  =&gt; "ordered"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="or-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a query specifying the union
  of the matches specified by the sub-queries.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="queries" type="cts:query*" optional="false">
    A sequence of sub-queries.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:or-query</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//PLAY,
    cts:or-query((
      cts:word-query("summer"),
      cts:word-query("sun of York"))))
  =&gt; .. a sequence of 'PLAY' elements which are
  ancestors (or self) of some node whose text content
  contains the word 'summer' OR some node
  whose text content contains the phrase 'sun of York'.
  This union contains at least one 'PLAY' node with:

    PLAY/TITLE = 
      "The Tragedy of King Richard the Second",

  but also contains other 'PLAY' nodes containing some 
  text node with the word "summer", for example,

    PLAY/TITLE = "A Midsummer Night's Dream".
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="or-query-queries" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a sequence of the queries that were used to construct the specified
  query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:or-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:or-query-queries($query)
  =&gt; ... a sequence of the queries used to construct this query
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="and-not-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a query specifying the set difference of
  the matches specified by two sub-queries.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="positive-query" type="cts:query" optional="false">
    A positive query, specifying the search results
    filtered in.
  </apidoc:param>
      <apidoc:param name="negative-query" type="cts:query" optional="false">
    A negative query, specifying the search results
    to filter out.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:and-not-query</apidoc:return>
    <apidoc:usage>
  The <code xmlns="http://www.w3.org/1999/xhtml">cts:and-not-query</code> constructor is fragment-based, so
  it returns true only if the specified query does not produce a match
  anywhere in a fragment.  Therefore, a search using 
  <code xmlns="http://www.w3.org/1999/xhtml">cts:and-not-query</code> is only guaranteed to be accurate if the 
  underlying query that is being negated is accurate from its index 
  resolution (that is,
  if the unfiltered results of the <code xmlns="http://www.w3.org/1999/xhtml">$negative-query</code> parameter to
  <code xmlns="http://www.w3.org/1999/xhtml">cts:not-query</code> are accurate).  The accuracy of the index
  resolution depends on many factors such as the query, if you search 
  at a fragment root (that is, if the first parameter of 
  <code xmlns="http://www.w3.org/1999/xhtml">cts:search</code> specifies an XPath that resolves to a fragment root),
  the index options enabled on the database, the search options, 
  and other factors.  
  In cases where the <code xmlns="http://www.w3.org/1999/xhtml">$negative-query</code> parameter has false 
  positive matches,
  the negation of the query can miss matches (have false negative matches).  
  In these cases, 
  searches with <code xmlns="http://www.w3.org/1999/xhtml">cts:and-not-query</code> can miss results, even if those 
  searches are filtered.  
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//PLAY,
    cts:and-not-query(
      cts:word-query("summer"),
      cts:word-query("glorious")))
  =&gt; .. sequence of 'PLAY' elements containing some
  text node with the word 'summer' BUT NOT containing
  any text node with the word 'glorious'.  This sequence
  may be (in fact is) non-empty, but certainly does not
  contain the PLAY element with:

    PLAY/TITLE = 
      "The Tragedy of King Richard the Second"

  since this play contains both 'glorious' and 'summer'.
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="and-not-query-positive-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the positive (first parameter) query used to construct the
  specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:and-not-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:and-not-query(
                 cts:word-query("wanted"), 
                 cts:word-query("unwanted"))
return cts:and-not-query-positive-query($query)
  
  =&gt; cts:word-query("wanted", (), 1)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="and-not-query-negative-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the negative (second parameter) query used to construct the 
  specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:and-not-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:and-not-query(
                 cts:word-query("wanted"), 
                 cts:word-query("unwanted"))
return cts:and-not-query-negative-query($query)
  
  =&gt; cts:word-query("unwanted", (), 1)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="not-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a query specifying the matches not specified by its sub-query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:query" optional="false">
    A negative query, specifying the search results
    to filter out.
  </apidoc:param>
      <!-- Do not document: this shouldn't be here and doesn't work
  <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.
    Higher weights move search results up in the relevance
    order. The default is 1.0. The 
    weight should be less than or equal to the absolute value of 16 (between 
    -16 and 16); weights greater than 16 will have the same effect as a 
    weight of 16. 
    Weights less than the absolute value of 0.0625 (between -0.0625 and
    0.0625) are rounded to 0, which means that they do not contribute to the 
    score.
  </apidoc:param>
  -->
    </apidoc:params>
    <apidoc:return>cts:not-query</apidoc:return>
    <apidoc:usage>
  The <code xmlns="http://www.w3.org/1999/xhtml">cts:not-query</code> constructor is fragment-based, so
  it returns true only if the specified query does not produce a match
  anywhere in a fragment.  Therefore, a search using 
  <code xmlns="http://www.w3.org/1999/xhtml">cts:not-query</code> is only guaranteed to be accurate if the underlying
  query that is being negated is accurate from its index resolution (that is,
  if the unfiltered results of the <code xmlns="http://www.w3.org/1999/xhtml">$query</code> parameter to
  <code xmlns="http://www.w3.org/1999/xhtml">cts:not-query</code> are accurate).  The accuracy of the index
  resolution depends on the many factors such as the query, if you search 
  at a fragment root (that is, if the first parameter of 
  <code xmlns="http://www.w3.org/1999/xhtml">cts:search</code> specifies an XPath that resolves to a fragment root),
  the index options enabled on the database, the search options, 
  and other factors.  
  In cases where the <code xmlns="http://www.w3.org/1999/xhtml">$query</code> parameter has false-positive matches,
  the negation of the query can miss matches (have false negative matches).  
  In these cases, 
  searches with <code xmlns="http://www.w3.org/1999/xhtml">cts:not-query</code> can miss results, even if those 
  searches are filtered.
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//PLAY,
    cts:not-query(
      cts:word-query("summer")))
  =&gt; ...  sequence of 'PLAY' elements not containing 
          any text node with the word 'summer'.  
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $doc := 
  &lt;doc&gt;  
   &lt;p n="1"&gt;Dogs, cats, and pigs&lt;/p&gt;
   &lt;p n="2"&gt;Trees, frogs, and cats&lt;/p&gt;
   &lt;p n="3"&gt;Dogs, alligators, and wolves&lt;/p&gt;
  &lt;/doc&gt; 
return
$doc//p[cts:contains(., cts:not-query("cat"))]
(: Returns the third p element (the one without
   a "cat" term). Note that the
   cts:contains forces the constraint to happen
   in the filtering stage of the query. :)

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="not-query-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the query used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:not-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:not-query-query($query)
  =&gt; cts:word-query("MarkLogic Server")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="not-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:not-query-weight($query)
  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="word-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a query matching text content containing a given phrase.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="text" type="xs:string*" optional="false">
    Some words or phrases to match.  
    When multiple strings are specified, 
    the query matches if any string matches. 
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive query.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive query.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive query.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive query.</dd>
        <dt>"punctuation-sensitive"</dt>
        <dd>A punctuation-sensitive query.</dd>
        <dt>"punctuation-insensitive"</dt>
        <dd>A punctuation-insensitive query.</dd>
        <dt>"whitespace-sensitive"</dt>
        <dd>A whitespace-sensitive query.</dd>
        <dt>"whitespace-insensitive"</dt>
        <dd>A whitespace-insensitive query.</dd>
        <dt>"stemmed"</dt>
        <dd>A stemmed query.</dd> 
        <dt>"unstemmed"</dt>
        <dd>An unstemmed query.</dd>
        <dt>"wildcarded"</dt>
        <dd>A wildcarded query.</dd>
        <dt>"unwildcarded"</dt>
        <dd>An unwildcarded query.</dd>
        <dt>"exact"</dt>
        <dd>An exact match query. Shorthand for "case-sensitive",
        "diacritic-sensitive", "punctuation-sensitive", 
        "whitespace-sensitive", "unstemmed", and "unwildcarded".
        </dd>
        <dt>"lang=<em>iso639code</em>"</dt>
        <dd>Specifies the language of the query. The <em>iso639code</em>
            code portion is case-insensitive, and uses the languages
            specified by 
           <a href="http://www.loc.gov/standards/iso639-2/php/code_list.php" target="_blank">ISO 639</a>.
            The default is specified in the database configuration.</dd>
        <dt>"distance-weight=<em>number</em>"</dt>
        <dd>A weight applied based on the minimum distance between matches
        of this query.  Higher weights add to the importance of
        proximity (as opposed to term matches) when the relevance order is
        calculated.  
        The default value is 0.0 (no impact of proximity). The 
        weight should be less than or equal to the absolute value of 16 
        (between -16 and 16); weights greater than 16 will have the 
        same effect as a weight of 16. 
        This parameter has no effect if the <code>word positions</code>
        index is not enabled.  This parameter has no effect on searches that 
	use score-simple or score-random (because those scoring algorithms
	do not consider term frequency, proximity is irrelevant).
        </dd>
        <dt>"min-occurs=<em>number</em>"</dt>
        <dd>Specifies the minimum number of occurrences required. If 
        fewer that this number of words occur, the fragment does not match.
        The default is 1.</dd>
        <dt>"max-occurs=<em>number</em>"</dt>
        <dd>Specifies the maximum number of occurrences required.  If
        more than this number of words occur, the fragment does not match.
        The default is unbounded.</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.
    Higher weights move search results up in the relevance
    order.  The default is 1.0. The 
    weight should be less than or equal to the absolute value of 16 (between 
    -16 and 16); weights greater than 16 will have the same effect as a 
    weight of 16. 
    Weights less than the absolute value of 0.0625 (between -0.0625 and
    0.0625) are rounded to 0, which means that they do not contribute to the 
    score.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:word-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive" 
    is present, $text is used to determine case sensitivity.
    If $text contains no uppercase, it specifies "case-insensitive".
    If $text contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive" 
    is present, $text is used to determine diacritic sensitivity.
    If $text contains no diacritics, it specifies "diacritic-insensitive".
    If $text contains diacritics, it specifies "diacritic-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "punctuation-sensitive" nor "punctuation-insensitive" 
    is present, $text is used to determine punctuation sensitivity.
    If $text contains no punctuation, it specifies "punctuation-insensitive".
    If $text contains punctuation, it specifies "punctuation-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "whitespace-sensitive" nor "whitespace-insensitive" 
    is present, the query is "whitespace-insensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "wildcarded" nor "unwildcarded" 
    is present, the database configuration and $text determine wildcarding.
    If the database has any wildcard indexes enabled ("three character 
    searches", "two character searches", "one character searches",  or
    "trailing wildcard searches") and if $text contains either of the 
    wildcard characters '?' or '*', it specifies "wildcarded".  
    Otherwise it specifies "unwildcarded".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "stemmed" nor "unstemmed" 
    is present, then the database configuration determines if a query
    is run as "stemmed" (stemmed searches enabled) or "unstemmed" 
    (word searches enabled and stemmed searches disabled).  
    If the query is a wildcard
    query and is also a phrase query (contains two or more terms),  
    then any wildcard terms in the query will be "unstemmed".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    Negative "min-occurs" or "max-occurs" values will be treated as 0 and
    non-integral values will be rounded down.  An error will be raised if
    the "min-occurs" value is greater than the "max-occurs" value.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">Relevance adjustment for the "distance-weight" option depends on
  the closest proximity of any two matches of the query.  For example,
  <pre xml:space="preserve">
  cts:word-query(("dog","cat"),("distance-weight=10"))
  </pre>
  will adjust relevance based on the distance between the closest pair of 
  matches of either "dog" or "cat" (the pair may consist only of matches of
  "dog", only of matches of "cat", or a match of "dog" and a match of "cat").
  </p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//function,
    cts:word-query("MarkLogic Corporation"))
  <br/>
  =&gt; .. relevance-ordered sequence of 'function' element
  ancestors (or self) of any node containing the phrase 
  'MarkLogic Corporation'.
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//function,
    cts:word-query("MarkLogic Corporation", 
                   "case-insensitive"))
  =&gt; .. relevance-ordered sequence of 'function' 
  element ancestors (or self) of any node containing 
  the phrase 'MarkLogic Corporation' or any other 
  case-shift like 'MarkLogic Corporation', 
  'MARKLOGIC Corporation', etc.
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//SPEECH,
    cts:word-query("to be, or not to be", 
                   "punctuation-insensitive"))
  =&gt; .. relevance-ordered sequence of 'SPEECH' 
  element ancestors (or self) of any node 
  containing the phrase 'to be, or not to be', 
  ignoring punctuation.
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="word-query-text" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the text used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:word-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:word-query-text($query)
  =&gt; "choice of law"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="word-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:word-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:word-query-options($query)
  =&gt; ("case-sensitive", "punctuation-insensitive")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="word-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:word-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:word-query-weight($query)
  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-range-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> matching elements by name with a 
  range-index entry equal a given value.  Searches with the 
  <code xmlns="http://www.w3.org/1999/xhtml">cts:element-range-query</code> 
  constructor require an element range index on the specified QName(s); 
  if there is no range index configured, then an exception is thrown. 
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-name" type="xs:QName*" optional="false">
    One or more element QNames to match.  
    When multiple QNames are specified, 
    the query matches if any QName matches.
  </apidoc:param>
      <apidoc:param name="operator" type="xs:string" optional="false">
    A comparison operator.  
    <p xmlns="http://www.w3.org/1999/xhtml">
      Operators include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"&lt;"</dt>
        <dd>Match range index values less than $value.</dd>
        <dt>"&lt;="</dt>
        <dd>Match range index values less than or equal to $value.</dd>
        <dt>"&gt;"</dt>
        <dd>Match range index values greater than $value.</dd>
        <dt>"&gt;="</dt>
        <dd>Match range index values greater than or equal to $value.</dd>
        <dt>"="</dt>
        <dd>Match range index values equal to $value.</dd>
        <dt>"!="</dt>
        <dd>Match range index values not equal to $value.</dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="value" type="xs:anyAtomicType*" optional="false">
    One or more element values to match. 
    When multiple values are specified, 
    the query matches if any value matches. 
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the range index with the collation specified by 
        <em>URI</em>.  If not specified, then the default collation
        from the query is used. If a range index with the specified
        collation does not exist, an error is thrown.</dd>
        <dt>"cached"</dt>
        <dd>Cache the results of this query in the list cache.</dd>
        <dt>"uncached"</dt>
        <dd>Do not cache the results of this query in the list cache.</dd>
        <dt>"min-occurs=<em>number</em>"</dt>
        <dd>Specifies the minimum number of occurrences required. If 
        fewer that this number of words occur, the fragment does not match.
        The default is 1.</dd>
        <dt>"max-occurs=<em>number</em>"</dt>
        <dd>Specifies the maximum number of occurrences required.  If
        more than this number of words occur, the fragment does not match.
        The default is unbounded.</dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.  The default is 1.0.  In the current release, 
    this option is ignored; range queries do not contribute to the score.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:element-range-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">If you want to constrain on a range of values, you can combine multiple
  <code>cts:element-range-query</code> constructors together
  with <code>cts:and-query</code> or any of the other composable 
  <code>cts:query</code> constructors, as in the last part of the example
  below.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If neither "cached" not "uncached" is present, it specifies "cached".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    Negative "min-occurs" or "max-occurs" values will be treated as 0 and
    non-integral values will be rounded down.  An error will be raised if
    the "min-occurs" value is greater than the "max-occurs" value.
  </p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: create a document with test data :)
xdmp:document-insert("/dates.xml",
&lt;root&gt;
  &lt;entry&gt;
    &lt;date&gt;2007-01-01&lt;/date&gt;
    &lt;info&gt;Some information.&lt;/info&gt;
  &lt;/entry&gt;
  &lt;entry&gt;
    &lt;date&gt;2006-06-23&lt;/date&gt;
    &lt;info&gt;Some other information.&lt;/info&gt;
  &lt;/entry&gt;
  &lt;entry&gt;
    &lt;date&gt;1971-12-23&lt;/date&gt;
    &lt;info&gt;Some different information.&lt;/info&gt;
  &lt;/entry&gt;
&lt;/root&gt;);

(: 
   requires an element (range) index of 
   type xs:date on "date" 
:)
cts:search(doc("/dates.xml")/root/entry, 
  cts:element-range-query(xs:QName("date"), "&lt;=",
      xs:date("2000-01-01")))
(:
  returns the following node: 
  &lt;entry&gt;
    &lt;date&gt;1971-12-23&lt;/date&gt;
    &lt;info&gt;Some different information.&lt;/info&gt;
  &lt;/entry&gt;
:)
;
(: 
   requires an element (range) index of 
   type xs:date on "date" 
:)
cts:search(doc("/dates.xml")/root/entry, 
  cts:and-query((
   cts:element-range-query(xs:QName("date"), "&gt;",
      xs:date("2006-01-01")),
   cts:element-range-query(xs:QName("date"), "&lt;",
      xs:date("2008-01-01")))))
(:
  returns the following 2 nodes: 
  &lt;entry&gt;
    &lt;date&gt;2007-01-01&lt;/date&gt;
    &lt;info&gt;Some information.&lt;/info&gt;
  &lt;/entry&gt;

  &lt;entry&gt;
    &lt;date&gt;2006-06-23&lt;/date&gt;
    &lt;info&gt;Some other information.&lt;/info&gt;
  &lt;/entry&gt;
:)
</pre>
</apidoc:example>
  </apidoc:function><apidoc:function name="element-range-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-range-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:element-range-query-element-name($query)
  =&gt; xs:QName("function")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-range-query-operator" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the operator used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-range-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-range-query-operator($query)
  =&gt; "&lt;"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-range-query-value" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the value used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-range-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-range-query-value($query)
  =&gt; 123
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-range-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-range-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-range-query-options($query)
  =&gt; "collation=http://marklogic.com/collation/"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-range-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-range-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-range-query-weight($query)
  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-value-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a query matching elements by name with text content equal a 
  given phrase.  <code xmlns="http://www.w3.org/1999/xhtml">cts:element-value-query</code> only matches against
  simple elements (that is, elements that contain only text and have no element 
  children).
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-name" type="xs:QName*" optional="false">
    One or more element QNames to match.  
    When multiple QNames are specified, 
    the query matches if any QName matches.
  </apidoc:param>
      <apidoc:param name="text" type="xs:string*" optional="false">
    One or more element values to match.  
    When multiple strings are specified, 
    the query matches if any string matches. 
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive query.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive query.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive query.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive query.</dd>
        <dt>"punctuation-sensitive"</dt>
        <dd>A punctuation-sensitive query.</dd>
        <dt>"punctuation-insensitive"</dt>
        <dd>A punctuation-insensitive query.</dd>
        <dt>"whitespace-sensitive"</dt>
        <dd>A whitespace-sensitive query.</dd>
        <dt>"whitespace-insensitive"</dt>
        <dd>A whitespace-insensitive query.</dd>
        <dt>"stemmed"</dt>
        <dd>A stemmed query.</dd> 
        <dt>"unstemmed"</dt>
        <dd>An unstemmed query.</dd>
        <dt>"wildcarded"</dt>
        <dd>A wildcarded query.</dd>
        <dt>"unwildcarded"</dt>
        <dd>An unwildcarded query.</dd>
        <dt>"exact"</dt>
        <dd>An exact match query. Shorthand for "case-sensitive",
        "diacritic-sensitive", "punctuation-sensitive", 
        "whitespace-sensitive", "unstemmed", and "unwildcarded".
        </dd>
        <dt>"lang=<em>iso639code</em>"</dt>
        <dd>Specifies the language of the query. The <em>iso639code</em>
            code portion is case-insensitive, and uses the languages
            specified by 
           <a href="http://www.loc.gov/standards/iso639-2/php/code_list.php" target="_blank">ISO 639</a>.
            The default is specified in the database configuration.</dd>
        <dt>"min-occurs=<em>number</em>"</dt>
        <dd>Specifies the minimum number of occurrences required. If 
        fewer that this number of words occur, the fragment does not match.
        The default is 1.</dd>
        <dt>"max-occurs=<em>number</em>"</dt>
        <dd>Specifies the maximum number of occurrences required.  If
        more than this number of words occur, the fragment does not match.
        The default is unbounded.</dd>
      </dl></blockquote>

  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.
    Higher weights move search results up in the relevance
    order.  The default is 1.0. The 
    weight should be less than or equal to the absolute value of 16 (between 
    -16 and 16); weights greater than 16 will have the same effect as a 
    weight of 16. 
    Weights less than the absolute value of 0.0625 (between -0.0625 and
    0.0625) are rounded to 0, which means that they do not contribute to the 
    score.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:element-value-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive" 
    is present, $text is used to determine case sensitivity.
    If $text contains no uppercase, it specifies "case-insensitive".
    If $text contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive" 
    is present, $text is used to determine diacritic sensitivity.
    If $text contains no diacritics, it specifies "diacritic-insensitive".
    If $text contains diacritics, it specifies "diacritic-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "punctuation-sensitive" nor "punctuation-insensitive" 
    is present, $text is used to determine punctuation sensitivity.
    If $text contains no punctuation, it specifies "punctuation-insensitive".
    If $text contains punctuation, it specifies "punctuation-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "whitespace-sensitive" nor "whitespace-insensitive" 
    is present, the query is "whitespace-insensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "stemmed" nor "unstemmed" 
    is present, the database configuration determines stemming.
    If the database has "stemmed searches" enabled, it specifies "stemmed".  
    Otherwise it specifies "unstemmed".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "wildcarded" nor "unwildcarded" 
    is present, the database configuration and $text determine wildcarding.
    If the database has any wildcard indexes enabled ("three character 
    searches", "two character searches", "one character searches",  or
    "trailing wildcard searches") and if $text contains either of the 
    wildcard characters '?' or '*', it specifies "wildcarded".  
    Otherwise it specifies "unwildcarded".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "stemmed" nor "unstemmed" 
    is present, then the database configuration determines if a query
    is run as "stemmed" (stemmed searches enabled) or "unstemmed" 
    (word searches enabled and stemmed searches disabled).  
    If the query is a wildcard
    query and is also a phrase query (contains two or more terms),  
    then any wildcard terms in the query will be "unstemmed".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    Negative "min-occurs" or "max-occurs" values will be treated as 0 and
    non-integral values will be rounded down.  An error will be raised if
    the "min-occurs" value is greater than the "max-occurs" value.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml"> Note that the text content for the value in a 
  <code>cts:element-value-query</code> is treated the same as a phrase in a
  <code>cts:word-query</code>, where the phrase is the element value. 
  Therefore, any wildcard and/or stemming rules are treated like a phrase.  
  For example, if you have an element value of "hello friend" with wildcarding 
  enabled for a query, a <code>cts:element-value-query</code> for "he*" will
  not match because the wildcard matches do not span word boundaries, but a  
  <code>cts:element-value-query</code> for "hello *" will match.  A search
  for "*" will match, because a "*" wildcard by itself is defined to match
  the value.  Similarly, stemming rules are applied to each term, so a
  search for "hello friends" would match when stemming is enabled for the query
  because "friends" matches "friend". For an example, see the 
  <a href="#evq4">fourth example</a> below.</p>
  <p xmlns="http://www.w3.org/1999/xhtml"> Similarly, because a "*" wildcard by itself is defined to match
  the value, the following query will match any element with the 
  QName <code>my-element</code>, regardless of the wildcard indexes enabled in
  the database configuration:
  <pre xml:space="preserve"><code>cts:element-value-query(xs:QName("my-element"), "*", "wildcarded")</code></pre>
  </p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:element-value-query(
      xs:QName("function"), 
      "MarkLogic Corporation"))
  <br/>
  =&gt; .. relevance-ordered sequence of 'module' element
  ancestors of 'function' elements whose text
  content equals 'MarkLogic Corporation'.
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:element-value-query(
      xs:QName("function"), 
      "MarkLogic Corporation", "case-insensitive"))
  <br/>
  =&gt; .. relevance-ordered sequence of 'module' element
  ancestors of 'function' elements whose text
  content equals 'MarkLogic Corporation', or any other 
  case-shift like 'MARKLOGIC CorpoRation'.
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:and-query((
      cts:element-value-query(
        xs:QName("function"), 
        "MarkLogic Corporation",
        "punctuation-insensitive", 0.5),
      cts:element-value-query(
        xs:QName("title"),
        "Word Query"))))
  =&gt; .. relevance-ordered sequence of 'module' elements
  which are ancestors of both:
  (a) 'function' elements with text content equal to
      'MarkLogic Corporation', ignoring embedded 
      punctuation,
  AND
  (b) 'title' elements with text content equal to 
      'Word Query', with the results of the first sub-query
      query given weight 0.5, and the results of the second
      sub-query given the default weight 1.0.  As a result,
      the title phrase 'Word Query' counts more heavily
      towards the relevance score.
</pre></apidoc:example>
    <apidoc:example><a id="evq4" xmlns="http://www.w3.org/1999/xhtml"></a><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $node := &lt;my-node&gt;hello friend&lt;/my-node&gt;
return (
cts:contains($node, cts:element-value-query(xs:QName('my-node'), 
      "hello friends", "stemmed")),
cts:contains($node, cts:element-value-query(xs:QName('my-node'), 
      "he*", "wildcarded")),
cts:contains($node, cts:element-value-query(xs:QName('my-node'), 
      "hello f*", "wildcarded"))
)

=&gt; true
   false
   true
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-value-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-value-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-value-query(
              xs:QName("function"),
              "MarkLogic Corporation")
return cts:element-value-query-element-name($query)

  =&gt; xs:QName("function")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-value-query-text" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the text used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-value-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-value-query-text($query)
  =&gt; "choice of law"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-value-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-value-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-value-query-options($query)
  =&gt; ("case-sensitive", "punctuation-insensitive")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-value-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-value-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-value-query-weight($query)
  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-word-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a query matching elements by name with text content containing 
  a given phrase.  Searches only through immediate text node children of 
  the specified element as well as any text node children of child elements 
  defined in the Admin Interface as element-word-query-throughs 
  or phrase-throughs; does not search through any other children of 
  the specified element.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-name" type="xs:QName*" optional="false">
    One or more element QNames to match.  
    When multiple QNames are specified, 
    the query matches if any QName matches.
  </apidoc:param>
      <apidoc:param name="text" type="xs:string*" optional="false">
    Some words or phrases to match. 
    When multiple strings are specified, 
    the query matches if any string matches. 
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive query.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive query.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive query.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive query.</dd>
        <dt>"punctuation-sensitive"</dt>
        <dd>A punctuation-sensitive query.</dd>
        <dt>"punctuation-insensitive"</dt>
        <dd>A punctuation-insensitive query.</dd>
        <dt>"whitespace-sensitive"</dt>
        <dd>A whitespace-sensitive query.</dd>
        <dt>"whitespace-insensitive"</dt>
        <dd>A whitespace-insensitive query.</dd>
        <dt>"stemmed"</dt>
        <dd>A stemmed query.</dd> 
        <dt>"unstemmed"</dt>
        <dd>An unstemmed query.</dd>
        <dt>"wildcarded"</dt>
        <dd>A wildcarded query.</dd>
        <dt>"unwildcarded"</dt>
        <dd>An unwildcarded query.</dd>
        <dt>"exact"</dt>
        <dd>An exact match query. Shorthand for "case-sensitive",
        "diacritic-sensitive", "punctuation-sensitive", 
        "whitespace-sensitive", "unstemmed", and "unwildcarded".
        </dd>
        <dt>"lang=<em>iso639code</em>"</dt>
        <dd>Specifies the language of the query. The <em>iso639code</em>
            code portion is case-insensitive, and uses the languages
            specified by 
           <a href="http://www.loc.gov/standards/iso639-2/php/code_list.php" target="_blank">ISO 639</a>.
            The default is specified in the database configuration.</dd>
        <dt>"distance-weight=<em>number</em>"</dt>
        <dd>A weight applied based on the minimum distance between matches
        of this query.  Higher weights add to the importance of
        proximity (as opposed to term matches) when the relevance order is
        calculated.  
        The default value is 0.0 (no impact of proximity). The 
        weight should be less than or equal to the absolute value of 16 
        (between -16 and 16); weights greater than 16 will have the 
        same effect as a weight of 16. 
        This parameter has no effect if the <code>word positions</code>
        index is not enabled.  This parameter has no effect on searches that 
	use score-simple or score-random (because those scoring algorithms
	do not consider term frequency, proximity is irrelevant).
        </dd>
        <dt>"min-occurs=<em>number</em>"</dt>
        <dd>Specifies the minimum number of occurrences required. If 
        fewer that this number of words occur, the fragment does not match.
        The default is 1.</dd>
        <dt>"max-occurs=<em>number</em>"</dt>
        <dd>Specifies the maximum number of occurrences required.  If
        more than this number of words occur, the fragment does not match.
        The default is unbounded.</dd>
      </dl></blockquote>

  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.
    Higher weights move search results up in the relevance
    order.  The default is 1.0. The 
    weight should be less than or equal to the absolute value of 16 (between 
    -16 and 16); weights greater than 16 will have the same effect as a 
    weight of 16. 
    Weights less than the absolute value of 0.0625 (between -0.0625 and
    0.0625) are rounded to 0, which means that they do not contribute to the 
    score.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:element-word-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive" 
    is present, $text is used to determine case sensitivity.
    If $text contains no uppercase, it specifies "case-insensitive".
    If $text contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive" 
    is present, $text is used to determine diacritic sensitivity.
    If $text contains no diacritics, it specifies "diacritic-insensitive".
    If $text contains diacritics, it specifies "diacritic-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "punctuation-sensitive" nor "punctuation-insensitive" 
    is present, $text is used to determine punctuation sensitivity.
    If $text contains no punctuation, it specifies "punctuation-insensitive".
    If $text contains punctuation, it specifies "punctuation-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "whitespace-sensitive" nor "whitespace-insensitive" 
    is present, the query is "whitespace-insensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "stemmed" nor "unstemmed" 
    is present, the database configuration determines stemming.
    If the database has "stemmed searches" enabled, it specifies "stemmed".  
    Otherwise it specifies "unstemmed".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "wildcarded" nor "unwildcarded" 
    is present, the database configuration and $text determine wildcarding.
    If the database has any wildcard indexes enabled ("three character 
    searches", "two character searches", "one character searches",  or
    "trailing wildcard searches") and if $text contains either of the 
    wildcard characters '?' or '*', it specifies "wildcarded".  
    Otherwise it specifies "unwildcarded".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "stemmed" nor "unstemmed" 
    is present, then the database configuration determines if a query
    is run as "stemmed" (stemmed searches enabled) or "unstemmed" 
    (word searches enabled and stemmed searches disabled).  
    If the query is a wildcard
    query and is also a phrase query (contains two or more terms),  
    then any wildcard terms in the query will be "unstemmed".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    Negative "min-occurs" or "max-occurs" values will be treated as 0 and
    non-integral values will be rounded down.  An error will be raised if
    the "min-occurs" value is greater than the "max-occurs" value.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">Relevance adjustment for the "distance-weight" option depends on
  the closest proximity of any two matches of the query.  For example,
  <pre xml:space="preserve">
  cts:element-word-query(xs:QName("p"),("dog","cat"),("distance-weight=10"))
  </pre>
  will adjust relevance based on the distance between the closest pair of 
  matches of either "dog" or "cat" within an element named "p" 
  (the pair may consist only of matches of
  "dog", only of matches of "cat", or a match of "dog" and a match of "cat").
  </p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:element-word-query(
      xs:QName("function"), 
      "MarkLogic Corporation"))
  <br/>
  =&gt; .. relevance-ordered sequence of 'module' elements
  ancestors (or self) of elements with QName 'function'
  and text content containing the phrase 'MarkLogic 
  Corporation'.
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:element-word-query(
      xs:QName("function"), 
        "MarkLogic Corporation", "case-sensitive"))
  <br/>
  =&gt; .. relevance-ordered sequence of 'module' elements
  ancestors (or self) of elements with QName 'function'
  and text content containing the phrase 'MarkLogic 
  Corporation',
  or any other case-shift, like 'MarkLogic Corporation'.
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:and-query((
      cts:element-word-query(
        xs:QName("function"), 
        "MarkLogic Corporation",
        ("case-insensitive", "punctuation-insensitive"), 0.5),
      cts:element-word-query(
        xs:QName("title"), 
        "faster"))))
  <br/>
  =&gt; .. relevance-ordered sequence of 'module' element
  ancestors (or self) of both:
  (a) 'function' elements with text content containing
      the phrase 'MarkLogic Corporation', ignoring embedded 
      punctuation,
  AND
  (b) 'title' elements containing the word 'faster',
      with the results of the first sub-query query given
      weight 0.5, and the results of the second sub-query
      given the default weight 1.0.  As a result, the title
      term 'faster' counts more towards the relevance 
      score.
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-word-query-text" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the text used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-word-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-word-query-text($query)
  =&gt; "choice of law"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-word-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-word-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-word-query(
              xs:QName("function"),
              "MarkLogic Corporation")
return cts:element-word-query-element-name($query)

  =&gt; xs:QName("function")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-word-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-word-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-word-query-options($query)
  =&gt; ("case-sensitive", "punctuation-insensitive")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-word-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-word-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-word-query-weight($query)
  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-word-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a query matching text content containing a given phrase in the 
  specified field.  If the specified field does not exist, 
  <code xmlns="http://www.w3.org/1999/xhtml">cts:field-word-query</code> throws an exception.  A field
  is a named object that specified elements to include and exclude
  from a search, and can include score weights for any included elements. 
  You create fields at the database level using the Admin Interface.  For 
  details on fields, see the chapter on "Fields Database Settings" in the
  <em xmlns="http://www.w3.org/1999/xhtml">Administrator's Guide</em>.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="field-name" type="xs:string*" optional="false">
    One or more field names to search over. If multiple field names are
    supplied, the match can be in any of the specified fields (or-query
    semantics).
  </apidoc:param>
      <apidoc:param name="text" type="xs:string*" optional="false">
    The word or phrase to match. If multiple strings are specified, 
    the query matches if any of the words or phrases match (or-query
    semantics). 
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive query.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive query.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive query.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive query.</dd>
        <dt>"punctuation-sensitive"</dt>
        <dd>A punctuation-sensitive query.</dd>
        <dt>"punctuation-insensitive"</dt>
        <dd>A punctuation-insensitive query.</dd>
        <dt>"whitespace-sensitive"</dt>
        <dd>A whitespace-sensitive query.</dd>
        <dt>"whitespace-insensitive"</dt>
        <dd>A whitespace-insensitive query.</dd>
        <dt>"stemmed"</dt>
        <dd>A stemmed query.</dd> 
        <dt>"unstemmed"</dt>
        <dd>An unstemmed query.</dd>
        <dt>"wildcarded"</dt>
        <dd>A wildcarded query.</dd>
        <dt>"unwildcarded"</dt>
        <dd>An unwildcarded query.</dd>
        <dt>"exact"</dt>
        <dd>An exact match query. Shorthand for "case-sensitive",
        "diacritic-sensitive", "punctuation-sensitive", 
        "whitespace-sensitive", "unstemmed", and "unwildcarded".
        </dd>
        <dt>"lang=<em>iso639code</em>"</dt>
        <dd>Specifies the language of the query. The <em>iso639code</em>
            code portion is case-insensitive, and uses the languages
            specified by 
           <a href="http://www.loc.gov/standards/iso639-2/php/code_list.php" target="_blank">ISO 639</a>.
            The default is specified in the database configuration.</dd>
	<dt>"distance-weight=<em>number</em>"</dt>
        <dd>A weight applied based on the minimum distance between matches
        of this query.  Higher weights add to the importance of
        proximity (as opposed to term matches) when the relevance order is
        calculated.  
        The default value is 0.0 (no impact of proximity). The 
        weight should be less than or equal to the absolute value of 16 
        (between -16 and 16); weights greater than 16 will have the 
        same effect as a weight of 16. 
        This parameter has no effect if the <code>word positions</code>
        index is not enabled.  This parameter has no effect on searches that 
	use score-simple or score-random (because those scoring algorithms
	do not consider term frequency, proximity is irrelevant).
        </dd>
        <dt>"min-occurs=<em>number</em>"</dt>
        <dd>Specifies the minimum number of occurrences required. If 
        fewer that this number of words occur, the fragment does not match.
        The default is 1.</dd>
        <dt>"max-occurs=<em>number</em>"</dt>
        <dd>Specifies the maximum number of occurrences required.  If
        more than this number of words occur, the fragment does not match.
        The default is unbounded.</dd>
      </dl></blockquote>

  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.
    Higher weights move search results up in the relevance
    order.  The default is 1.0. The 
    weight should be less than or equal to the absolute value of 16 (between 
    -16 and 16); weights greater than 16 will have the same effect as a 
    weight of 16. 
    Weights less than the absolute value of 0.0625 (between -0.0625 and
    0.0625) are rounded to 0, which means that they do not contribute to the 
    score.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:field-word-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">If you use <code>cts:near-query</code> with 
  <code>cts:field-word-query</code>, the distance supplied in the near query
  applies to the whole document, not just to the field.  For example, if 
  you specify a near query with a distance of 3, it will return matches 
  when the words or phrases are within 3 words in the whole document, 
  even if some of those words are not in the specified field.  For a code
  example illustrating this, see the <a href="#fqex2">second example</a> 
  below. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">Phrases are determined based on words being next to each other 
  (word positions with a distance of 1) and words being in the same
  instance of the field.  Because field word positions
  are determined based on the fragment, not on the field, field phrases
  cannot span excluded elements (this is because MarkLogic Server breaks 
  out of the field when it encounters the excluded element and start a new 
  field when it encounters the next included element).  Similarly, field 
  phrases will not span included sibling elements.  The 
  <a href="#fqex2">second code example below</a> illustrates this. </p>
  <p xmlns="http://www.w3.org/1999/xhtml">Field phrases will automatically phrase-through all child elements of
  an included element, until it encounters an explicitly excluded 
  element. The <a href="#fqex3">third example</a> below illustrates this. 
  An example of when this automatic phrase-through behavior might be 
  convenient is if you create a field that includes only the element 
  <code>ABSTRACT</code>.  Then all child elements of <code>ABSTRACT</code>
  are included in the field, and phrases would span all of the child 
  elements (that is, phrases would "phrase-through" all the child elements).</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    Negative "min-occurs" or "max-occurs" values will be treated as 0 and
    non-integral values will be rounded down.  An error will be raised if
    the "min-occurs" value is greater than the "max-occurs" value.
  </p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:search(fn:doc(), cts:field-word-query("myField", "my phrase"))

=&gt; a list of documents that contain the phrase
   "my phrase" in the field "myField". The field
   must exist in the database against which this query
   is evaluated.
</pre></apidoc:example>
    <apidoc:example><a id="fqex2" xmlns="http://www.w3.org/1999/xhtml"></a><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: 
   Assume the database has a field named 
   "buzz" with the element "buzz"
   included and the element "baz" excluded. 
:)
let $x := 
&lt;hello&gt;word1 word2 word3
  &lt;buzz&gt;word4 word5&lt;/buzz&gt;
  &lt;baz&gt;word6 word7 word8&lt;/baz&gt;
  &lt;buzz&gt;word9 word10&lt;/buzz&gt;
&lt;/hello&gt;
return (
cts:contains($x, cts:near-query(
  (cts:field-word-query("buzz", "word5"), 
   cts:field-word-query("buzz", "word9")), 3)),
cts:contains($x, cts:near-query(
  (cts:field-word-query("buzz", "word5"), 
   cts:field-word-query("buzz", "word9")), 4)),
cts:contains($x, 
  cts:field-word-query("buzz", "word5 word9")))
(: 
   Returns the sequence ("false", "true", "false").
   The first part does not match because 
   the distance between "word5" and "word9" 
   is 4.  This is because the distance is 
   calculated based on the whole node (if the
   document was in a database, based on the 
   fragment), not based on the field. The 
   second part specifies a distance of 4, and 
   therefore matches and returns true. The third 
   part does not match because the phrase is 
   based on the entire node, not on the field, 
   and there are words between "word5" and "word9" 
   in the node (even though not in the field).
:)

</pre></apidoc:example>
    <apidoc:example><a id="fqex3" xmlns="http://www.w3.org/1999/xhtml"></a><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: 
   Assume the database has a field named 
   "buzz" with the element "buzz"
   included and the element "baz" excluded. 
:)
let $x := 
&lt;hello&gt;
  &lt;buzz&gt;word1 word2
    &lt;gads&gt;word3 word4 word5&lt;/gads&gt;
    &lt;zukes&gt;word6 word7 word8&lt;/zukes&gt;
  word9 word10
  &lt;/buzz&gt;
&lt;/hello&gt;
return (
cts:contains($x, 
  cts:field-word-query("buzz", "word2 word3")))
(: 
   Returns "true" because the children of
   "buzz" are not excluded, and are therefore
   automatically phrased through.
:)

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-word-query-text" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the text used to construct the specified 
  <code xmlns="http://www.w3.org/1999/xhtml">cts:field-word-query</code>.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:field-word-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:field-word-query("myField", "choice of law")
return
cts:field-word-query-text($query)

=&gt; "choice of law"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-word-query-field-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the names used to construct the specified 
  <code xmlns="http://www.w3.org/1999/xhtml">cts:field-word-query</code>.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:field-word-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:field-word-query(
                "function",
                "MarkLogic Corporation")
return 
cts:field-word-query-element-name($query)

  =&gt; "function"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-word-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the options for the specified 
  <code xmlns="http://www.w3.org/1999/xhtml">cts:field-word-query</code>.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:field-word-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:field-word-query("myField",
      "to be or not to be",
      ("case-sensitive", "punctuation-insensitive"))
return
cts:field-word-query-options($query)
  =&gt; ("case-sensitive", "punctuation-insensitive", "lang=en")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-word-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:field-word-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:field-word-query-weight($query)
  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-range-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> matching elements by name with a 
  range-index entry equal a given value.  Searches with the 
  <code xmlns="http://www.w3.org/1999/xhtml">cts:element-attribute-range-query</code> 
  constructor require an attribute range index on the specified QName(s); 
  if there is no range index configured, then an exception is thrown. 
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-name" type="xs:QName*" optional="false">
    One or more element QNames to match.  
    When multiple QNames are specified, 
    the query matches if any QName matches.
  </apidoc:param>
      <apidoc:param name="attribute-name" type="xs:QName*" optional="false">
    One or more attribute QNames to match.  
    When multiple QNames are specified, 
    the query matches if any QName matches.
  </apidoc:param>
      <apidoc:param name="operator" type="xs:string" optional="false">
    A comparison operator.  
    <p xmlns="http://www.w3.org/1999/xhtml">
      Operators include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"&lt;"</dt>
        <dd>Match range index values less than $value.</dd>
        <dt>"&lt;="</dt>
        <dd>Match range index values less than or equal to $value.</dd>
        <dt>"&gt;"</dt>
        <dd>Match range index values greater than $value.</dd>
        <dt>"&gt;="</dt>
        <dd>Match range index values greater than or equal to $value.</dd>
        <dt>"="</dt>
        <dd>Match range index values equal to $value.</dd>
        <dt>"!="</dt>
        <dd>Match range index values not equal to $value.</dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="value" type="xs:anyAtomicType*" optional="false">
    Some values to match.  
    When multiple values are specified, 
    the query matches if any value matches. 
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the range index with the collation specified by 
        <em>URI</em>.  If not specified, then the default collation
        from the query is used. If a range index with the specified
        collation does not exist, an error is thrown.</dd>
        <dt>"cached"</dt>
        <dd>Cache the results of this query in the list cache.</dd>
        <dt>"uncached"</dt>
        <dd>Do not cache the results of this query in the list cache.</dd>
        <dt>"min-occurs=<em>number</em>"</dt>
        <dd>Specifies the minimum number of occurrences required. If 
        fewer that this number of words occur, the fragment does not match.
        The default is 1.</dd>
        <dt>"max-occurs=<em>number</em>"</dt>
        <dd>Specifies the maximum number of occurrences required.  If
        more than this number of words occur, the fragment does not match.
        The default is unbounded.</dd>
      </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.  The default is 1.0.  In the current release, 
    this option is ignored; range queries do not contribute to the score.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:element-attribute-range-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">If you want to constrain on a range of values, you can combine multiple
  <code>cts:element-attribute-range-query</code> constructors together
  with <code>cts:and-query</code> or other composable <code>cts:query</code>
  constructors.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If neither "cached" not "uncached" is present, it specifies "cached".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    Negative "min-occurs" or "max-occurs" values will be treated as 0 and
    non-integral values will be rounded down.  An error will be raised if
    the "min-occurs" value is greater than the "max-occurs" value.
  </p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: create a document with test data :)
xdmp:document-insert("/attributes.xml",
&lt;root&gt;
  &lt;entry sku="100"&gt;
    &lt;product&gt;apple&lt;/product&gt;
  &lt;/entry&gt;
  &lt;entry sku="200"&gt;
    &lt;product&gt;orange&lt;/product&gt;
  &lt;/entry&gt;
  &lt;entry sku="1000"&gt;
    &lt;product&gt;electric car&lt;/product&gt;
  &lt;/entry&gt;
&lt;/root&gt;) ;

(: 
   requires an attribute (range) index of 
   type xs:int on the "sku" attribute of
   the "entry" element 
:)
cts:search(doc("/attributes.xml")/root/entry, 
  cts:element-attribute-range-query(
      xs:QName("entry"), xs:QName("sku"), "&gt;=",
      500))
(:
  returns the following node: 
  &lt;entry sku="1000"&gt;
    &lt;product&gt;electric car&lt;/product&gt;
  &lt;/entry&gt;
:)
</pre>
</apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-range-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-range-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-range-query(
              xs:QName("function"),
              xs:QName("name"),
              "MarkLogic Corporation")
return cts:element-attribute-range-query-element-name($query)

  =&gt; xs:QName("function")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-range-query-attribute-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-range-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-range-query(
              xs:QName("function"),
              xs:QName("name"),
              "MarkLogic Corporation")
return cts:element-attribute-range-query-attribute-name($query)

  =&gt; xs:QName("name")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-range-query-operator" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the operator used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-range-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-attribute-range-query-operator($query)
  =&gt; "&lt;"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-range-query-value" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the value used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-range-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-attribute-range-query-value($query)
  =&gt; 123
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-range-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-range-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-attribute-range-query-options($query)
  =&gt; "collation=http://marklogic.com/collation/"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-range-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-range-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-attribute-range-query-weight($query)
  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-value-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a query matching elements by name with attributes by name 
  with text content equal a given phrase. 
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-name" type="xs:QName*" optional="false">
    One or more element QNames to match.  
    When multiple QNames are specified, 
    the query matches if any QName matches. 
  </apidoc:param>
      <apidoc:param name="attribute-name" type="xs:QName*" optional="false">
    One or more attribute QNames to match.  
    When multiple QNames are specified, 
    the query matches if any QName matches. 
  </apidoc:param>
      <apidoc:param name="text" type="xs:string*" optional="false">
    One or more attribute values to match.  
    When multiple strings are specified, 
    the query matches if any string matches. 
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive query.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive query.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive query.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive query.</dd>
        <dt>"punctuation-sensitive"</dt>
        <dd>A punctuation-sensitive query.</dd>
        <dt>"punctuation-insensitive"</dt>
        <dd>A punctuation-insensitive query.</dd>
        <dt>"whitespace-sensitive"</dt>
        <dd>A whitespace-sensitive query.</dd>
        <dt>"whitespace-insensitive"</dt>
        <dd>A whitespace-insensitive query.</dd>
        <dt>"stemmed"</dt>
        <dd>A stemmed query.</dd> 
        <dt>"unstemmed"</dt>
        <dd>An unstemmed query.</dd>
        <dt>"wildcarded"</dt>
        <dd>A wildcarded query.</dd>
        <dt>"unwildcarded"</dt>
        <dd>An unwildcarded query.</dd>
        <dt>"exact"</dt>
        <dd>An exact match query. Shorthand for "case-sensitive",
        "diacritic-sensitive", "punctuation-sensitive", 
        "whitespace-sensitive", "unstemmed", and "unwildcarded".
        </dd>
        <dt>"lang=<em>iso639code</em>"</dt>
        <dd>Specifies the language of the query. The <em>iso639code</em>
            code portion is case-insensitive, and uses the languages
            specified by 
           <a href="http://www.loc.gov/standards/iso639-2/php/code_list.php" target="_blank">ISO 639</a>.
            The default is specified in the database configuration.</dd>
        <dt>"min-occurs=<em>number</em>"</dt>
        <dd>Specifies the minimum number of occurrences required. If 
        fewer that this number of words occur, the fragment does not match.
        The default is 1.</dd>
        <dt>"max-occurs=<em>number</em>"</dt>
        <dd>Specifies the maximum number of occurrences required.  If
        more than this number of words occur, the fragment does not match.
        The default is unbounded.</dd>
      </dl></blockquote>

  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.
    Higher weights move search results up in the relevance
    order.  The default is 1.0. The 
    weight should be less than or equal to the absolute value of 16 (between 
    -16 and 16); weights greater than 16 will have the same effect as a 
    weight of 16. 
    Weights less than the absolute value of 0.0625 (between -0.0625 and
    0.0625) are rounded to 0, which means that they do not contribute to the 
    score.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:element-attribute-value-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive" 
    is present, $text is used to determine case sensitivity.
    If $text contains no uppercase, it specifies "case-insensitive".
    If $text contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive" 
    is present, $text is used to determine diacritic sensitivity.
    If $text contains no diacritics, it specifies "diacritic-insensitive".
    If $text contains diacritics, it specifies "diacritic-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "punctuation-sensitive" nor "punctuation-insensitive" 
    is present, $text is used to determine punctuation sensitivity.
    If $text contains no punctuation, it specifies "punctuation-insensitive".
    If $text contains punctuation, it specifies "punctuation-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "whitespace-sensitive" nor "whitespace-insensitive" 
    is present, the query is "whitespace-insensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "stemmed" nor "unstemmed" 
    is present, the database configuration determines stemming.
    If the database has "stemmed searches" enabled, it specifies "stemmed".  
    Otherwise it specifies "unstemmed".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "wildcarded" nor "unwildcarded" 
    is present, the database configuration and $text determine wildcarding.
    If the database has any wildcard indexes enabled ("three character 
    searches", "two character searches", "one character searches",  or
    "trailing wildcard searches") and if $text contains either of the 
    wildcard characters '?' or '*', it specifies "wildcarded".  
    Otherwise it specifies "unwildcarded".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "stemmed" nor "unstemmed" 
    is present, then the database configuration determines if a query
    is run as "stemmed" (stemmed searches enabled) or "unstemmed" 
    (word searches enabled and stemmed searches disabled).  
    If the query is a wildcard
    query and is also a phrase query (contains two or more terms),  
    then any wildcard terms in the query will be "unstemmed".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    Negative "min-occurs" or "max-occurs" values will be treated as 0 and
    non-integral values will be rounded down.  An error will be raised if
    the "min-occurs" value is greater than the "max-occurs" value.
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When multiple element and/or attribute QNames are specified,
  then all possible element/attribute QName combinations are used
  to select the matching values.</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:element-attribute-value-query(
      xs:QName("function"), 
      xs:QName("type"), 
      "MarkLogic Corporation"))
  <br/>
  =&gt; .. relevance-ordered sequence of 'module' element
  ancestors (or self) of 'function' elements that have
  an attribute 'type' whose value equals 'MarkLogic 
  Corporation'.
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:and-query((
      cts:element-attribute-value-query(
        xs:QName("function"), 
        xs:QName("type"), 
        "MarkLogic Corporation",
        false(), true(), 0.5),
      cts:element-word-query(
        xs:QName("title"), 
        "faster"))))
  <br/>
  =&gt; .. relevance-ordered sequence of 'module' element
  ancestors (or self) of both:
   (a) 'function' elements with attribute 'type' whose
       value equals the string 'MarkLogic Corporation', 
       ignoring embedded punctuation,
   AND
   (b) 'title' elements whose text content contains the
       word 'faster', with the results from (a) given
       weight 0.5, and the results from (b) given default
       weight 1.0.
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-value-query-text" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the text used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-value-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-attribute-value-query-text($query)
  =&gt; "choice of law"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-value-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the element QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-value-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-value-query(
              xs:QName("function"),
              xs:QName("type"),
              "MarkLogic Corporation")
return 
  cts:element-attribute-value-query-element-name($query)

  =&gt; xs:QName("function")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-value-query-attribute-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the attribute QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-value-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-value-query(
              xs:QName("function"),
              xs:QName("type"),
              "MarkLogic Corporation")
return 
  cts:element-attribute-value-query-attribute-name($query)

  =&gt; xs:QName("type")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-value-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-value-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-attribute-value-query-options($query)
  =&gt; ("case-sensitive", "punctuation-insensitive")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-value-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-value-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-attribute-value-query-weight($query)
  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-word-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a query matching elements by name
  with attributes by name
  with text content containing a given phrase.  
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-name" type="xs:QName*" optional="false">
    One or more element QNames to match.  
    When multiple QNames are specified, 
    the query matches if any QName matches. 
  </apidoc:param>
      <apidoc:param name="attribute-name" type="xs:QName*" optional="false">
    One or more attribute QNames to match.  
    When multiple QNames are specified, 
    the query matches if any QName matches. 
  </apidoc:param>
      <apidoc:param name="text" type="xs:string*" optional="false">
    Some words or phrases to match. 
    When multiple strings are specified, 
    the query matches if any string matches. 
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive query.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive query.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive query.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive query.</dd>
        <dt>"punctuation-sensitive"</dt>
        <dd>A punctuation-sensitive query.</dd>
        <dt>"punctuation-insensitive"</dt>
        <dd>A punctuation-insensitive query.</dd>
        <dt>"whitespace-sensitive"</dt>
        <dd>A whitespace-sensitive query.</dd>
        <dt>"whitespace-insensitive"</dt>
        <dd>A whitespace-insensitive query.</dd>
        <dt>"stemmed"</dt>
        <dd>A stemmed query.</dd> 
        <dt>"unstemmed"</dt>
        <dd>An unstemmed query.</dd>
        <dt>"wildcarded"</dt>
        <dd>A wildcarded query.</dd>
        <dt>"unwildcarded"</dt>
        <dd>An unwildcarded query.</dd>
        <dt>"exact"</dt>
        <dd>An exact match query. Shorthand for "case-sensitive",
        "diacritic-sensitive", "punctuation-sensitive", 
        "whitespace-sensitive", "unstemmed", and "unwildcarded".
        </dd>
        <dt>"lang=<em>iso639code</em>"</dt>
        <dd>Specifies the language of the query. The <em>iso639code</em>
            code portion is case-insensitive, and uses the languages
            specified by 
           <a href="http://www.loc.gov/standards/iso639-2/php/code_list.php" target="_blank">ISO 639</a>.
            The default is specified in the database configuration.</dd>
        <dt>"min-occurs=<em>number</em>"</dt>
        <dd>Specifies the minimum number of occurrences required. If 
        fewer that this number of words occur, the fragment does not match.
        The default is 1.</dd>
        <dt>"max-occurs=<em>number</em>"</dt>
        <dd>Specifies the maximum number of occurrences required.  If
        more than this number of words occur, the fragment does not match.
        The default is unbounded.</dd>
      </dl></blockquote>

  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.
    Higher weights move search results up in the relevance
    order.  The default is 1.0. The 
    weight should be less than or equal to the absolute value of 16 (between 
    -16 and 16); weights greater than 16 will have the same effect as a 
    weight of 16. 
    Weights less than the absolute value of 0.0625 (between -0.0625 and
    0.0625) are rounded to 0, which means that they do not contribute to the 
    score.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:element-attribute-word-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive" 
    is present, $text is used to determine case sensitivity.
    If $text contains no uppercase, it specifies "case-insensitive".
    If $text contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive" 
    is present, $text is used to determine diacritic sensitivity.
    If $text contains no diacritics, it specifies "diacritic-insensitive".
    If $text contains diacritics, it specifies "diacritic-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "punctuation-sensitive" nor "punctuation-insensitive" 
    is present, $text is used to determine punctuation sensitivity.
    If $text contains no punctuation, it specifies "punctuation-insensitive".
    If $text contains punctuation, it specifies "punctuation-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "whitespace-sensitive" nor "whitespace-insensitive" 
    is present, the query is "whitespace-insensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "stemmed" nor "unstemmed" 
    is present, the database configuration determines stemming.
    If the database has "stemmed searches" enabled, it specifies "stemmed".  
    Otherwise it specifies "unstemmed".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "wildcarded" nor "unwildcarded" 
    is present, the database configuration and $text determine wildcarding.
    If the database has any wildcard indexes enabled ("three character 
    searches", "two character searches", "one character searches",  or
    "trailing wildcard searches") and if $text contains either of the 
    wildcard characters '?' or '*', it specifies "wildcarded".  
    Otherwise it specifies "unwildcarded".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "stemmed" nor "unstemmed" 
    is present, then the database configuration determines if a query
    is run as "stemmed" (stemmed searches enabled) or "unstemmed" 
    (word searches enabled and stemmed searches disabled).  
    If the query is a wildcard
    query and is also a phrase query (contains two or more terms),  
    then any wildcard terms in the query will be "unstemmed".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    Negative "min-occurs" or "max-occurs" values will be treated as 0 and
    non-integral values will be rounded down.  An error will be raised if
    the "min-occurs" value is greater than the "max-occurs" value.
  </p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:element-attribute-word-query(
      xs:QName("function"), 
      xs:QName("type"), 
      "MarkLogic Corporation"))
  <br/>
  =&gt; .. relevance-ordered sequence of 'module' element
  ancestors of 'function' elements that have a 'type'
  attribute whose value contains the phrase 
  'MarkLogic Corporation'.
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:element-attribute-word-query(
      xs:QName("function"), 
      xs:QName("type"), 
      "MarkLogic Corporation", "case-insensitive"))
  <br/>
  =&gt; .. relevance-ordered sequence of 'module' element
  ancestors of 'function' elements that have a 'type'
  attribute whose value contains the phrase 
  'MarkLogic Corporation', or any other case-shift,
  like 'MARKLOGIC CorpoRation'.
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:and-query((
      cts:element-attribute-word-query(
        xs:QName("function"), 
        xs:QName("type"), 
        "MarkLogic Corporation",
        "punctuation-insensitive", 0.5),
      cts:element-word-query(
        xs:QName("title"), 
        "faster"))))
  <br/>
  =&gt; .. relevance-ordered sequence of 'module' element
  ancestors of both:
  (a) 'function' elements with 'type' attribute whose value
      contains the phrase 'MarkLogic Corporation', 
      ignoring embedded punctuation,
  AND
  (b) 'title' elements whose text content contains the
      term 'faster',
  with the results of the first query given weight 0.5,
  as opposed to the default 1.0 for the second query.
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-word-query-text" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the text used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-word-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-attribute-word-query-text($query)
  =&gt; "choice of law"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-word-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the element QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-word-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-word-query(
              xs:QName("function"),
              xs:QName("type"),
              "MarkLogic Corporation")
return 
  cts:element-attribute-word-query-element-name($query)

  =&gt; xs:QName("function")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-word-query-attribute-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the attribute QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-word-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-attribute-word-query(
              xs:QName("function"),
              xs:QName("type"),
              "MarkLogic Corporation")
return 
  cts:element-attribute-word-query-attribute-name($query)

  =&gt; xs:QName("type")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-word-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-word-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-attribute-word-query-options($query)
  =&gt; ("case-sensitive", "punctuation-insensitive")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-word-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-attribute-word-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-attribute-word-query-weight($query)
  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="similar-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a query matching nodes similar to the model nodes.  It uses an
  algorithm which finds the most "relevant" terms in the model nodes 
  (that is, the terms with the highest scores), and then creates a 
  query equivalent to a <code xmlns="http://www.w3.org/1999/xhtml">cts:or-query</code> of those terms.  By default
  16 terms are used.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="nodes" type="node()*" optional="false">
    Some model nodes.
  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.
    Higher weights move search results up in the relevance
    order.  The default is 1.0. The 
    weight should be less than or equal to the absolute value of 16 (between 
    -16 and 16); weights greater than 16 will have the same effect as a 
    weight of 16. 
    Weights less than the absolute value of 0.0625 (between -0.0625 and
    0.0625) are rounded to 0, which means that they do not contribute to the 
    score.
  </apidoc:param>
      <apidoc:param name="options" type="element()?" optional="true">
    An XML representation of the options for defining which terms to 
    generate and how to evaluate them.
    The options node must be in the <code xmlns="http://www.w3.org/1999/xhtml">cts:distinctive-terms</code>
    namespace. The following is a sample options node:
    <pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
    &lt;options xmlns="cts:distinctive-terms"&gt;
      &lt;max-terms&gt;20&lt;/max-terms&gt;
    &lt;/options&gt; </pre>
    
    <p xmlns="http://www.w3.org/1999/xhtml">See <a href="SearchBuiltins#db-term-options">the 
    <code>cts:distinctive-terms</code>
    options</a> for the valid options to use with this function.</p>
    <p xmlns="http://www.w3.org/1999/xhtml">Note that enabling index settings that
    are disabled in the database configuration will not affect the results, 
    as similar documents will not be found on the basis of terms that do 
    not exist in the actual database index.</p>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:similar-query</apidoc:return>
    <apidoc:usage>
   As the number of fragments in a database grows, the results 
   of <code xmlns="http://www.w3.org/1999/xhtml">cts:similar-query</code> become increasingly accurate.  
   For best results, there should be at least 10,000 fragments for 32-bit 
   systems, and 1,000 fragments for 64-bit systems.
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//function,
    cts:similar-query((//function)[1]))
  <br/>
  =&gt; .. relevance-ordered sequence of 'function' element
  ancestors (or self) of any node similar to the first 
  'function' element.
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
xdmp:estimate(
  cts:search(//function,
    cts:similar-query((//function)[1], (),
    &lt;options xmlns="cts:distinctive-terms"&gt;
      &lt;max-terms&gt;20&lt;/max-terms&gt;
      &lt;use-db-config&gt;true&lt;/use-db-config&gt;
    &lt;/options&gt;)))
=&gt; the number of fragments containing any node similar 
   to the first 'function' element.
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="similar-query-nodes" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the nodes used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:similar-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>node()*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:similar-query-nodes($query)
  =&gt; //function
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="similar-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:similar-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:similar-query-weight($query)
  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="contains" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns true if any of a sequence of nodes matches a query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="nodes" type="node()*" optional="false">
    Some nodes to be checked for a match.
  </apidoc:param>
      <apidoc:param name="query" type="cts:query" optional="false">
    A query to match against.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the 
   specified string.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:boolean?</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:contains(//PLAY
  [TITLE="The Tragedy of Hamlet, Prince of Denmark"]
      /ACT[3]/SCENE[1],
    cts:word-query("To be, or not to be"))
  =&gt; ..true, if ACT II, SCENE I of Hamlet contains
    the phrase "To be, or not to be" (it does).
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="search" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a relevance-ordered sequence of nodes specified by a given query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="expression" type="node()*" optional="false">
    An expression to be searched.  
    This must be an inline fully searchable path expression.
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="false">
    A <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> specifying the search to perform.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the 
   specified string.   
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this search.  The default is ().
    <a id="unfiltered" xmlns="http://www.w3.org/1999/xhtml"></a><p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt><p>"filtered"</p></dt>
        <dd><p>A filtered search (the default). Filtered searches 
        eliminate any false-positive matches and properly resolve cases where 
        there are multiple candidate matches within the same fragment. 
        Filtered search results fully satisfy the specified 
        <code>cts:query</code>.</p>
        </dd> 
        <dt><p>"unfiltered"</p></dt>
        <dd><p>
        An unfiltered search.  An unfiltered search
        selects fragments from the indexes that are candidates to satisfy
        the specified <code>cts:query</code>, and then it returns
        a single node from within each fragment that satisfies the specified 
        searchable path expression. Unfiltered searches are useful because 
        of the performance they afford when jumping deep into the 
        result set (for example, when paginating a long result set and 
        jumping to the 1,000,000th result). However, depending on the 
        searchable path expression, the 
        <code>cts:query</code> specified, the structure of the documents in 
        the database, and the configuration of the database, unfiltered 
        searches may yield false-positive results being included in the 
        search results.  Unfiltered searches may also result in missed 
        matches or in incorrect matches, especially when there are 
        multiple candidate matches within a single fragment. 
        To avoid these problems, you should only use unfiltered searches 
        on top-level XPath expressions (for example, document nodes, 
        collections, directories) or on fragment roots. Using unfiltered 
        searches on complex XPath expressions or on XPath expressions that
        traverse below a fragment root can result in unexpected results.</p> 
        </dd>
        <dt><p>"score-logtfidf"</p></dt>
        <dd><p>Compute scores using the logtfidf method (the default scoring 
        method). This uses the formula: <br/><br/>
        <code>log(term frequency) * (inverse document frequency)
        </code></p></dd>
        <dt><p>"score-logtf"</p></dt>
        <dd><p>Compute scores using the logtf method. This does not take into
        account how many documents have the term and uses the formula: <br/>
        <br/>
        <code>log(term frequency)</code></p></dd>
        <dt><p>"score-simple"</p></dt>
        <dd><p>Compute scores using the simple method. The score-simple
        method gives a score of 8*weight for each matching term in the 
        <code>cts:query</code> expression. It does not matter how 
        many times a given term matches (that is, the term 
        frequency does not matter); each match contributes 8*weight 
        to the score.  For example, the following query  (assume the 
        default weight of 1) would give a score of 8 for 
        any fragment with one or more matches for "hello", a score of 16 
        for any fragment that also has one or more matches for "goodbye", 
        or a score of zero for fragments that have no matches for 
        either term:<br/><br/>
        <code>cts:or-query(("hello", "goodbye"))</code></p></dd>
        <dt><p>"score-random"</p></dt>
        <dd><p>Compute scores using the random method. The score-random
        method gives a random value to the score.  You can use this 
        to randomly choose fragments matching a query.</p></dd>
        <dt>"checked"</dt>
        <dd><p>Word positions are checked (the default) when resolving 
        the query. Checked searches eliminate false-positive matches for
        phrases during the index resolution phase of search processing.</p></dd>
        <dt>"unchecked"</dt>
        <dd><p>Word positions are not checked when resolving the 
        query.  Unchecked searches do not take into account word positions
        and can lead to false-positive matches during the index resolution
        phase of search processing.  This setting is useful
        for debugging, but not recommended for normal use.</p></dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database. 
    The default is (). You can use <code xmlns="http://www.w3.org/1999/xhtml">cts:search</code> with this 
    parameter and an empty <code xmlns="http://www.w3.org/1999/xhtml">cts:and-query</code> to specify a 
    forest-specific XPath statement (see the <a href="#searchEx3" xmlns="http://www.w3.org/1999/xhtml">third 
    example</a> below). If you
    use this to constrain an XPath to one or more forests, you should set
    the <code xmlns="http://www.w3.org/1999/xhtml">quality-weight</code> to zero to keep the XPath document
    order.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>node()*</apidoc:return>
    <apidoc:usage>
<p xmlns="http://www.w3.org/1999/xhtml">Queries that use <code>cts:search</code> require that the XPath expression 
searched is fully searchable. A <em>fully searchable</em> path is one that 
has no steps that are unsearchable and whose last step is searchable. 
You can use the 
<code>xdmp:query-trace()</code> function to see if the path is fully 
searchable. If there are no entries in the <code>xdmp:query-trace()</code> 
output indicating that a step is unsearchable, and if the last step
is searchable, then that path is fully 
searchable. Queries that use <code>cts:search</code> on unsearchable 
XPath expressions will fail with an an error message. You can often make 
the path expressions fully searchable by rewriting the query or adding 
new indexes.</p>
<p xmlns="http://www.w3.org/1999/xhtml">Each node that <code>cts:search</code> returns has a score with which
it is associated. To access the score, use the <code>cts:score</code> 
function. The nodes are returned in relevance order (most relevant to least
relevant), where more relevant nodes have a higher score.</p>
<p xmlns="http://www.w3.org/1999/xhtml">Only one of the "filtered" or "unfiltered" options may be specified
in the options parameter. If neither "filtered" nor "unfiltered", is 
specified then the default is "filtered".</p>
<p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
or "score-random" options may be specified in the options parameter. 
If none of "score-logtfidf", "score-logtf", "score-simple", or 
"score-random" are specified, then the default is "score-logtfidf".</p>
<p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
in the options parameter.  If the neither "checked" nor "unchecked" are
specified, then the default is "checked".</p>
<p xmlns="http://www.w3.org/1999/xhtml">If the <code>cts:query</code> specified is the empty string (equivalent 
to <code>cts:word-query("")</code>), then the search returns the empty 
sequence.</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//SPEECH,
    cts:word-query("with flowers"))
  
  =&gt; ... a sequence of 'SPEECH' element ancestors (or self)
     of any node containing the phrase 'with flowers'.
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(collection("self-help")/book,
    cts:element-query(xs:QName("title"), "meditation"),
    "score-simple", 1.0, (xdmp:forest("prod"),xdmp:forest("preview")))

  =&gt; ... a sequence of book elements matching the XPath
     expression which are members of the "self-help"
     collection, reside in the the "prod" or "preview" forests and
     contain "meditation" in the title element, using the
     "score-simple" option.
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" id="searchEx3" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(/some/xpath, cts:and-query(()), (), 0.0,
    xdmp:forest("myForest"))

  =&gt; ... a sequence of /some/xpath elements that are
     in the forest named "myForest".  Note the 
     empty and-query, which matches all documents (and
     scores them all the same) and the quality-weight
     of 0, which together make each result have a score
     of 0, which keeps the results in document order.
</pre></apidoc:example>
    <algorithm type="internal" xmlns="http://www.w3.org/1999/xhtml">
The algorithm uses two stages.  The first stage
selects fragments which are candidates for the second stage.
The second stage does exact matching of nodes, attributes and
text by scanning the fragments.
<ul>
	<li>Construct a boolean query from the 'and', 'or', 'and-not'
queries, with term query leaf nodes.</li>
	<li>Submit the boolean term query to the inverted file
manager, which returns a sequence of fragments.</li>
	<li>Scan the fragment list and return a sequence of
element nodes exactly matching the query.</li>
	<li>The fragments are relevance ordered, and this order
is preserved throughout the subsequent scanning and matching.</li>
      </ul>
</algorithm>
  </apidoc:function><apidoc:function name="quality" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the quality of a node, 
  or of the context node if no node is provided.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="node" type="node()" optional="true">
    A node. Typically this is an item in the result sequence of a 
    <code xmlns="http://www.w3.org/1999/xhtml">cts:search</code> operation. 
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:integer</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">If you run <code>cts:quality</code> on a constructed node, it always
  returns 0; it is primarily intended to run on nodes that are the retrieved
  from the database (an item from a <code>cts:search</code> result or an 
  item from the result of an XPath expression that searches through the 
  database).</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  xdmp:document-insert("/test.xml", &lt;a&gt;my test&lt;/a&gt;, (), (), 50);
  for $x in cts:search(collection(),"my test")
  return cts:quality($x) =&gt; 50
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  for $a in cts:search(collection(),"my test")
  where $a[cts:quality() gt 10]
  return xdmp:node-uri($a) =&gt; /test.xml
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="score" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the score of a node, 
  or of the context node if no node is provided.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="node" type="node()" optional="true">
    A node. Typically this is an item in the result sequence of a 
    <code xmlns="http://www.w3.org/1999/xhtml">cts:search</code> operation. 
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:integer</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Score is computed according to the scoring method specified in the 
  <code>cts:search</code> expression, if any.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If you run <code>cts:score</code> on a constructed node, it always
  returns 0; it is primarily intended to run on nodes that are the retrieved
  from the database (an item from a <code>cts:search</code> result or an 
  item from the result of an XPath expression that searches through the 
  database).</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: run this on the Shakespeare content set :)
for $hit in cts:search(//SPEECH,
    cts:word-query("with flowers"))[1 to 10]
return element hit {
  attribute score { cts:score($hit) },
  $hit
}
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  xdmp:document-insert("/test.xml", &lt;a&gt;my test&lt;/a&gt;);
  for $x in cts:search(doc("/test.xml"),"my test")
  return cts:score($x) =&gt; 11
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  for $a in cts:search(collection(),"my test") 
  where $a[cts:score() gt 10]
  return xdmp:node-uri($a) =&gt; /test.xml
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="confidence" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the confidence of a node, 
  or of the context node if no node is provided.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="node" type="node()" optional="true">
    A node. Typically this is an item in the result sequence of a 
    <code xmlns="http://www.w3.org/1999/xhtml">cts:search</code> operation. 
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:float</apidoc:return>
    <apidoc:usage>
   <p xmlns="http://www.w3.org/1999/xhtml">Confidence is similar to score, except that it is bounded.
   It is similar to fitness, except that it is influenced by term IDFs.
   It is an <code>xs:float</code> in the range of 0.0 to 1.0.
   It does not include quality.</p>
   <p xmlns="http://www.w3.org/1999/xhtml">When using with any of the scoring methods, the confidence is 
   calculated by first bounding the score in the range of 0.0 to 1.0, 
   then taking the square root of that number.</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  let $x := cts:search(collection(), "dog")
  return
  cts:confidence($x[1])

   =&gt; Returns the confidence value for the first item
      in the search.
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="fitness" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the fitness of a node, 
  or of the context node if no node is provided. Fitness is a normalized 
  measure of relevance that is based on how well a node matches the query
  issued, not taking into account the number of documents in which
  the query term(s) occur.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="node" type="node()" optional="true">
    A node. Typically this is an item in the result sequence of a 
    <code xmlns="http://www.w3.org/1999/xhtml">cts:search</code> operation. 
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:float</apidoc:return>
    <apidoc:usage>
   <p xmlns="http://www.w3.org/1999/xhtml">Fitness is similar to score, except that it is bounded.
   It is similar to confidence, except that it is not influenced by term IDFs.
   It is an <code>xs:float</code> in the range of 0.0 to 1.0.
   It does not include quality.</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  let $x := cts:search(collection(), "dog")
  return
  cts:fitness($x[1])

   =&gt; Returns the fitness value for the first item
      in the search.
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="remainder" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns an estimated search result size for a node, 
  or of the context node if no node is provided.
  The search result size for a node is the number of fragments remaining
  (including the current node) in the result sequence containing the node.  
  This is useful to quickly estimate the size of a search result sequence, 
  without using <code xmlns="http://www.w3.org/1999/xhtml">fn:count()</code> or <code xmlns="http://www.w3.org/1999/xhtml">xdmp:estimate()</code>.  
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="node" type="node()" optional="true">
    A node. Typically this is an item in the result sequence of a 
    <code xmlns="http://www.w3.org/1999/xhtml">cts:search</code> operation.  If you specify the first item
    from a <code xmlns="http://www.w3.org/1999/xhtml">cts:search</code> expression, 
    then <code xmlns="http://www.w3.org/1999/xhtml">cts:remainder</code> will return an estimate of the number 
    of fragments that match that expression.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:integer</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">This function makes it efficient to estimate the size of a search result 
  and execute that search in the same query.  If you only need an estimate of
  the size of a search but do not need to run the search, then 
  <code>xdmp:estimate</code> is more efficient.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">To return the estimated size of a search with <code>cts:remainder</code>,
  use the first item of a <code>cts:search</code> result sequence as the 
  parameter to <code>cts:remainder</code>. For example, the following
  query returns the estimated number of fragments that contain the word
  "dog":</p>
  <pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:remainder(cts:search(collection(), "dog")[1]) </pre> 
  <p xmlns="http://www.w3.org/1999/xhtml">When you put the position predicate on the <code>cts:search</code> result 
  sequence, MarkLogic Server will filter all of the false-positive results 
  up to the specified position, but not the false-positive results beyond 
  the specified
  position. Because of this, when you increase the position number in the
  parameter, the result from <code>cts:remainder</code> might decrease
  by a larger number than the increase in position number, or it might not
  decrease at all. For example, if
  the query above returned 10, then the following query might return 9, it
  might return 10, or it might return less than 9, depending on how the 
  results are dispersed throughout different fragments:</p> 
  <pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:remainder(cts:search(collection(), "dog")[2]) </pre>
  <p xmlns="http://www.w3.org/1999/xhtml">If you run <code>cts:remainder</code> on a constructed node, it always
  returns 0; it is primarily intended to run on nodes that are the retrieved
  from the database (an item from a <code>cts:search</code> result or an 
  item from the result of an XPath expression that searches through the 
  database).</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  let $x := cts:search(collection(), "dog")
  return
  (cts:remainder($x[1]), $x)

   =&gt; Returns the estimated number of items in the search 
      for "dog" followed by the results of the search.
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  xdmp:document-insert("/test.xml", &lt;a&gt;my test&lt;/a&gt;);
  for $x in cts:search(collection(),"my test")
  return cts:remainder($x) =&gt; 1
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  for $a in cts:search(collection(),"my test")
  where $a[cts:remainder() eq 1]
  return xdmp:node-uri($a) =&gt; /test.xml
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="tokenize" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Tokenizes text into words, punctuation, and spaces.  Returns output in
  the type <code xmlns="http://www.w3.org/1999/xhtml">cts:token</code>, which has subtypes
  <code xmlns="http://www.w3.org/1999/xhtml">cts:word</code>, <code xmlns="http://www.w3.org/1999/xhtml">cts:punctuation</code>, and 
  <code xmlns="http://www.w3.org/1999/xhtml">cts:space</code>, all of which are subtypes of 
  <code xmlns="http://www.w3.org/1999/xhtml">xs:string</code>.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="text" type="xs:string" optional="false">
    A word or phrase to tokenize. 
  </apidoc:param>
      <apidoc:param name="language" type="xs:string?" optional="true">
    A language to use for tokenization.  If not supplied, it uses the
    database default language.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:token*</apidoc:return>
    <apidoc:usage>
<p xmlns="http://www.w3.org/1999/xhtml"> When you tokenize a string with <code>cts:tokenize</code>, each word is 
  represented by an instance of 
  <code>cts:word</code>, each punctuation character
  is represented by an instance of <code>cts:punctuation</code>, 
  each set of adjacent spaces is represented by an instance of 
  <code>cts:space</code>, and each set of adjacent line breaks 
  is represented by an instance of <code>cts:space</code>.</p>
<p xmlns="http://www.w3.org/1999/xhtml">
   Unlike the standard XQuery function <code>fn:tokenize</code>, 
   <code>cts:tokenize</code> returns words, punctuation, and spaces 
   as different types. You can therefore use a typeswitch to handle each type 
   differently. For example, you can use <code>cts:tokenize</code> to remove 
   all punctuation from a string, or create logic to test for the type and 
   return different things for different types, as shown in the first
   two examples below. 
</p><p xmlns="http://www.w3.org/1999/xhtml">
   You can use <code>xdmp:describe</code> to show how a given string will be
   tokenized. When run on the results of <code>cts:tokenize</code>, the 
   <code>xdmp:describe</code> function returns the types and the values
   for each token. For a sample of this pattern, see the third example below. 
</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: Remove all punctuation :)
let $string := "The red, blue, green, and orange
                balloons were launched!" 
let $noPunctuation := 
  for $token in cts:tokenize($string)
  return
    typeswitch ($token)
     case $token as cts:punctuation return ""
     case $token as cts:word return $token
     case $token as cts:space return $token
     default return ()
return string-join($noPunctuation, "")
  <br/>
 =&gt; The red blue green and orange
    balloons were launched
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: Insert the string "XX" before and after 
   all punctuation tokens :)
let $string := "The red, blue, green, and orange
                 balloons were launched!"
let $tokens := cts:tokenize($string)
return string-join(
for $x in $tokens
return if ($x instance of cts:punctuation)
       then (concat("XX",
                     $x, "XX"))
       else ($x) , "")
 =&gt; The redXX,XX blueXX,XX greenXX,XX and orange
    balloons were launchedXX!XX
 
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: show the types and tokens for a string :)
xdmp:describe(cts:tokenize("blue, green"))

=&gt; (cts:word("blue"), cts:punctuation(","), 
    cts:space(" "), cts:word("green"))
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="stem" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the stem(s) for a word.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="text" type="xs:string" optional="false">
    A word or phrase to stem. 
  </apidoc:param>
      <apidoc:param name="language" type="xs:string?" optional="true">
    A language to use for stemming.  If not supplied, it uses the
    database default language.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
<p xmlns="http://www.w3.org/1999/xhtml">In general, you should pass a word into <code>cts:stem</code>; if you 
enter a phrase, it will stem the phrase, which will normally stem to 
itself.</p>
<p xmlns="http://www.w3.org/1999/xhtml">When you stem a word through <code>cts:stem</code>, it returns all of the
stems for the word, including decompounding and multiple stems, regardless
of the database stemming setting.</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:stem("ran","en")
=&gt; "run"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="walk" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Walks a node, evaluating an expression with any text matching a query.
  It returns a sequence of all the values returned by the expression 
  evaluations.  This is similar to <code xmlns="http://www.w3.org/1999/xhtml">cts:highlight</code> in how it 
  evaluates its expression, but it is different in what it returns.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="node" type="node()" optional="false">
    A node to walk.  The node must be either a document node 
    or an element node; it cannot be a text node.
  </apidoc:param>
      <apidoc:param name="query" type="cts:query" optional="false">
   A query specifying the text on which to evaluate the expression.  
   If a string is entered, the string is treated as a 
   <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the specified string. 
  </apidoc:param>
      <apidoc:param name="expr" type="item()*" optional="false">
    An expression to evaluate with matching text. You can use the 
    variables <code xmlns="http://www.w3.org/1999/xhtml">$cts:text</code>, <code xmlns="http://www.w3.org/1999/xhtml">$cts:node</code>, 
    <code xmlns="http://www.w3.org/1999/xhtml">$cts:queries</code>, <code xmlns="http://www.w3.org/1999/xhtml">$cts:start</code>, and 
    <code xmlns="http://www.w3.org/1999/xhtml">$cts:action</code> (described below) in the expression.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>item()*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">
    There are five built-in variables to represent a query match.
    These variables can be used inline in the expression parameter.
  </p>
  <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
    <dt><code>$cts:text</code> as <code>xs:string</code></dt> 
    <dd><p>The matched text.</p></dd>
    <dt><code>$cts:node</code> as <code>text()</code></dt>
    <dd><p>The node containing the matched text.</p></dd>
    <dt><code>$cts:queries</code> as <code>cts:query*</code></dt> 
    <dd><p>The matching queries.</p></dd>
    <dt><code>$cts:start</code> as <code>xs:integer</code></dt> 
    <dd><p>The string-length position of the first character of 
    <code>$cts:text</code> in <code>$cts:node</code>.  Therefore, the following
    always returns true:</p>
    <pre xml:space="preserve">fn:substring($cts:node, $cts:start, 
             fn:string-length($cts:text)) eq $cts:text </pre>
    </dd>
    <dt><code>$cts:action</code> as <code>xs:string</code></dt> 
    <dd><p>Use <code>xdmp:set</code> on this to specify what should happen 
    next</p>
    <dl>
      <dt>"continue"</dt>
      <dd>(default) Walk the next match.  
      If there are no more matches, return all evaluation results.</dd>
      <dt>"skip"</dt>
      <dd>Skip walking any more matches and return all evaluation results.</dd>
      <dt>"break"</dt>
      <dd>Stop walking matches and return all evaluation results.</dd>
    </dl>
    </dd>
 </dl></blockquote>
 <p xmlns="http://www.w3.org/1999/xhtml">You cannot use <code>cts:walk</code> to walk results matching
 <code>cts:similar-query</code> and <code>cts:element-attribute-*-query</code>
 items.</p>
 <p xmlns="http://www.w3.org/1999/xhtml">Because the expressions can be any XQuery expression, they can be very 
 simple like the above example or they can be extremely complex.</p>
</apidoc:usage>
    <apidoc:example> <pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(:
   Return all text nodes containing matches to the query "the".
:)
let $x := &lt;p&gt;the quick brown fox &lt;b&gt;jumped&lt;/b&gt; over the lazy dog's back&lt;/p&gt;
return cts:walk($x, "the", $cts:node)
=&gt;
  (text{"the quick brown fox "}, text{" over the lazy dog's back"})
  
</pre></apidoc:example>
    <apidoc:example> <pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
xquery version "1.0-ml";
(: 
   Do not show any more matches that occur after 
   $threshold characters. 
:)
let $x := &lt;p&gt;This is 1, this is 2, this is 3, this is 4, this is 5.&lt;/p&gt;
let $pos := 1
let $threshold := 20
return 
cts:walk($x, "this is", 
 (if ( $pos gt $threshold )
  then xdmp:set($cts:action, "break")
  else ($cts:text, xdmp:set($pos, $cts:start)) ) )
=&gt;
("This is", "this is", "this is")
</pre></apidoc:example>
    <apidoc:example> <pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
xquery version "1.0-ml";
(: 
   Show the first two matches. 
:)
let $x := &lt;p&gt;This is 1, this is 2, this is 3, this is 4, this is 5.&lt;/p&gt;
let $match := 0
let $threshold := 2
return 
cts:walk($x, "this is", 
 (if ( $match ge $threshold )
  then xdmp:set($cts:action, "break")
  else ($cts:text, xdmp:set($match, $match + 1)) ) )
=&gt;
("This is", "this is")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="highlight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a copy of the node, replacing any text matching the query 
  with the specified expression.  You can use this function
  to easily highlight any text found in a query. Unlike 
  <code xmlns="http://www.w3.org/1999/xhtml">fn:replace</code> and other XQuery string functions that match 
  literal text, <code xmlns="http://www.w3.org/1999/xhtml">cts:highlight</code> matches every term that 
  matches the search, including stemmed matches or matches with 
  different capitalization.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="node" type="node()" optional="false">
    A node to highlight.  The node must be either a document node 
    or an element node; it cannot be a text node.
  </apidoc:param>
      <apidoc:param name="query" type="cts:query" optional="false">
    A query specifying the text to highlight.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the 
   specified string. 
  </apidoc:param>
      <apidoc:param name="expr" type="item()*" optional="false">
    An expression with which to replace each match. You can use the 
    variables <code xmlns="http://www.w3.org/1999/xhtml">$cts:text</code>, <code xmlns="http://www.w3.org/1999/xhtml">$cts:node</code>, 
    <code xmlns="http://www.w3.org/1999/xhtml">$cts:queries</code>, <code xmlns="http://www.w3.org/1999/xhtml">$cts:start</code>, and 
    <code xmlns="http://www.w3.org/1999/xhtml">$cts:action</code> (described below) in the expression.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>node()</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">
    There are five built-in variables to represent a query match.
    These variables can be used inline in the expression parameter.
  </p>
  <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
    <dt><code>$cts:text</code> as <code>xs:string</code></dt> 
    <dd><p>The matched text.</p></dd>
    <dt><code>$cts:node</code> as <code>text()</code></dt>
    <dd><p>The node containing the matched text.</p></dd>
    <dt><code>$cts:queries</code> as <code>cts:query*</code></dt> 
    <dd><p>The matching queries.</p></dd>
    <dt><code>$cts:start</code> as <code>xs:integer</code></dt> 
    <dd><p>The string-length position of the first character of 
    <code>$cts:text</code> in <code>$cts:node</code>.  Therefore, the following
    always returns true:</p>
    <pre xml:space="preserve">fn:substring($cts:node, $cts:start, 
             fn:string-length($cts:text)) eq $cts:text </pre>
    </dd>
    <dt><code>$cts:action</code> as <code>xs:string</code></dt> 
    <dd><p>Use <code>xdmp:set</code> on this to specify what should happen 
    next</p>
    <dl>
      <dt>"continue"</dt>
      <dd>(default) Walk the next match.  
      If there are no more matches, return all evaluation results.</dd>
      <dt>"skip"</dt>
      <dd>Skip walking any more matches and return all evaluation results.</dd>
      <dt>"break"</dt>
      <dd>Stop walking matches and return all evaluation results.</dd>
    </dl>
    </dd>
 </dl></blockquote>
 <p xmlns="http://www.w3.org/1999/xhtml">You cannot use <code>cts:highlight</code> to highlight results matching
 <code>cts:similar-query</code> and <code>cts:element-attribute-*-query</code>
 items.  Using <code>cts:highlight</code> with these queries will 
 return the nodes without any highlighting. </p>
 <p xmlns="http://www.w3.org/1999/xhtml">You can also use <code>cts:highlight</code> as a general search 
 and replace function. The specified expression will replace any matching
 text. For example, you could replace the word "hello" with "goodbye"
 in a query similar to the following:</p>
 <pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
 cts:highlight($node, "hello", "goodbye")</pre>
 <p xmlns="http://www.w3.org/1999/xhtml">Because the expressions can be any XQuery expression, they can be very 
 simple like the above example or they can be extremely complex.</p>
</apidoc:usage>
    <apidoc:example> <pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
To highlight "MarkLogic" with bold in the following paragraph:
  
let $x :=  &lt;p&gt;MarkLogic Server is an enterprise-class 
  database specifically built for content.&lt;/p&gt;
return 
cts:highlight($x, "MarkLogic", &lt;b&gt;{$cts:text}&lt;/b&gt;)

Returns:
  
  &lt;p&gt;&lt;b&gt;MarkLogic&lt;/b&gt; Server is an enterprise-class 
  database specifically built for content.&lt;/p&gt; 
  
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
Given the following document with the URI "hellogoodbye.xml":

&lt;root&gt;
  &lt;a&gt;It starts with hello and ends with goodbye.&lt;/a&gt;
&lt;/root&gt;

The following query will highlight the word "hello" in 
blue, and everything else in red.

cts:highlight(doc("hellogoodbye.xml"), 
       cts:and-query((cts:word-query("hello"),
                      cts:word-query("goodbye"))),
  if (cts:word-query-text($cts:queries) eq "hello")
  then (&lt;font color="blue"&gt;{$cts:text}&lt;/font&gt;)
  else (&lt;font color="red"&gt;{$cts:text}&lt;/font&gt;))
             
returns:

&lt;root&gt;
  &lt;a&gt;It starts with &lt;font color="blue"&gt;hello&lt;/font&gt; 
  and ends with &lt;font color="red"&gt;goodbye&lt;/font&gt;.&lt;/a&gt;
&lt;/root&gt;
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
for $x in cts:search(collection(), "MarkLogic")
return
cts:highlight($x, "MarkLogic", &lt;b&gt;{$cts:text}&lt;/b&gt;)

returns all of the nodes that contain "MarkLogic", 
placing bold markup around the matched words.
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="entity-highlight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a copy of the node, replacing any entities found 
  with the specified expression.  You can use this function
  to easily highlight any entities in an XML document in an arbitrary manner.
  If you do not need fine-grained control of the XML markup returned, 
  you can use the <code xmlns="http://www.w3.org/1999/xhtml">entity:enrich</code> XQuery module function instead.
  A valid entity enrichment license key is required 
  to use <code xmlns="http://www.w3.org/1999/xhtml">cts:entity-highlight</code>;  
  without a valid license key, it throws an exception.  If you
  have a valid license for entity enrichment, you can entity enrich text 
  in English and in any other languages for which you have a valid license 
  key. For languages in which you do not have a valid license key,  
  <code xmlns="http://www.w3.org/1999/xhtml">cts:entity-highlight</code> finds no entities for text in that 
  language.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="node" type="node()" optional="false">
    A node to run entity highlight on.  The node must be either a document node 
    or an element node; it cannot be a text node.
  </apidoc:param>
      <apidoc:param name="expr" type="item()*" optional="false">
    An expression with which to replace each match. You can use the 
    variables <code xmlns="http://www.w3.org/1999/xhtml">$cts:text</code>, <code xmlns="http://www.w3.org/1999/xhtml">$cts:node</code>,  
    <code xmlns="http://www.w3.org/1999/xhtml">$cts:entity-type</code> and <code xmlns="http://www.w3.org/1999/xhtml">$cts:normalized-text</code>,
    <code xmlns="http://www.w3.org/1999/xhtml">$cts:start</code>, and <code xmlns="http://www.w3.org/1999/xhtml">$cts:action</code>
    (described below) in the expression.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>node()</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">
    There are six built-in variables to represent an entity match.
    These variables can be used inline in the expression parameter.
  </p>
  <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
    <dt><code>$cts:text</code> as <code>xs:string</code></dt> 
    <dd><p>The matched text.</p></dd>
    <dt><code>$cts:node</code> as <code>text()</code></dt>
    <dd><p>The node containing the matched text.</p></dd>
    <dt><code>$cts:start</code> as <code>xs:integer</code></dt> 
    <dd><p>The string-length position of the first character of 
    <code>$cts:text</code> in <code>$cts:node</code>.  Therefore, the following
    always returns true:</p>
    <pre xml:space="preserve">fn:substring($cts:node, $cts:start, 
             fn:string-length($cts:text)) eq $cts:text </pre>
    </dd>
    <dt><code>$cts:action</code> as <code>xs:string</code></dt> 
    <dd><p>Use <code>xdmp:set</code> on this to specify what should happen 
    next</p>
    <dl>
      <dt>"continue"</dt>
      <dd>(default) Walk the next match.  
      If there are no more matches, return all evaluation results.</dd>
      <dt>"skip"</dt>
      <dd>Skip walking any more matches and return all evaluation results.</dd>
      <dt>"break"</dt>
      <dd>Stop walking matches and return all evaluation results.</dd>
    </dl>
    </dd>
    <dt><p><code>$cts:entity-type</code> as <code>xs:string</code></p></dt> 
    <dd><p>The type of the matching entity.</p></dd>
    <dt><code>$cts:normalized-text</code> as <code>xs:string</code></dt> 
    <dd><p>The normalized entity text (only applicable for some 
    languages).</p></dd>
 </dl></blockquote>
 <p xmlns="http://www.w3.org/1999/xhtml">The following are the entity types returned from the 
 <code>$cts:entity-type</code> built-in variable (in alphabetical order):</p>
  <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
    <dt><code>FACILITY</code></dt>
       <dd>A place used as a facility.</dd>
    <dt><code>GPE</code></dt>
       <dd>Geo-political entity.  Differs from location because it has a
       person-made aspect to it (for example, California is a GPE because
       its boundaries were defined by a government).</dd>
    <dt><code>IDENTIFIER:CREDIT_CARD_NUM</code></dt>
       <dd>A number identifying a credit card number.</dd>
    <dt><code>IDENTIFIER:DISTANCE</code></dt>
       <dd>A number identifying a distance.</dd>
    <dt><code>IDENTIFIER:EMAIL</code></dt>
       <dd>Identifies an email address.</dd>
    <dt><code>IDENTIFIER:LATITUDE_LONGITUDE</code></dt>
       <dd>Latitude and longitude coordinates.</dd>
    <dt><code>IDENTIFIER:MONEY</code></dt>
       <dd>Identifies currency (dollars, euros, and so on).</dd>
    <dt><code>IDENTIFIER:NUMBER</code></dt>
       <dd>Identifies a number.</dd>
    <dt><code>IDENTIFIER:PERSONAL_ID_NUM</code></dt>
       <dd>A number identifying a social security number or other ID 
       number.</dd>
    <dt><code>IDENTIFIER:PHONE_NUMBER</code></dt>
       <dd>A number identifying a telephone number.</dd>
    <dt><code>IDENTIFIER:URL</code></dt>
       <dd>Identifies a web site address (URL).</dd>
    <dt><code>IDENTIFIER:UTM</code></dt>
       <dd>Identifies Universal Transverse Mercator coordinates.</dd>
    <dt><code>LOCATION</code></dt>
       <dd>A geographic location (Mount Everest, for example).</dd>
    <dt><code>NATIONALITY</code></dt>
       <dd>The nationality of someone or something (for example, American).</dd>
    <dt><code>ORGANIZATION</code></dt>
       <dd>An organization.</dd>
    <dt><code>PERSON</code></dt>
       <dd>A person.</dd>
    <dt><code>RELIGION</code></dt>
       <dd>A religion.</dd>
    <dt><code>TEMPORAL:DATE</code></dt>
       <dd>Date-related.</dd>
    <dt><code>TEMPORAL:TIME</code></dt>
       <dd>Time-related.</dd>
    <dt><code>TITLE</code></dt>
       <dd>Appellation or honorific associated with a person.</dd>
    <dt><code>URL</code></dt>
       <dd>A URL on the world wide web.</dd>
    <dt><code>UTM</code></dt>
       <dd>A point in the Universal Transverse Mercator (UTM) 
        coordinate system.</dd>
   </dl></blockquote>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $myxml := &lt;node&gt;George Washington never visited Norway.  
              If he had a Social Security number, 
              it might be 000-00-0001.&lt;/node&gt;
return
cts:entity-highlight($myxml, 
   element { fn:replace($cts:entity-type, ":", "-") } { $cts:text })

=&gt; 
&lt;node&gt;
  &lt;PERSON&gt;George Washington&lt;/PERSON&gt; never visited &lt;GPE&gt;Norway&lt;/GPE&gt;.  
  If he had a Social Security number, it might be 
  &lt;IDENTIFIER-PERSONAL_ID_NUM&gt;000-00-0001&lt;/IDENTIFIER-PERSONAL_ID_NUM&gt;.
&lt;/node&gt;

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="near-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a query matching all of the specified queries, where
  the matches occur within the specified distance from each other.  
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="queries" type="cts:query*" optional="false">
    A sequence of queries to match.
  </apidoc:param>
      <apidoc:param name="distance" type="xs:double?" optional="true">
    A distance, in number of words, between any two matching queries.
    The results match if two queries match and the distance between the 
    two matches is equal to or less than the specified distance. A 
    distance of 0 matches when the text is the exact same text or when 
    there is overlapping text (see the third example below). A negative 
    distance is treated as 0.  The default value is 10.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default value is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ordered"</dt>
        <dd>Any near-query matches must occur in the order of 
            the specified sub-queries.</dd>
        <dt>"unordered"</dt>
        <dd>Any near-query matches will satisfy the query, 
        regardless of the order they were specified.  </dd>
     </dl></blockquote> 
  </apidoc:param>
      <apidoc:param name="distance-weight" type="xs:double?" optional="true">
    A weight attributed to the distance for this query.  Higher 
    weights add to the importance of distance (as opposed to term matches)
    when the relevance order is calculated.  The default value is 1.0. The 
    weight should be less than or equal to the absolute value of 16 (between 
    -16 and 16); weights greater than 16 will have the same effect as a 
    weight of 16. 
    Weights less than the absolute value of 0.0625 (between -0.0625 and
    0.0625) are rounded to 0, which means that they do not contribute to the 
    score.  This parameter has no effect if the <code xmlns="http://www.w3.org/1999/xhtml">word positions</code>
    index is not enabled.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:near-query</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">If the options parameter contains neither "ordered" nor "unordered",
  then the default is "unordered".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">The <code>word positions</code> index will speed the performance of 
  queries that use <code>cts:near-query</code>. The <code>element word 
  positions</code> index will speed the performance of element-queries
  that use <code>cts:near-query</code>.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If you use <code>cts:near-query</code> with a field, the distance
  specified is the distance in the whole document, not the distance
  in the field.  For example, if the distance between two words is 20 in 
  the document, but the distance is 10 if you look at a view of the document
  that only includes the elements in a field, a <code>cts:near-query</code>
  must have a distance of 20 or more to match; a distance of 10 would not 
  match.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If you use <code>cts:near-query</code> with 
  <code>cts:field-word-query</code>, the distance supplied in the near query
  applies to the whole document, not just to the field.  For details, see 
  <a href="#cts:field-word-query"><code>cts:field-word-query</code></a>.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Expressions using the <code>ordered</code> option are more efficient
  than those using the <code>unordered</code> option, especially if they 
  specify many queries to match.</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
 The following query searches for paragraphs containing 
 both "MarkLogic" and "Server" within 3 words of each 
 other, given the following paragraphs in a database:

  &lt;p&gt;MarkLogic Server is an enterprise-class 
  database specifically built for content.&lt;/p&gt;
  &lt;p&gt;MarkLogic is an excellent XML Content Server.&lt;/p&gt; 

  cts:search(//p,
    cts:near-query(
      (cts:word-query("MarkLogic"),
      cts:word-query("Server")),
      3))
  
  =&gt;
  &lt;p&gt;MarkLogic Server is an enterprise-class 
  database specifically built for content.&lt;/p&gt; 
      
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $x := &lt;p&gt;Now is the winter of our discontent&lt;/p&gt;
return
cts:contains($x, cts:near-query(
                    ("discontent", "winter"), 
                    3, "ordered"))

=&gt; false because "discontent" comes after "winter"

let $x := &lt;p&gt;Now is the winter of our discontent&lt;/p&gt;
return
cts:contains($x, cts:near-query(
                    ("discontent", "winter"), 
                    3, "unordered"))

=&gt; true because the query specifies "unordered",
        and it is still a match even though
        "discontent" comes after "winter"
      
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $x := &lt;p&gt;Now is the winter of our discontent&lt;/p&gt;
return
cts:contains($x, cts:near-query(
                    ("is the winter", "winter of"), 
                    0))

=&gt; true because the phrases overlap

let $x := &lt;p&gt;Now is the winter of our discontent&lt;/p&gt;
return
cts:contains($x, cts:near-query(
                    ("is the winter", "of our"), 
                    0))

=&gt; false because the phrases do not overlap
         (they have 1 word distance, not 0)
      
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="near-query-queries" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the query sequence used to construct the near query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:near-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:near-query-queries($query)
  =&gt; ... a sequence of the queries used to 
            construct this query
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := 
  cts:near-query((
    cts:word-query("to be or"), 
    cts:word-query("or not to be")))
return cts:near-query-queries($query)
  =&gt; (cts:word-query("to be or", (), 1) 
         cts:word-query("or not to be", (), 1))
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="near-query-distance" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the distance used to construct the near query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:near-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:integer</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:near-query(
                 cts:word-query("wanted"), 
                 cts:word-query("unwanted"),
                 12)
return cts:near-query-distance($query)
  =&gt; 12
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="near-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:near-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:near-query(
                 cts:word-query("wanted"), 
                 cts:word-query("unwanted"),
                 12,
                 "ordered")
return
  cts:near-query-options($query)
  =&gt; "ordered"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="near-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:near-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:near-query(
                 cts:word-query("wanted"), 
                 cts:word-query("unwanted"),
                 12, "ordered", 5.0)
return
  cts:near-query-weight($query)
  =&gt; 5.0
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> matching elements by name
  with the content constrained by the given <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> in the 
  second parameter.  
  Searches for matches in the specified element and all of its descendants. 
  If the specified query in the second parameter has any
  <code xmlns="http://www.w3.org/1999/xhtml">cts:element-attribute-*-query</code> constructors, it will search
  attributes directly on the specified element and attributes on any 
  descendant elements (see the <a href="#eq2" xmlns="http://www.w3.org/1999/xhtml">second example</a> below).
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-name" type="xs:QName*" optional="false">
    One or more element QNames to match.  
    When multiple QNames are specified, 
    the query matches if any QName matches.
  </apidoc:param>
      <apidoc:param name="query" type="cts:query" optional="false">
    A query for the element to match.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the 
   specified string.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:element-query</apidoc:return>
    <apidoc:usage>
  Enabling both the word position and element position indexes ("word position"
  and "element word position" in the database configuration screen of the 
  Admin Interface) will speed up query performance for many queries that use 
  <code xmlns="http://www.w3.org/1999/xhtml">cts:element-query</code>. The  position indexes enable MarkLogic 
  Server to eliminate many false-positive results, which can reduce 
  disk I/O and processing, thereby speeding the performance of many queries.  
  The amount of benefit will vary depending on your data.
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//module,
    cts:element-query(
      xs:QName("function"), 
      "MarkLogic Corporation"))
  <br/>
  =&gt; .. relevance-ordered sequence of 'module' elements
  ancestors (or self) of elements with QName 'function'
  and text content containing the phrase 'MarkLogic 
  Corporation'.
</pre></apidoc:example>
    <apidoc:example><a id="eq2" xmlns="http://www.w3.org/1999/xhtml"></a><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $x := &lt;a attr="something"&gt;hello&lt;/a&gt;
return
cts:contains($x, cts:element-query(xs:QName("a"), 
   cts:and-query((
     cts:element-attribute-word-query(xs:QName("a"), 
         xs:QName("attr"), "something"),
     cts:word-query("hello")))))
(: returns true :)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-query-element-name" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the QNames used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:QName*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-query(
              xs:QName("function"),
              "MarkLogic Corporation")
return cts:element-query-element-name($query)

  =&gt; xs:QName("function")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-query-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the query used to construct the element query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:element-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := cts:element-query(
                 cts:word-query("wanted"))
return cts:element-query-query($query)
  
  =&gt; cts:word-query("wanted", (), 1)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="document-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a query matching documents with the given URIs.  It will match both
  documents and properties documents with the given URIs.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="uris" type="xs:string*" optional="false">
    One or more document URIs.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:document-query</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//function,
    cts:document-query("/reports.xml"))
  
  =&gt; .. relevance-ordered sequence of 'function' elements
  in the document "/reports.xml".
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:search(//function, cts:and-query(("repair", 
  cts:document-query(("/reports.xml", "/analysis.xml")))))
  
  =&gt; .. relevance ordered sequence of 'function' elements in 
     any document that both contains the word "repair" and is
     in either the document "/reports.xml" or in the document 
     "/analysis.xml".
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="document-query-uris" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the URIs used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:document-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:document-query-uris($query)
  =&gt; ("/reports.xml", "/analysis.xml")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="collection-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a query matching documents in the collections with the given URIs.
  It will match both documents and properties documents in the collections
  with the given URIs.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="uris" type="xs:string*" optional="false">
    One or more collection URIs.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:collection-query</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//function,
    cts:collection-query(("reports", "analysis")))
  
  =&gt; .. a sequence of 'function' elements in any document in the 
     collection "reports" or in the collection "analysis".
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:search(//function, cts:and-query(("repair", 
    cts:collection-query(("reports", "analysis")))))
  
  =&gt; .. relevance ordered sequence of 'function' elements in 
     any document that both contains the word "repair" and is
     in either the collection "reports" or in the collection 
     "analysis".
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="collection-query-uris" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the URIs used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:collection-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:collection-query-uris($query)
  =&gt; ("reports", "analysis")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="directory-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a query matching documents in the directories with the given URIs.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="uris" type="xs:string*" optional="false">
    One or more directory URIs.
  </apidoc:param>
      <apidoc:param name="depth" type="xs:string?" optional="true">
    "1" for immediate children, "infinity" for all.  If not supplied,
    depth is "1".
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:directory-query</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//function,
    cts:directory-query(("/reports/","/analysis/"),"1"))
  
  =&gt; .. a sequence of 'function' elements in any document 
     in the directory "/reports/" or the directory "/analysis/".
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:search(//function, cts:and-query(("repair", 
  cts:directory-query(("/reports/", "/analysis/"), "1"))))
  
  =&gt; .. relevance ordered sequence of 'function' elements in 
     any document that both contains the word "repair" and is
     in either the directory "/reports/" or in the directory 
     "/analysis/".
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="directory-query-uris" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the URIs used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:directory-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:directory-query-uris($query)
  =&gt; ("/reports", "/analysis/")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="directory-query-depth" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the depth used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:directory-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:directory-query-depth($query)
  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="register" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Register a query for later use.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:query" optional="false">
    A query to register.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:unsignedLong</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:register(cts:collection-query("mycollection"))
  
  =&gt; 12345678901234567
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="deregister" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Deregister a registered query, explicitly releasing the associated 
  resources.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="id" type="xs:unsignedLong" optional="false">
    A registered query identifier.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>empty-sequence()</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:deregister(xs:unsignedLong("12345678901234567"))
  
   =&gt; ()
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="registered-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a query matching fragments specified by previously registered
  queries (see <a href="#cts:register" xmlns="http://www.w3.org/1999/xhtml"><code>cts:register</code></a>).  If a
  registered query with the specified ID(s) is not found, then
  a <code xmlns="http://www.w3.org/1999/xhtml">cts:search</code> operation with an invalid
  <code xmlns="http://www.w3.org/1999/xhtml">cts:registered-query</code> throws an XDMP-UNREGISTERED
  exception.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="ids" type="xs:unsignedLong*" optional="false">
    Some registered query identifiers.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options to this query.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"filtered"</dt>
        <dd>A filtered query (the default). Filtered queries
        eliminate any false-positive results and properly resolve 
        cases where there are multiple candidate matches within the same 
        fragment, thereby guaranteeing 
        that the results fully satisfy the original <code>cts:query</code> 
        item that was registered.  This option is not available in 
        the 4.0 release.</dd> 
        <dt>"unfiltered"</dt>
        <dd>An unfiltered query.  Unfiltered registered queries
        select fragments from the indexes that are candidates to satisfy
        the <code>cts:query</code>.
        Depending on the original <code>cts:query</code>, the 
        structure of the documents in the database, and the configuration 
        of the database, 
        unfiltered registered queries may result in false-positive results 
        or in incorrect matches when there are multiple candidate matches 
        within the same fragment. 
        To avoid these problems, you should only use unfiltered queries 
        on top-level XPath expressions (for example, document nodes, 
        collections, directories) or on fragment roots. Using unfiltered 
        queries on complex XPath expressions or on XPath expressions that
        traverse below a fragment root can result in unexpected results. 
        This option is required in the 4.0 release.
        </dd>
     </dl></blockquote> 
  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.
    Higher weights move search results up in the relevance
    order.  The default is 1.0. The 
    weight should be less than or equal to the absolute value of 16 (between 
    -16 and 16); weights greater than 16 will have the same effect as a 
    weight of 16. 
    Weights less than the absolute value of 0.0625 (between -0.0625 and
    0.0625) are rounded to 0, which means that they do not contribute to the 
    score.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:registered-query</apidoc:return>
    <apidoc:usage>
<p xmlns="http://www.w3.org/1999/xhtml">If the options parameter does not contain "unfiltered",
then an error is returned, as the "unfiltered" option is required.</p>
<p xmlns="http://www.w3.org/1999/xhtml">Registered queries are persisted as a soft state only; they can 
become unregistered through an explicit direction (using 
<a href="#cts:deregister"><code>cts:deregister</code></a>),
as a result of the cache growing too large, or because of a server restart.  
Consequently, either your XQuery code or your middleware layer should handle
the case when an XDMP-UNREGISTERED exception occurs (for example, you can
wrap your <code>cts:registered-query</code> code in a try/catch block
or your Java or .NET code can catch and handle the exception).</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:search(//function,
    cts:registered-query(1234567890123456,"unfiltered"))
  
  =&gt; .. relevance-ordered sequence of 'function' elements
  in any document that also matches the registered query
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: wrap the registered query in a try/catch :)
try {
cts:search(fn:doc(),cts:registered-query(995175721241192518,"unfiltered")))
} catch ($e) {
  if ($e/err:code = "XDMP-UNREGISTERED")
  then ("Retry this query with the following registered query ID: ",
        cts:register(cts:word-query("hello*world","wildcarded")))
  else $e
}
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="registered-query-ids" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the registered query identifiers used to construct the specified
  query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:registered-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:unsignedLong*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:registered-query-ids($query)
  =&gt; 1234567890123456
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="registered-query-options" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the options for the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:registered-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:registered-query-options($query)
  =&gt; "unfiltered"
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="registered-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:registered-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:registered-query-weight($query)
  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="words" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns words from the word lexicon.  This function requires the word
  lexicon to be enabled. If the word lexicon is not enabled, an
  exception is thrown.  The words are returned in collation order.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="start" type="xs:string?" optional="true">
    A starting word.  Returns only this word and any following words
    from the lexicon.  If the parameter is not in the lexicon, then it
    returns the words beginning with the next word.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Words should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Words should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Words from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Words from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Words from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Words from locks fragments should be included.</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> words.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only words from the first <em>N</em> fragments 
        selected by the <code>cts:query</code>.  
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only words from the first <em>N</em> fragments 
        selected by the <code>cts:query</code>.  
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint 
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon 
        processing occurs.  This is especially useful in cases where multiple 
        lexicon calls occur in the same query (for example, resolving many 
        facets in a single query).</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include words in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.
    The words do not need to match the query, but the words must occur
    in fragments selected by the query.
    The fragments are not filtered to ensure they match the query, 
    but instead selected in the same manner as <a href="#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the 
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified 
  in the options parameter.  If neither "ascending" nor "descending" 
  is specified, then the default is "ascending".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks" 
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  or "score-random" options may be specified in the options parameter. 
  If none of "score-logtfidf", "score-logtf", "score-simple", or 
  "score-random" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter. 
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter, 
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter, 
  then all included words may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter, 
  then words from all fragments selected by the <code>$query</code> parameter 
  are included.  If a <code>$query</code> parameter is not present, then  
  "truncate=<em>N</em>" has no effect.</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:words("aardvark")
  =&gt; ("aardvark","aardvarks","aardwolf",...)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="word-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns words from the word lexicon that match the wildcard pattern. 
  This function requires the word lexicon to be enabled. If the word 
  lexicon is not enabled, an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="pattern" type="xs:string" optional="false">
    A wildcard pattern to match.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive match.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive match.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive match.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive match.</dd>
        <dt>"ascending"</dt>
        <dd>Words should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Words should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Words from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Words from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Words from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Words from locks fragments should be included.</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> words.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only words from the first <em>N</em> fragments 
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only words from the first <em>N</em> fragments 
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint 
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon 
        processing occurs.  This is especially useful in cases where multiple 
        lexicon calls occur in the same query (for example, resolving many 
        facets in a single query).</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include words in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.
    The words do not need to match the query, but the words must occur
    in fragments selected by the query.
    The fragments are not filtered to ensure they match the query, 
    but instead selected in the same manner as <a href="#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the 
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified 
  in the options parameter.  If neither "ascending" nor "descending" 
  is specified, then the default is "ascending".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks" 
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  or "score-random" options may be specified in the options parameter. 
  If none of "score-logtfidf", "score-logtf", "score-simple", or 
  "score-random" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter. 
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter, 
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter, 
  then all included words may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter, 
  then words from all fragments selected by the <code>$query</code> parameter 
  are included.  If a <code>$query</code> parameter is not present, then  
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive" 
    is present, $pattern is used to determine case sensitivity.
    If $pattern contains no uppercase, it specifies "case-insensitive".
    If $pattern contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive" 
    is present, $pattern is used to determine diacritic sensitivity.
    If $pattern contains no diacritics, it specifies "diacritic-insensitive".
    If $pattern contains diacritics, it specifies "diacritic-sensitive".
  </p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:word-match("aardvark*")
  =&gt; ("aardvark","aardvarks")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-words" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns words from the specified element word lexicon.  This function
  requires an element word lexicon for each of the element specified in the
  function.  If there is not an element word lexicon configured for any
  of the specified elements, an exception is thrown.  The words are
  returned in collation order.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*" optional="false">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="start" type="xs:string?" optional="true">
    A starting word.  Returns only this word and any following words
    from the lexicon.  If the parameter is not in the lexicon, then it
    returns the words beginning with the next word.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Words should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Words should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Words from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Words from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Words from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Words from locks fragments should be included.</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> words.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only words from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only words from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint 
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon 
        processing occurs.  This is especially useful in cases where multiple 
        lexicon calls occur in the same query (for example, resolving many 
        facets in a single query).</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include words in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.
    The words do not need to match the query, but the words must occur
    in fragments selected by the query.
    The fragments are not filtered to ensure they match the query, 
    but instead selected in the same manner as <a href="#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the 
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified 
  in the options parameter.  If neither "ascending" nor "descending" 
  is specified, then the default is "ascending".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks" 
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  or "score-random" options may be specified in the options parameter. 
  If none of "score-logtfidf", "score-logtf", "score-simple", or 
  "score-random" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter. 
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter, 
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter, 
  then all included words may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter, 
  then words from all fragments selected by the <code>$query</code> parameter 
  are included.  If a <code>$query</code> parameter is not present, then  
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only words that can be matched with element-word-query are included.
  That is, only words present in immediate text node children of the 
  specified element as well as any text node children of child elements
  defined in the Admin Interface as element-word-query-throughs or 
  phrase-throughs. </p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-words(xs:QName("animal"),"aardvark")
  =&gt; ("aardvark","aardvarks","aardwolf",...)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-word-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns words from the specified element word lexicon(s) that match 
  a wildcard pattern.   This function requires an element word lexicon 
  configured for each of the specified elements in the function.  If there 
  is not an element word lexicon configured for any of the specified 
  elements, an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*" optional="false">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="pattern" type="xs:string" optional="false">
    Wildcard pattern to match.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive match.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive match.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive match.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive match.</dd>
        <dt>"ascending"</dt>
        <dd>Words should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Words should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Words from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Words from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Words from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Words from locks fragments should be included.</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> words.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only words from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only words from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint 
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon 
        processing occurs.  This is especially useful in cases where multiple 
        lexicon calls occur in the same query (for example, resolving many 
        facets in a single query).</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include words in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.
    The words do not need to match the query, but the words must occur
    in fragments selected by the query.
    The fragments are not filtered to ensure they match the query, 
    but instead selected in the same manner as <a href="#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the 
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified 
  in the options parameter.  If neither "ascending" nor "descending" 
  is specified, then the default is "ascending".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks" 
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  or "score-random" options may be specified in the options parameter. 
  If none of "score-logtfidf", "score-logtf", "score-simple", or 
  "score-random" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter. 
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter, 
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter, 
  then all included words may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter, 
  then words from all fragments selected by the <code>$query</code> parameter 
  are included.  If a <code>$query</code> parameter is not present, then  
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive" 
    is present, $pattern is used to determine case sensitivity.
    If $pattern contains no uppercase, it specifies "case-insensitive".
    If $pattern contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive" 
    is present, $pattern is used to determine diacritic sensitivity.
    If $pattern contains no diacritics, it specifies "diacritic-insensitive".
    If $pattern contains diacritics, it specifies "diacritic-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only words that can be matched with element-word-query are included.
  That is, only words present in immediate text node children of the 
  specified element as well as any text node children of child elements
  defined in the Admin Interface as element-word-query-throughs or 
  phrase-throughs. </p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-word-match(xs:QName("animal"),"aardvark*")
  =&gt; ("aardvark","aardvarks")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-values" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns values from the specified element value lexicon(s).  
  Value lexicons are implemented using range indexes; consequently this 
  function requires an element range index for each element specified 
  in the function.  If there is not a range index configured for each 
  of the specified elements, an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*" optional="false">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="start" type="xs:anyAtomicType?" optional="true">
    A starting value.  The parameter type must match the lexicon type.
    If the parameter value is is not in the lexicon, then the values are 
    returned beginning with the next value.  
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Values should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Values should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Values should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Values should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value.  
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value. 
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em> 
        (int, unsignedInt, long, unsignedLong, float, double, decimal, 
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay, 
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date, 
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.  
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> values.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only values occurring in the first <em>N</em> fragments
        selected by the <code>cts:query</code>;  only values in fragments
        satisfying the <code>cts:query</code> are returned, but any analytics 
        calculations (using <code>cts:frequency</code>, for example)
        use all the lexicon values, not just the ones constrained by the 
        <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only values from the first <em>N</em> fragments
        selected by the <code>cts:query</code>; only values in fragments
        satisfying the <code>cts:query</code> are returned, and only those
        values are used in calculating any analytics (using 
        <code>cts:frequency</code>, for example).
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint 
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon 
        processing occurs.  This is especially useful in cases where multiple 
        lexicon calls occur in the same query (for example, resolving many 
        facets in a single query).</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query, 
    but instead selected in the same manner as <a href="#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the 
   specified string.    
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified 
  in the options parameter.  If neither "frequency-order" nor "item-order" 
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified 
  in the options parameter.  If neither "fragment-frequency" nor 
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified 
  in the options parameter.  If neither "ascending" nor "descending" 
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks" 
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  or "score-random" options may be specified in the options parameter. 
  If none of "score-logtfidf", "score-logtf", "score-simple", or 
  "score-random" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter. 
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter, 
  then all included values may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter, 
  then values from all fragments selected by the <code>$query</code> parameter 
  are included.  If a <code>$query</code> parameter is not present, then  
  "truncate=<em>N</em>" has no effect.</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-values(xs:QName("animal"),"aardvark")
  =&gt; ("aardvark","aardvarks","aardwolf",...)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-value-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
   Returns values from the specified element value lexicon(s)
   that match the specified wildcard pattern.  Element value lexicons 
   are implemented using range indexes; consequently this function 
   requires an element range index for each element specified in the 
   function.  If there is not a range index configured for each of the
   specified elements, then an exception is thrown. 
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*" optional="false">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="pattern" type="xs:anyAtomicType" optional="false">
    A pattern to match.  The parameter type must match the lexicon type.
    String parameters may include wildcard characters.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive match.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive match.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive match.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive match.</dd>
        <dt>"ascending"</dt>
        <dd>Values should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Values should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Values should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Values should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value. 
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em> 
        (int, unsignedInt, long, unsignedLong, float, double, decimal, 
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay, 
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the range index with the collation specified by 
        <em>URI</em>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date, 
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.  
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> values.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only values occurring in the first <em>N</em> fragments
        selected by the <code>cts:query</code>;  only values in fragments
        satisfying the <code>cts:query</code> are returned, but any analytics 
        calculations (using <code>cts:frequency</code>, for example)
        use all the lexicon values, not just the ones constrained by the 
        <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only values from the first <em>N</em> fragments
        selected by the <code>cts:query</code>; only values in fragments
        satisfying the <code>cts:query</code> are returned, and only those
        values are used in calculating any analytics (using 
        <code>cts:frequency</code>, for example).
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint 
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon 
        processing occurs.  This is especially useful in cases where multiple 
        lexicon calls occur in the same query (for example, resolving many 
        facets in a single query).</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query, 
    but instead selected in the same manner as <a href="#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the 
   specified string. 
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:usage>
 <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified 
  in the options parameter.  If neither "frequency-order" nor "item-order" 
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified 
  in the options parameter.  If neither "fragment-frequency" nor 
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified 
  in the options parameter.  If neither "ascending" nor "descending" 
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks" 
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  or "score-random" options may be specified in the options parameter. 
  If none of "score-logtfidf", "score-logtf", "score-simple", or 
  "score-random" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter. 
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter, 
  then the default collation is used.  If a range index with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter, 
  then all included values may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter, 
  then values from all fragments selected by the <code>$query</code> parameter 
  are included.  If a <code>$query</code> parameter is not present, then  
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive" 
    is present, $pattern is used to determine case sensitivity.
    If $pattern contains no uppercase, it specifies "case-insensitive".
    If $pattern contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive" 
    is present, $pattern is used to determine diacritic sensitivity.
    If $pattern contains no diacritics, it specifies "diacritic-insensitive".
    If $pattern contains diacritics, it specifies "diacritic-sensitive".
  </p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-value-match(xs:QName("animal"),"aardvark*")
  =&gt; ("aardvark","aardvarks")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-value-co-occurrences" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns value co-occurrences (that is, pairs of values, both of which appear
  in the same fragment) from the specified element value lexicon(s).  The
  values are returned as an XML element with two children, each child
  containing one of the co-occurring values.  You can use 
  <code xmlns="http://www.w3.org/1999/xhtml">cts:frequency</code> on each item returned to find how many times
  the pair occurs.
  Value lexicons are implemented using range indexes; consequently 
  this function requires an element range index for each element specified 
  in the function, and the range index must have range value positions
  set to true.  If there is not a range index configured for each 
  of the specified elements, and if the range value positions is not
  enabled for the any of the range indexes, an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-name-1" type="xs:QName" optional="false">
    An element QName.
  </apidoc:param>
      <apidoc:param name="element-name-2" type="xs:QName" optional="false">
    An element QName.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Co-occurrences should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Co-occurrences should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Co-occurrences from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Co-occurrences from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Co-occurrences from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Co-occurrences from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Co-occurrences should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Co-occurrences should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included co-occurrences.  
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included co-occurrence. 
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"type=<em>type</em>"</dt>
        <dd>For both lexicons, use the type specified by <em>type</em> 
        (int, unsignedInt, long, unsignedLong, float, double, decimal, 
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay, 
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"type-1=<em>type</em>"</dt>
        <dd>For the first lexicon, use the type specified by <em>type</em> 
        (int, unsignedInt, long, unsignedLong, float, double, decimal, 
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay, 
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"type-2=<em>type</em>"</dt>
        <dd>For the second lexicon, use the type specified by <em>type</em> 
        (int, unsignedInt, long, unsignedLong, float, double, decimal, 
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay, 
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>For both lexicons, use the collation specified by 
        <em>URI</em>.</dd>
        <dt>"collation-1=<em>URI</em>"</dt>
        <dd>For the first lexicon, use the collation specified by 
        <em>URI</em>.</dd>
        <dt>"collation-2=<em>URI</em>"</dt>
        <dd>For the second lexicon, use the collation specified by 
        <em>URI</em>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date, 
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.  
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"ordered"</dt>
        <dd>Include co-occurrences only when the value from the first lexicon
        appears before the value from the second lexicon.
        Requires that word positions be enabled for both lexicons.</dd>
        <dt>"proximity=<em>N</em>"</dt>
        <dd>Include co-occurrences only when the values appear within 
        <em>N</em> words of each other.
        Requires that word positions be enabled for both lexicons.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> co-occurrences.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only co-occurrences from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only co-occurrences from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint 
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon 
        processing occurs.  This is especially useful in cases where multiple 
        lexicon calls occur in the same query (for example, resolving many 
        facets in a single query).</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include co-occurrences in fragments selected by the 
    <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.
    The co-occurrences do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query, 
    but instead selected in the same manner as <a href="#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the 
   specified string.    
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>element(cts:co-occurrence)*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified 
  in the options parameter.  If neither "frequency-order" nor "item-order" 
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified 
  in the options parameter.  If neither "fragment-frequency" nor 
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified 
  in the options parameter.  If neither "ascending" nor "descending" 
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks" 
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  or "score-random" options may be specified in the options parameter. 
  If none of "score-logtfidf", "score-logtf", "score-simple", or 
  "score-random" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter. 
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter, 
  then all included co-occurrences may be returned.  
  If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter, 
  then co-occurrences from all fragments selected by the 
  <code>$query</code> parameter are included.  
  If a <code>$query</code> parameter is not present, then  
  "truncate=<em>N</em>" has no effect.</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  (: this query has the database fragmented on SPEECH and 
     finds SPEAKERs that co-occur in a SPEECH :)
  cts:element-value-co-occurrences(
    xs:QName("SPEAKER"),xs:QName("SPEAKER"),
    ("frequency-order","ordered"),
    cts:document-query("hamlet.xml"))[1 to 3]
  =&gt; 
  &lt;cts:co-occurrence xmlns:cts="http://marklogic.com/cts" 
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
      xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;cts:value xsi:type="xs:string"&gt;MARCELLUS&lt;/cts:value&gt;
    &lt;cts:value xsi:type="xs:string"&gt;BERNARDO&lt;/cts:value&gt;
  &lt;/cts:co-occurrence&gt;
  &lt;cts:co-occurrence xmlns:cts="http://marklogic.com/cts"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;cts:value xsi:type="xs:string"&gt;ROSENCRANTZ&lt;/cts:value&gt;
    &lt;cts:value xsi:type="xs:string"&gt;GUILDENSTERN&lt;/cts:value&gt;
  &lt;/cts:co-occurrence&gt;
  &lt;cts:co-occurrence xmlns:cts="http://marklogic.com/cts"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;cts:value xsi:type="xs:string"&gt;HORATIO&lt;/cts:value&gt;
    &lt;cts:value xsi:type="xs:string"&gt;MARCELLUS&lt;/cts:value&gt;
  &lt;/cts:co-occurrence&gt;

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-value-co-occurrences" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns value co-occurrences from the specified element or element-attribute
  value lexicon(s). 
  Value lexicons are implemented using range indexes; 
  consequently this function requires a range index for each element/attribute
  pairs specified in the function.  
  If there is not a range index configured for each of the specified 
  element or element/attribute pairs, then an exception is thrown. 
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-name-1" type="xs:QName" optional="false">
    An element QName.
  </apidoc:param>
      <apidoc:param name="attribute-name-1" type="xs:QName?" optional="false">
    An attribute QName or empty sequence.  
    The empty sequence specifies an element lexicon.
  </apidoc:param>
      <apidoc:param name="element-name-2" type="xs:QName" optional="false">
    An element QName.
  </apidoc:param>
      <apidoc:param name="attribute-name-2" type="xs:QName?" optional="false">
    An attribute QName or empty sequence.
    The empty sequence specifies an element lexicon.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Co-occurrences should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Co-occurrences should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Co-occurrences from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Co-occurrences from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Co-occurrences from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Co-occurrences from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Co-occurrences should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Co-occurrences should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included co-occurrences.  
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included co-occurrence. 
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"type=<em>type</em>"</dt>
        <dd>For both lexicons, use the type specified by <em>type</em> 
        (int, unsignedInt, long, unsignedLong, float, double, decimal, 
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay, 
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"type-1=<em>type</em>"</dt>
        <dd>For the first lexicon, use the type specified by <em>type</em> 
        (int, unsignedInt, long, unsignedLong, float, double, decimal, 
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay, 
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"type-2=<em>type</em>"</dt>
        <dd>For the second lexicon, use the type specified by <em>type</em> 
        (int, unsignedInt, long, unsignedLong, float, double, decimal, 
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay, 
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>For both lexicons, use the collation specified by 
        <em>URI</em>.</dd>
        <dt>"collation-1=<em>URI</em>"</dt>
        <dd>For the first lexicon, use the collation specified by 
        <em>URI</em>.</dd>
        <dt>"collation-2=<em>URI</em>"</dt>
        <dd>For the second lexicon, use the collation specified by 
        <em>URI</em>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date, 
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.  
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"ordered"</dt>
        <dd>Include co-occurrences only when the value from the first lexicon
        appears before the value from the second lexicon.
        Requires that word positions be enabled for both lexicons.</dd>
        <dt>"proximity=<em>N</em>"</dt>
        <dd>Include co-occurrences only when the values appear within 
        <em>N</em> words of each other.
        Requires that word positions be enabled for both lexicons.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> co-occurrences.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only co-occurrences from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only co-occurrences from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint 
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon 
        processing occurs.  This is especially useful in cases where multiple 
        lexicon calls occur in the same query (for example, resolving many 
        facets in a single query).</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include co-occurrences in fragments selected by the 
    <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.
    The co-occurrences do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query, 
    but instead selected in the same manner as <a href="#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the 
   specified string.    
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>element(cts:co-occurrence)*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified 
  in the options parameter.  If neither "frequency-order" nor "item-order" 
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified 
  in the options parameter.  If neither "fragment-frequency" nor 
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified 
  in the options parameter.  If neither "ascending" nor "descending" 
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks" 
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  or "score-random" options may be specified in the options parameter. 
  If none of "score-logtfidf", "score-logtf", "score-simple", or 
  "score-random" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter. 
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter, 
  then all included co-occurrences may be returned.  
  If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter, 
  then co-occurrences from all fragments selected by the 
  <code>$query</code> parameter are included.  
  If a <code>$query</code> parameter is not present, then  
  "truncate=<em>N</em>" has no effect.</p>
</apidoc:usage>
  </apidoc:function><apidoc:function name="element-value-ranges" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  <p xmlns="http://www.w3.org/1999/xhtml">Returns value ranges from the specified element value lexicon(s).  
  Value lexicons are implemented using range indexes; consequently this 
  function requires an element range index for each element specified 
  in the function.  If there is not a range index configured for each 
  of the specified elements, an exception is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">The values are divided into buckets. The $bounds parameter specifies
  the number of buckets and the size of each bucket. 
  All included values are bucketed, even those less than the lowest bound
  or greater than the highest bound. An empty sequence for $bounds specifies
  one bucket, a single value specifies two buckets, two values specify
  three buckets, and so on.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If you have string values and you pass a $bounds parameter
   as in the following call:</p>
  <pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">cts:element-value-ranges(xs:QName("myElement"), ("f", "m"))</pre>
  <p xmlns="http://www.w3.org/1999/xhtml">The first bucket contains string values that are less than the
  string <code>f</code>, the second bucket contains string values greater than
  or equal to <code>f</code> but less than <code>m</code>, and the third bucket 
  contains string values that are greater than or equal to <code>m</code>.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">For each non-empty bucket, a <code>cts:range</code> element is returned.
  Each <code>cts:range</code> element has a <code>cts:minimum</code> child
  and a <code>cts:maximum</code> child.  If a bucket is bounded, its
  <code>cts:range</code> element will also have a 
  <code>cts:lower-bound</code> child if it is bounded from below, and
  a <code>cts:upper-bound</code> element if it is bounded from above.
  Empty buckets return nothing unless the "empties" option is specified.</p>
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*" optional="false">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="bounds" type="xs:anyAtomicType*" optional="true">
    A sequence of range bounds. 
    The types must match the lexicon type.
    The values must be in strictly ascending order, otherwise an exception
    is thrown.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Ranges should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Ranges should be returned in descending order.</dd>
        <dt>"empties"</dt>
        <dd>Include fully-bounded ranges whose frequency is 0. These ranges 
        will have no minimum or maximum value.  Only empty ranges that have 
        both their upper and lower bounds specified in the $bounds 
        options are returned;
        any empty ranges that are less than the first bound or greater than the 
        last bound are not returned.  For example, if you specify 4 bounds
        and there are no results for any of the bounds, 3 elements are 
        returned (not 5 elements).</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Ranges should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Ranges should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value.  
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value. 
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em> 
        (int, unsignedInt, long, unsignedLong, float, double, decimal, 
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay, 
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date, 
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.  
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> ranges.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only ranges for buckets with at least one value from the
        first <em>N</em> fragments selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only values from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint 
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon 
        processing occurs.  This is especially useful in cases where multiple 
        lexicon calls occur in the same query (for example, resolving many 
        facets in a single query).</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query, 
    but instead selected in the same manner as <a href="#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the 
   specified string.    
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>element(cts:range)*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified 
  in the options parameter.  If neither "frequency-order" nor "item-order" 
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified 
  in the options parameter.  If neither "fragment-frequency" nor 
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified 
  in the options parameter.  If neither "ascending" nor "descending" 
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks" 
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  or "score-random" options may be specified in the options parameter. 
  If none of "score-logtfidf", "score-logtf", "score-simple", or 
  "score-random" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter. 
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter,
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter, 
  then ranges with all included values may be returned. If a 
  <code>$query</code> parameter is not present, then "sample=<em>N</em>" 
  has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter, 
  then values from all fragments selected by the <code>$query</code> parameter 
  are included.  If a <code>$query</code> parameter is not present, then  
  "truncate=<em>N</em>" has no effect.</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: Run the following to load data for this example.
   Make sure you have an int element range index on 
   number. :)
for $x in  (1 to 10)
return
xdmp:document-insert(fn:concat("/doc", fn:string($x), ".xml"),
 &lt;root&gt;&lt;number&gt;{$x}&lt;/number&gt;&lt;/root&gt;) ;

(: The following is based on the above setup :)
cts:element-value-ranges(xs:QName("number"),
  (5, 10, 15, 20), "empties")
=&gt;

&lt;cts:range xmlns:cts="http://marklogic.com/cts" 
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:minimum xsi:type="xs:int"&gt;1&lt;/cts:minimum&gt;
  &lt;cts:maximum xsi:type="xs:int"&gt;4&lt;/cts:maximum&gt;
  &lt;cts:upper-bound xsi:type="xs:int"&gt;5&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts" 
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:minimum xsi:type="xs:int"&gt;5&lt;/cts:minimum&gt;
  &lt;cts:maximum xsi:type="xs:int"&gt;9&lt;/cts:maximum&gt;
  &lt;cts:lower-bound xsi:type="xs:int"&gt;5&lt;/cts:lower-bound&gt;
  &lt;cts:upper-bound xsi:type="xs:int"&gt;10&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts" 
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:minimum xsi:type="xs:int"&gt;10&lt;/cts:minimum&gt;
  &lt;cts:maximum xsi:type="xs:int"&gt;10&lt;/cts:maximum&gt;
  &lt;cts:lower-bound xsi:type="xs:int"&gt;10&lt;/cts:lower-bound&gt;
  &lt;cts:upper-bound xsi:type="xs:int"&gt;15&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts" 
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:lower-bound xsi:type="xs:int"&gt;15&lt;/cts:lower-bound&gt;
  &lt;cts:upper-bound xsi:type="xs:int"&gt;20&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts" 
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:lower-bound xsi:type="xs:int"&gt;20&lt;/cts:lower-bound&gt;
&lt;/cts:range&gt;

  
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  (: this query has the database fragmented on SPEECH and 
     finds four ranges of SPEAKERs :)
  cts:element-value-ranges(xs:QName("SPEAKER"),("F","N","S"));
  =&gt; 
  &lt;cts:range xmlns:cts="http://marklogic.com/cts" 
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
      xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;cts:minimum xsi:type="xs:string"&gt;All&lt;/cts:minimum&gt;
    &lt;cts:maximum xsi:type="xs:string"&gt;Danes&lt;/cts:maximum&gt;
    &lt;cts:upper-bound xsi:type="xs:string"&gt;F&lt;/cts:maximum&gt;
  &lt;/cts:range&gt;
  &lt;cts:range xmlns:cts="http://marklogic.com/cts" 
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
      xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;cts:minimum xsi:type="xs:string"&gt;First Ambassador&lt;/cts:minimum&gt;
    &lt;cts:maximum xsi:type="xs:string"&gt;Messenger&lt;/cts:maximum&gt;
    &lt;cts:lower-bound xsi:type="xs:string"&gt;F&lt;/cts:maximum&gt;
    &lt;cts:upper-bound xsi:type="xs:string"&gt;N&lt;/cts:maximum&gt;
  &lt;/cts:range&gt;
  &lt;cts:range xmlns:cts="http://marklogic.com/cts" 
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
      xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;cts:minimum xsi:type="xs:string"&gt;OPHELIA&lt;/cts:minimum&gt;
    &lt;cts:maximum xsi:type="xs:string"&gt;ROSENCRANTZ&lt;/cts:maximum&gt;
    &lt;cts:lower-bound xsi:type="xs:string"&gt;N&lt;/cts:maximum&gt;
    &lt;cts:upper-bound xsi:type="xs:string"&gt;S&lt;/cts:maximum&gt;
  &lt;/cts:range&gt;
  &lt;cts:range xmlns:cts="http://marklogic.com/cts" 
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
      xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;cts:minimum xsi:type="xs:string"&gt;Second Clown&lt;/cts:minimum&gt;
    &lt;cts:maximum xsi:type="xs:string"&gt;VOLTIMAND&lt;/cts:maximum&gt;
    &lt;cts:lower-bound xsi:type="xs:string"&gt;S&lt;/cts:maximum&gt;
  &lt;/cts:range&gt;

</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  (: this is the same query has above, but it is getting the counts
     of the number of SPEAKERs for each bucket :)
  for $bucket in cts:element-value-ranges(xs:QName("SPEAKER"),("F","N","S"))
  return cts:frequency($bucket);
  =&gt; 
  9602
  11329
  5167
  4983
  
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="frequency" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns an integer representing the number of times in which a particular 
  value occurs in a value lexicon lookup (for example, 
  <code xmlns="http://www.w3.org/1999/xhtml">cts:element-values</code>).  When using the 
  <code xmlns="http://www.w3.org/1999/xhtml">fragment-frequency</code> lexicon option, <code xmlns="http://www.w3.org/1999/xhtml">cts:frequency</code>
  returns the number of fragments in which the lexicon value occurs. When
  using the <code xmlns="http://www.w3.org/1999/xhtml">item-frequency</code> lexicon option, 
  <code xmlns="http://www.w3.org/1999/xhtml">cts:frequency</code> returns the total number of times 
  in which the lexicon value occurs in each item.   
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="value" type="item()" optional="false">
    A value from a value lexicon lookup.  The value should be one returned 
   from the <a href="#cts:element-values" xmlns="http://www.w3.org/1999/xhtml"><code>cts:element-values</code></a>,  
    <a href="#cts:element-attribute-values" xmlns="http://www.w3.org/1999/xhtml">
    <code>cts:element-attribute-values</code></a>, or the corresponding
    <code xmlns="http://www.w3.org/1999/xhtml">value-match</code> lexicon APIs.   
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:integer</apidoc:return>
    <apidoc:usage>
 <p xmlns="http://www.w3.org/1999/xhtml">You must have a Range index configured to use the value lexicon APIs
 (<code>cts:element-values</code>, <code>cts:element-value-match</code>, 
 <code>cts:element-attribute-values</code>, or
 <code>cts:element-attribute-value-match</code>).
 </p>
 <p xmlns="http://www.w3.org/1999/xhtml">If the value specified is not from a value lexicon lookup, 
 <code>cts:frequency</code> returns a frequency of 0.</p>
 <p xmlns="http://www.w3.org/1999/xhtml">The frequency returned from <code>cts:frequency</code> is fragment-based
 by default (using the default <code>fragment-frequency</code> option in the 
 lexicon API).  If there are multiple occurences of the value in any given 
 fragment, the frequency is still one per fragment when using 
 <code>fragment-frequency</code>. Therefore, if the value 
 returned is 13, it means that the value occurs in 13 fragments.</p>
 <p xmlns="http://www.w3.org/1999/xhtml">If you want the total frequency instead of the fragment-based frequency 
 (that is, the total number of occurences of the value in the items specified
 in the <code>cts:query</code> option of the lexicon API), 
 you must specify the <code>item-frequency</code> option to the lexicon
 API value input to <code>cts:frequency</code>. For example, the second
 example below specifies an <code>item-frequency</code> and a
 <code>cts:document-query</code> in the lexicon
 API, so the item frequency is how many times each speaker speaks in the 
 play (because the constraining query is a document query of hamlet.xml, which
 contains the whole play).</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
&lt;results&gt;{
let $x := cts:element-values(xs:QName("SPEAKER"),"",(), 
  cts:document-query("/shakespeare/plays/hamlet.xml"))
for $speaker in $x
return 
(
&lt;result&gt;
  &lt;SPEAKER&gt;{$speaker}&lt;/SPEAKER&gt; 
  &lt;NUMBER-OF-SPEECHES&gt;{cts:frequency($speaker)}&lt;/NUMBER-OF-SPEECHES&gt; 
&lt;/result&gt;
)
}&lt;/results&gt;

=&gt; Returns the names of the speakers in Hamlet
   with the number of times they speak. If the
   play is fragmented at the SCENE level, then 
   it returns the number of scenes in which each 
   speaker speaks. 
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
&lt;results&gt;{
let $x := cts:element-values(xs:QName("SPEAKER"),
  "", "item-frequency", 
  cts:document-query("/shakespeare/plays/hamlet.xml"))
for $speaker in $x
return 
(
&lt;result&gt;
  &lt;SPEAKER&gt;{$speaker}&lt;/SPEAKER&gt; 
  &lt;NUMBER-OF-SPEECHES&gt;
    {cts:frequency($speaker)}
  &lt;/NUMBER-OF-SPEECHES&gt; 
&lt;/result&gt;
)
}&lt;/results&gt;

=&gt; Returns the names of the speakers in Hamlet
   with the number of times they speak. Returns
   the total times they speak, regardless
   of fragmentation. 
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="sum" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a frequency-weighted sum of a sequence.  
  This function works like <code xmlns="http://www.w3.org/1999/xhtml">fn:sum</code> except each item in the 
  sequence is multiplied by <code xmlns="http://www.w3.org/1999/xhtml">cts:frequency</code> before summing.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="arg" type="xs:anyAtomicType*" optional="false">
   The sequence of values to be summed.  The values should be the result of 
   a lexicon lookup.
  </apidoc:param>
      <apidoc:param name="zero" type="xs:anyAtomicType?" optional="true">
   The value to return as zero if the input sequence is the empty sequence. 
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType?</apidoc:return>
    <apidoc:usage>
 <p xmlns="http://www.w3.org/1999/xhtml">The <code>cts:frequency</code> of the result is the sum of the 
 frequencies of the sequence.</p>
 <p xmlns="http://www.w3.org/1999/xhtml">This function is designed to take a sequence of values returned
 by a lexicon function (for example, <code>cts:element-values</code>); if you
 input non-lexicon values, the result will always be 0.</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
xquery version "1.0-ml";

(: 
   This query assumes an int range index 
   is configured in the database. It
   generates some sample data and then 
   performs the aggregation in a separate
   transaction. 
:)
for $x in 1 to 10
return
xdmp:document-insert(fn:concat($x, ".xml"),
&lt;my-element&gt;{
  for $y in 1 to $x 
  return &lt;int&gt;{$x}&lt;/int&gt;
}&lt;/my-element&gt;);

cts:sum(cts:element-values(xs:QName("int"), (), 
           ("type=int", "item-frequency"))),
cts:sum(cts:element-values(xs:QName("int"), (), 
           ("type=int", "fragment-frequency")))
=&gt;
385
55


</pre></apidoc:example>
  </apidoc:function><apidoc:function name="count" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a frequency-weighted count of a sequence.  
  This function works like <code xmlns="http://www.w3.org/1999/xhtml">fn:count</code> except the count
  of each item is multiplied by <code xmlns="http://www.w3.org/1999/xhtml">cts:frequency</code>.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="arg" type="item()*" optional="false">
  The sequence of items to count.  The items should be the result of 
   a lexicon lookup.
  </apidoc:param>
      <apidoc:param name="maximum" type="xs:double" optional="true">
  The maximum value of the count to return. MarkLogic Server will stop
  counting when the $maximum value is reached and return 
  the $maximum value.  
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:integer</apidoc:return>
    <apidoc:usage>
 <p xmlns="http://www.w3.org/1999/xhtml">This function is designed to take a sequence of values returned
 by a lexicon function (for example, <code>cts:element-values</code>); if you
 input non-lexicon values, the result will always be 0.</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
xquery version "1.0-ml";

(: 
   This query assumes an int range index 
   is configured in the database. It
   generates some sample data and then 
   performs the aggregation in a separate
   transaction.
:)
for $x in 1 to 10
return
xdmp:document-insert(fn:concat($x, ".xml"),
&lt;my-element&gt;{
  for $y in 1 to $x 
  return &lt;int&gt;{$x}&lt;/int&gt;
}&lt;/my-element&gt;);

cts:count(cts:element-values(xs:QName("int"), (), 
           ("type=int", "item-frequency"))),
cts:count(cts:element-values(xs:QName("int"), (), 
           ("type=int", "fragment-frequency")))
=&gt;
55
10


</pre></apidoc:example>
  </apidoc:function><apidoc:function name="avg" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a frequency-weighted average of a sequence.  
  This function works like <code xmlns="http://www.w3.org/1999/xhtml">fn:avg</code> except each item in the 
  sequence is multiplied by <code xmlns="http://www.w3.org/1999/xhtml">cts:frequency</code> before summing.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="arg" type="xs:anyAtomicType*" optional="false">
   The sequence of values to be averaged.  The values should be the result of 
   a lexicon lookup.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType?</apidoc:return>
    <apidoc:usage>
 <p xmlns="http://www.w3.org/1999/xhtml">This function is designed to take a sequence of values returned
 by a lexicon function (for example, <code>cts:element-values</code>); if you
 input non-lexicon values, the result will always be 0.</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
xquery version "1.0-ml";

(: 
   This query assumes an int range index 
   is configured in the database. It
   generates some sample data and then 
   performs the aggregation in a separate
   transaction. 
:)
for $x in 1 to 10
return
xdmp:document-insert(fn:concat($x, ".xml"),
&lt;my-element&gt;{
  for $y in 1 to $x 
  return &lt;int&gt;{$x}&lt;/int&gt;
}&lt;/my-element&gt;);

cts:avg(cts:element-values(xs:QName("int"), (), 
           ("type=int", "item-frequency"))),
cts:avg(cts:element-values(xs:QName("int"), (), 
           ("type=int", "fragment-frequency")))
=&gt;
7
5.5


</pre></apidoc:example>
  </apidoc:function><apidoc:function name="uris" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns values from the URI lexicon. 
  This function requires the uri-lexicon database configuration 
  parameter to be enabled. If the uri-lexicon database-configuration 
  parameter is not enabled, an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="start" type="xs:string?" optional="true">
    A starting value.  Return only this value and following values.  If
    the empty string, return all values.  If the parameter is is not in
    the lexicon, then it returns the values beginning with the next
    value.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>URIs should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>URIs should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>URIs from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>URIs from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>URIs from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>URIs from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>URIs should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>URIs should be returned ordered by item.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> URIs.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only URIs from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only URIs from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint 
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon 
        processing occurs.  This is especially useful in cases where multiple 
        lexicon calls occur in the same query (for example, resolving many 
        facets in a single query).</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include URIs from fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.  
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as <a href="#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the 
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified 
  in the options parameter.  If neither "frequency-order" nor "item-order" 
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified 
  in the options parameter.  If neither "ascending" nor "descending" 
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks" 
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  or "score-random" options may be specified in the options parameter. 
  If none of "score-logtfidf", "score-logtf", "score-simple", or 
  "score-random" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter. 
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter, 
  then all included URIs may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter, 
  then URIs from all fragments selected by the <code>$query</code> parameter 
  are included.  If a <code>$query</code> parameter is not present, then  
  "truncate=<em>N</em>" has no effect.</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:uris("http://foo.com/")
  =&gt; ("http://foo.com/", "http://foo.com/bar.html", ...)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="uri-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
   Returns values from the URI lexicon
   that match the specified wildcard pattern. 
   This function requires the uri-lexicon database configuration 
   parameter to be enabled. If the uri-lexicon database-configuration 
   parameter is not enabled, an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="pattern" type="xs:string" optional="false">
    Wildcard pattern to match.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive match.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive match.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive match.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive match.</dd>
        <dt>"ascending"</dt>
        <dd>URIs should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>URIs should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>URIs from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>URIs from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>URIs from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>URIs from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>URIs should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>URIs should be returned ordered by item.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> URIs.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only URIs from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only URIs from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint 
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon 
        processing occurs.  This is especially useful in cases where multiple 
        lexicon calls occur in the same query (for example, resolving many 
        facets in a single query).</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include URIs from fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.  
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as <a href="#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the 
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified 
  in the options parameter.  If neither "frequency-order" nor "item-order" 
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified 
  in the options parameter.  If neither "ascending" nor "descending" 
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks" 
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  or "score-random" options may be specified in the options parameter. 
  If none of "score-logtfidf", "score-logtf", "score-simple", or 
  "score-random" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter. 
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter, 
  then all included URIs may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter, 
  then URIs from all fragments selected by the <code>$query</code> parameter 
  are included.  If a <code>$query</code> parameter is not present, then  
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive" 
    is present, $pattern is used to determine case sensitivity.
    If $pattern contains no uppercase, it specifies "case-insensitive".
    If $pattern contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive" 
    is present, $pattern is used to determine diacritic sensitivity.
    If $pattern contains no diacritics, it specifies "diacritic-insensitive".
    If $pattern contains diacritics, it specifies "diacritic-sensitive".
  </p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:uri-match("http://foo.com/*.html")
  =&gt; ("http://foo.com/bar.html", "http://foo.com/baz/bork.html", ...)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="collections" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns values from the collection lexicon. 
  This function requires the collection-lexicon database configuration 
  parameter to be enabled. If the collection-lexicon database-configuration 
  parameter is not enabled, an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="start" type="xs:string?" optional="true">
    A starting value.  Return only this value and following values.  
    If the parameter is is not in the lexicon, then it returns the values 
    beginning with the next value.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>URIs should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>URIs should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>URIs from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>URIs from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>URIs from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>URIs from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>URIs should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>URIs should be returned ordered by item.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> URIs.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only URIs from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.  
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only URIs from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.  
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint 
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon 
        processing occurs.  This is especially useful in cases where multiple 
        lexicon calls occur in the same query (for example, resolving many 
        facets in a single query).</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include URIs from fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.  
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as <a href="#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the 
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified 
  in the options parameter.  If neither "frequency-order" nor "item-order" 
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified 
  in the options parameter.  If neither "ascending" nor "descending" 
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks" 
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  or "score-random" options may be specified in the options parameter. 
  If none of "score-logtfidf", "score-logtf", "score-simple", or 
  "score-random" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter. 
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter, 
  then all included words may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter, 
  then words from all fragments selected by the <code>$query</code> parameter 
  are included.  If a <code>$query</code> parameter is not present, then  
  "truncate=<em>N</em>" has no effect.</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:collections("aardvark")
  =&gt; ("aardvark", "aardvarks", ...)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="collection-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
   Returns values from the collection lexicon
   that match the specified wildcard pattern. 
   This function requires the collection-lexicon database configuration 
   parameter to be enabled. If the uri-lexicon database-configuration 
   parameter is not enabled, an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="pattern" type="xs:string" optional="false">
    Wildcard pattern to match.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive match.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive match.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive match.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive match.</dd>
        <dt>"ascending"</dt>
        <dd>URIs should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>URIs should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>URIs from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>URIs from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>URIs from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>URIs from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>URIs should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>URIs should be returned ordered by item.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> URIs.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only URIs from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only URIs from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint 
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon 
        processing occurs.  This is especially useful in cases where multiple 
        lexicon calls occur in the same query (for example, resolving many 
        facets in a single query).</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include URIs from fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.  
    The fragments are not filtered to ensure they match the query,
    but instead selected in the same manner as <a href="#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the 
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified 
  in the options parameter.  If neither "frequency-order" nor "item-order" 
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified 
  in the options parameter.  If neither "ascending" nor "descending" 
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks" 
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  or "score-random" options may be specified in the options parameter. 
  If none of "score-logtfidf", "score-logtf", "score-simple", or 
  "score-random" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter. 
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter, 
  then all included URIs may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter, 
  then URIs from all fragments selected by the <code>$query</code> parameter 
  are included.  If a <code>$query</code> parameter is not present, then  
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive" 
    is present, $pattern is used to determine case sensitivity.
    If $pattern contains no uppercase, it specifies "case-insensitive".
    If $pattern contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive" 
    is present, $pattern is used to determine diacritic sensitivity.
    If $pattern contains no diacritics, it specifies "diacritic-insensitive".
    If $pattern contains diacritics, it specifies "diacritic-sensitive".
  </p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:collection-match("collection*")
  =&gt; ("collection1", "collection2", ...)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-words" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns words from the specified element-attribute word lexicon(s).
  This function requires an element-attribute word lexicon for each of the
  element/attribute pairs specified in the function.  If there is not an
  element/attribute word lexicon configured for any of the specified
  element/attribute pairs, then an exception is thrown.  The words are
  returned in collation order.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*" optional="false">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="attribute-names" type="xs:QName*" optional="false">
    One or more attribute QNames.
  </apidoc:param>
      <apidoc:param name="start" type="xs:string?" optional="true">
    A starting word.  Returns only this word and any following words
    from the lexicon.  If the parameter is not in the lexicon, then it
    returns the words beginning with the next word.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Words should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Words should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Words from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Words from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Words from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Words from locks fragments should be included.</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> words.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only words from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only words from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint 
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon 
        processing occurs.  This is especially useful in cases where multiple 
        lexicon calls occur in the same query (for example, resolving many 
        facets in a single query).</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include words in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.
    The words do not need to match the query, but the words must occur
    in fragments selected by the query.
    The fragments are not filtered to ensure they match the query, 
    but instead selected in the same manner as <a href="#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the 
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified 
  in the options parameter.  If neither "ascending" nor "descending" 
  is specified, then the default is "ascending".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks" 
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  or "score-random" options may be specified in the options parameter. 
  If none of "score-logtfidf", "score-logtf", "score-simple", or 
  "score-random" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter. 
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter, 
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter, 
  then all included words may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter, 
  then words from all fragments selected by the <code>$query</code> parameter 
  are included.  If a <code>$query</code> parameter is not present, then  
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">When multiple element and/or attribute QNames are specified,
  then all possible element/attribute QName combinations are used
  to select the matching values.</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-attribute-words(xs:QName("animal"),
                              xs:QName("name"),
                              "aardvark")
  =&gt; ("aardvark","aardvarks","aardwolf",...)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-word-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns words from the specified element-attribute word lexicon(s) that 
  match a wildcard pattern.   This function requires an element-attribute 
  word lexicon for each of the element/attribute pairs specified in the 
  function.  If there is not an element-attribute word lexicon
  configured for any of the specified element/attribute pairs, then
  an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*" optional="false">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="attribute-names" type="xs:QName*" optional="false">
    One or more attribute QNames.
  </apidoc:param>
      <apidoc:param name="pattern" type="xs:string" optional="false">
    Wildcard pattern to match.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive match.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive match.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive match.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive match.</dd>
        <dt>"ascending"</dt>
        <dd>Words should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Words should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Words from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Words from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Words from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Words from locks fragments should be included.</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> words.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only words from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only words from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint 
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon 
        processing occurs.  This is especially useful in cases where multiple 
        lexicon calls occur in the same query (for example, resolving many 
        facets in a single query).</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include words in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.
    The words do not need to match the query, but the words must occur
    in fragments selected by the query.
    The fragments are not filtered to ensure they match the query, 
    but instead selected in the same manner as <a href="#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the 
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified 
  in the options parameter.  If neither "ascending" nor "descending" 
  is specified, then the default is "ascending".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks" 
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  or "score-random" options may be specified in the options parameter. 
  If none of "score-logtfidf", "score-logtf", "score-simple", or 
  "score-random" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter. 
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter, 
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter, 
  then all included words may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter, 
  then words from all fragments selected by the <code>$query</code> parameter 
  are included.  If a <code>$query</code> parameter is not present, then  
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive" 
    is present, $pattern is used to determine case sensitivity.
    If $pattern contains no uppercase, it specifies "case-insensitive".
    If $pattern contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive" 
    is present, $pattern is used to determine diacritic sensitivity.
    If $pattern contains no diacritics, it specifies "diacritic-insensitive".
    If $pattern contains diacritics, it specifies "diacritic-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When multiple element and/or attribute QNames are specified,
  then all possible element/attribute QName combinations are used
  to select the matching values.</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-word-match(xs:QName("animals"),"aardvark*")
  =&gt; ("aardvark","aardvarks")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-values" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns values from the specified element-attribute value lexicon(s).
  Element-attribute value lexicons are implemented using indexes; 
  consequently this function requires an attribute range index
  of for each of the element/attribute pairs specified in the function. 
  If there is not a range index configured for each of the specified
  element/attribute pairs, then an exception is thrown.  
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*" optional="false">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="attribute-names" type="xs:QName*" optional="false">
    One or more attribute QNames.
  </apidoc:param>
      <apidoc:param name="start" type="xs:anyAtomicType?" optional="true">
    A starting value.  The parameter type must match the lexicon type.
    If the parameter value is is not in the lexicon, then the values are 
    returned beginning with the next value.  
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Values should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Values should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Values should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Values should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value. 
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em> 
        (int, unsignedInt, long, unsignedLong, float, double, decimal, 
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay, 
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the range index with the collation specified by 
        <em>URI</em>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date, 
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.  
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> values.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only values from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only values from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint 
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon 
        processing occurs.  This is especially useful in cases where multiple 
        lexicon calls occur in the same query (for example, resolving many 
        facets in a single query).</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query, 
    but instead selected in the same manner as <a href="#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the 
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified 
  in the options parameter.  If neither "frequency-order" nor "item-order" 
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified 
  in the options parameter.  If neither "fragment-frequency" nor 
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified 
  in the options parameter.  If neither "ascending" nor "descending" 
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks" 
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  or "score-random" options may be specified in the options parameter. 
  If none of "score-logtfidf", "score-logtf", "score-simple", or 
  "score-random" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter. 
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter, 
  then the default collation is used. If a range index with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter, 
  then all included values may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter, 
  then values from all fragments selected by the <code>$query</code> parameter 
  are included.  If a <code>$query</code> parameter is not present, then  
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">When multiple element and/or attribute QNames are specified,
  then all possible element/attribute QName combinations are used
  to select the matching values.</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-attribute-values(xs:QName("animal"),
                               xs:QName("name"),
                               "aardvark")
  =&gt; ("aardvark","aardvarks","aardwolf",...)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-value-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
   Returns values from the specified element-attribute value lexicon(s)
   that match the specified pattern.  Element-attribute value lexicons are 
   implemented using range indexes; consequently this function requires an
   attribute range index for each of the element/attribute pairs specified 
   in the function.  If there is not a range index configured for each of the
   specified element/attribute pairs, then an exception is thrown. 
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*" optional="false">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="attribute-names" type="xs:QName*" optional="false">
    One or more attribute QNames.
  </apidoc:param>
      <apidoc:param name="pattern" type="xs:anyAtomicType" optional="false">
    A pattern to match.  The parameter type must match the lexicon type.
    String parameters may include wildcard characters.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive match.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive match.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive match.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive match.</dd>
        <dt>"ascending"</dt>
        <dd>Values should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Values should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Values should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Values should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value.  
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-order"</dt>
        <dd>Values should be returned ordered by item.</dd>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em> 
        (int, unsignedInt, long, unsignedLong, float, double, decimal, 
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay, 
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the range index with the collation specified by 
        <em>URI</em>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date, 
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.  
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> values.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only values occurring in the first <em>N</em> fragments
        selected by the <code>cts:query</code>;  only values in fragments
        satisfying the <code>cts:query</code> are returned, but any analytics 
        calculations (using <code>cts:frequency</code>, for example)
        use all the lexicon values, not just the ones constrained by the 
        <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only values from the first <em>N</em> fragments
        selected by the <code>cts:query</code>; only values in fragments
        satisfying the <code>cts:query</code> are returned, and only those
        values are used in calculating any analytics (using 
        <code>cts:frequency</code>, for example).
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint 
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon 
        processing occurs.  This is especially useful in cases where multiple 
        lexicon calls occur in the same query (for example, resolving many 
        facets in a single query).</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query, 
    but instead selected in the same manner as <a href="#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the 
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:anyAtomicType*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified 
  in the options parameter.  If neither "frequency-order" nor "item-order" 
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified 
  in the options parameter.  If neither "fragment-frequency" nor 
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified 
  in the options parameter.  If neither "ascending" nor "descending" 
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks" 
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  or "score-random" options may be specified in the options parameter. 
  If none of "score-logtfidf", "score-logtf", "score-simple", or 
  "score-random" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter. 
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter, 
  then the default collation is used. If a range index with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter, 
  then all included values may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter, 
  then values from all fragments selected by the <code>$query</code> parameter 
  are included.  If a <code>$query</code> parameter is not present, then  
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive" 
    is present, $pattern is used to determine case sensitivity.
    If $pattern contains no uppercase, it specifies "case-insensitive".
    If $pattern contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive" 
    is present, $pattern is used to determine diacritic sensitivity.
    If $pattern contains no diacritics, it specifies "diacritic-insensitive".
    If $pattern contains diacritics, it specifies "diacritic-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">When multiple element and/or attribute QNames are specified,
  then all possible element/attribute QName combinations are used
  to select the matching values.</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:element-attribute-value-match(xs:QName("animals"),
                     xs:QName("name"),"aardvark*")
  =&gt; ("aardvark","aardvarks")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="element-attribute-value-ranges" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  <p xmlns="http://www.w3.org/1999/xhtml">Returns value ranges from the specified element-attribute value lexicon(s).
  Element-attribute value lexicons are implemented using indexes; 
  consequently this function requires an attribute range index
  of for each of the element/attribute pairs specified in the function. 
  If there is not a range index configured for each of the specified
  element/attribute pairs, then an exception is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">The values are divided into buckets. The $bounds parameter specifies
  the number of buckets and the size of each bucket. 
  All included values are bucketed, even those less than the lowest bound
  or greater than the highest bound. An empty sequence for $bounds specifies
  one bucket, a single value specifies two buckets, two values specify
  three buckets, and so on.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If you have string values and you pass a $bounds parameter
   as in the following call:</p>
  <pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">cts:element-value-ranges(xs:QName("myElement"), ("f", "m"))</pre>
  <p xmlns="http://www.w3.org/1999/xhtml">The first bucket contains string values that are less than the
  string <code>f</code>, the second bucket contains string values greater than
  or equal to <code>f</code> but less than <code>m</code>, and the third bucket 
  contains string values that are greater than or equal to <code>m</code>.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">For each non-empty bucket, a <code>cts:range</code> element is returned.
  Each <code>cts:range</code> element has a <code>cts:minimum</code> child
  and a <code>cts:maximum</code> child.  If a bucket is bounded, its
  <code>cts:range</code> element will also have a 
  <code>cts:lower-bound</code> child if it is bounded from below, and
  a <code>cts:upper-bound</code> element if it is bounded from above.
  Empty buckets return nothing unless the "empties" option is specified.</p>
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="element-names" type="xs:QName*" optional="false">
    One or more element QNames.
  </apidoc:param>
      <apidoc:param name="attribute-names" type="xs:QName*" optional="false">
    One or more attribute QNames.
  </apidoc:param>
      <apidoc:param name="bounds" type="xs:anyAtomicType*" optional="true">
    A sequence of range bounds. 
    The types must match the lexicon type.
    The values must be in strictly ascending order.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Ranges should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Ranges should be returned in descending order.</dd>
        <dt>"empties"</dt>
        <dd>Include fully-bounded ranges whose frequency is 0. These ranges 
        will have no minimum or maximum value.  Only empty ranges that have 
        both their upper and lower bounds specified in the $bounds 
        options are returned;
        any empty ranges that are less than the first bound or greater than the 
        last bound are not returned.  For example, if you specify 4 bounds
        and there are no results for any of the bounds, 3 elements are 
        returned (not 5 elements).</dd>
        <dt>"any"</dt>
        <dd>Values from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Values from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Values from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Values from locks fragments should be included.</dd>
        <dt>"frequency-order"</dt>
        <dd>Ranges should be returned ordered by frequency.</dd>
        <dt>"item-order"</dt>
        <dd>Ranges should be returned ordered by item.</dd>
        <dt>"fragment-frequency"</dt>
        <dd>Frequency should be the number of fragments with
        an included value. 
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"item-frequency"</dt>
        <dd>Frequency should be the number of occurences of
        an included value.
        This option is used with <code>cts:frequency</code>.</dd>
        <dt>"type=<em>type</em>"</dt>
        <dd>Use the lexicon with the type specified by <em>type</em> 
        (int, unsignedInt, long, unsignedLong, float, double, decimal, 
        dateTime, time, date, gYearMonth, gYear, gMonth, gDay, 
        yearMonthDuration, dayTimeDuration, string, or anyURI)</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the range index with the collation specified by 
        <em>URI</em>.</dd>
        <dt>"timezone=<em>TZ</em>"</dt>
        <dd>Return timezone sensitive values (dateTime, time, date, 
        gYearMonth, gYear, gMonth, and gDay) adjusted to the timezone
        specified by <em>TZ</em>.  
        Example timezones: Z, -08:00, +01:00.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> ranges.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only ranges for buckets with at least one value from the
        first <em>N</em> fragments selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only values from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint 
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon 
        processing occurs.  This is especially useful in cases where multiple 
        lexicon calls occur in the same query (for example, resolving many 
        facets in a single query).</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include values in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.
    The values do not need to match the query, but they must occur in
    fragments selected by the query.
    The fragments are not filtered to ensure they match the query, 
    but instead selected in the same manner as <a href="#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the 
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>element(cts:range)*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "frequency-order" or "item-order" may be specified 
  in the options parameter.  If neither "frequency-order" nor "item-order" 
  is specified, then the default is "item-order".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "fragment-frequency" or "item-frequency" may be specified 
  in the options parameter.  If neither "fragment-frequency" nor 
  "item-frequency" is specified, then the default is "fragment-frequency".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified 
  in the options parameter.  If neither "ascending" nor "descending" 
  is specified, then the default is "ascending" if "item-order" is
  specified, and "descending" if "frequency-order" is specified.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks" 
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  or "score-random" options may be specified in the options parameter. 
  If none of "score-logtfidf", "score-logtf", "score-simple", or 
  "score-random" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter. 
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter, 
  then the default collation is used. If a range index with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter, 
  then ranges with all included values may be returned. If a 
  <code>$query</code> parameter is not present, then "sample=<em>N</em>" 
  has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter, 
  then values from all fragments selected by the <code>$query</code> parameter 
  are included.  If a <code>$query</code> parameter is not present, then  
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">When multiple element and/or attribute QNames are specified,
  then all possible element/attribute QName combinations are used
  to select the matching values.</p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
(: Run the following to load data for this example.
   Make sure you have an int element attribute
   range index on my-node/@number. :)
for $x in  (1 to 10)
return
xdmp:document-insert(fn:concat("/doc", fn:string($x), ".xml"),
 &lt;root&gt;&lt;my-node number={$x}/&gt;&lt;/root&gt;) ;

(: The following is based on the above setup :)
cts:element-attribute-value-ranges(xs:QName("my-node"),
  xs:QName("number"), (5, 10, 15, 20), "empties")
=&gt;

&lt;cts:range xmlns:cts="http://marklogic.com/cts" 
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:minimum xsi:type="xs:int"&gt;1&lt;/cts:minimum&gt;
  &lt;cts:maximum xsi:type="xs:int"&gt;4&lt;/cts:maximum&gt;
  &lt;cts:upper-bound xsi:type="xs:int"&gt;5&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts" 
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:minimum xsi:type="xs:int"&gt;5&lt;/cts:minimum&gt;
  &lt;cts:maximum xsi:type="xs:int"&gt;9&lt;/cts:maximum&gt;
  &lt;cts:lower-bound xsi:type="xs:int"&gt;5&lt;/cts:lower-bound&gt;
  &lt;cts:upper-bound xsi:type="xs:int"&gt;10&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts" 
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:minimum xsi:type="xs:int"&gt;10&lt;/cts:minimum&gt;
  &lt;cts:maximum xsi:type="xs:int"&gt;10&lt;/cts:maximum&gt;
  &lt;cts:lower-bound xsi:type="xs:int"&gt;10&lt;/cts:lower-bound&gt;
  &lt;cts:upper-bound xsi:type="xs:int"&gt;15&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts" 
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:lower-bound xsi:type="xs:int"&gt;15&lt;/cts:lower-bound&gt;
  &lt;cts:upper-bound xsi:type="xs:int"&gt;20&lt;/cts:upper-bound&gt;
&lt;/cts:range&gt;
&lt;cts:range xmlns:cts="http://marklogic.com/cts" 
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
           xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;cts:lower-bound xsi:type="xs:int"&gt;20&lt;/cts:lower-bound&gt;
&lt;/cts:range&gt;

  
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-words" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns words from the specified field word lexicon.  This function
  requires an field lexicon for each of the field specified in the
  function.  If there is not an field word lexicon configured for any
  of the specified fields, an exception is thrown.  The words are
  returned in collation order.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="field-names" type="xs:string*" optional="false">
    One or more field names.
  </apidoc:param>
      <apidoc:param name="start" type="xs:string?" optional="true">
    A starting word.  Returns only this word and any following words
    from the lexicon.  If the parameter is not in the lexicon, then it
    returns the words beginning with the next word.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"ascending"</dt>
        <dd>Words should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Words should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Words from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Words from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Words from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Words from locks fragments should be included.</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> words.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only words from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only words from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint 
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon 
        processing occurs.  This is especially useful in cases where multiple 
        lexicon calls occur in the same query (for example, resolving many 
        facets in a single query).</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include words in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.
    The words do not need to match the query, but the words must occur
    in fragments selected by the query.
    The fragments are not filtered to ensure they match the query, 
    but instead selected in the same manner as <a href="#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the 
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified 
  in the options parameter.  If neither "ascending" nor "descending" 
  is specified, then the default is "ascending".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks" 
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  or "score-random" options may be specified in the options parameter. 
  If none of "score-logtfidf", "score-logtf", "score-simple", or 
  "score-random" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter. 
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter, 
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter, 
  then all included words may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter, 
  then words from all fragments selected by the <code>$query</code> parameter 
  are included.  If a <code>$query</code> parameter is not present, then  
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only words that can be matched with field-word-query are included.
  That is, only words present in immediate text node children of the 
  specified field as well as any text node children of child fields
  defined in the Admin Interface as field-word-query-throughs or 
  phrase-throughs. </p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:field-words("animal","aardvark")
  =&gt; ("aardvark","aardvarks","aardwolf",...)
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="field-word-match" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Lexicon" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns words from the specified field word lexicon(s) that match 
  a wildcard pattern.   This function requires an field word lexicon 
  configured for each of the specified fields in the function.  If there 
  is not an field word lexicon configured for any of the specified 
  fields, an exception is thrown.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="field-names" type="xs:string*" optional="false">
    One or more field names.
  </apidoc:param>
      <apidoc:param name="pattern" type="xs:string" optional="false">
    Wildcard pattern to match.
  </apidoc:param>
      <apidoc:param name="options" type="xs:string*" optional="true">
    Options.  The default is ().
    <p xmlns="http://www.w3.org/1999/xhtml">
      Options include:</p>
      <blockquote xmlns="http://www.w3.org/1999/xhtml"><dl>
        <dt>"case-sensitive"</dt>
        <dd>A case-sensitive match.</dd>
        <dt>"case-insensitive"</dt>
        <dd>A case-insensitive match.</dd>
        <dt>"diacritic-sensitive"</dt>
        <dd>A diacritic-sensitive match.</dd>
        <dt>"diacritic-insensitive"</dt>
        <dd>A diacritic-insensitive match.</dd>
        <dt>"ascending"</dt>
        <dd>Words should be returned in ascending order.</dd>
        <dt>"descending"</dt>
        <dd>Words should be returned in descending order.</dd>
        <dt>"any"</dt>
        <dd>Words from any fragment should be included.</dd>
        <dt>"document"</dt>
        <dd>Words from document fragments should be included.</dd>
        <dt>"properties"</dt>
        <dd>Words from properties fragments should be included.</dd>
        <dt>"locks"</dt>
        <dd>Words from locks fragments should be included.</dd>
        <dt>"collation=<em>URI</em>"</dt>
        <dd>Use the lexicon with the collation specified by <em>URI</em>.</dd>
        <dt>"limit=<em>N</em>"</dt>
        <dd>Return no more than <em>N</em> words.</dd>
        <dt>"sample=<em>N</em>"</dt>
        <dd>Return only words from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"truncate=<em>N</em>"</dt>
        <dd>Include only words from the first <em>N</em> fragments
        selected by the <code>cts:query</code>.
        Only applies when a <code>$query</code> parameter is specified.</dd>
        <dt>"score-logtfidf"</dt>
        <dd>Compute scores using the logtfidf method.</dd>
        <dt>"score-logtf"</dt>
        <dd>Compute scores using the logtf method.</dd>
        <dt>"score-simple"</dt>
        <dd>Compute scores using the simple method.</dd>
        <dt>"score-random"</dt>
        <dd>Compute scores using the random method.</dd>
        <dt>"checked"</dt>
        <dd>Word positions should be checked when resolving the query.</dd>
        <dt>"unchecked"</dt>
        <dd>Word positions should not be checked when resolving the query.</dd>
        <dt>"concurrent"</dt>
        <dd>Perform the work concurrently in another thread. This is a hint 
        to the query optimizer to help parallelize the lexicon work, allowing
        the calling query to continue performing other work while the lexicon 
        processing occurs.  This is especially useful in cases where multiple 
        lexicon calls occur in the same query (for example, resolving many 
        facets in a single query).</dd>
     </dl></blockquote>
  </apidoc:param>
      <apidoc:param name="query" type="cts:query?" optional="true">
    Only include words in fragments selected by the <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code>.
    The words do not need to match the query, but the words must occur
    in fragments selected by the query.
    The fragments are not filtered to ensure they match the query, 
    but instead selected in the same manner as <a href="#unfiltered" xmlns="http://www.w3.org/1999/xhtml">
    "unfiltered" <code>cts:search</code></a> operations.  If a string
   is entered, the string is treated as a <code xmlns="http://www.w3.org/1999/xhtml">cts:word-query</code> of the 
   specified string.
  </apidoc:param>
      <apidoc:param name="quality-weight" type="xs:double?" optional="true">
    A document quality weight to use when computing scores.
    The default is 1.0.
  </apidoc:param>
      <apidoc:param name="forest-ids" type="xs:unsignedLong*" optional="true">
    A sequence of IDs of forests to which the search will be constrained.
    An empty sequence means to search all forests in the database.
    The default is ().
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:string*</apidoc:return>
    <apidoc:usage>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "ascending" or "descending" may be specified 
  in the options parameter.  If neither "ascending" nor "descending" 
  is specified, then the default is "ascending".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of "any", "document", "properties", or "locks" 
  may be specified in the options parameter.
  If none of "any", "document", "properties", or "locks" are specified
  and there is a $query parameter, then the default is "document".
  If there is no $query parameter then the default is "any".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "score-logtfidf", "score-logtf", "score-simple",
  or "score-random" options may be specified in the options parameter. 
  If none of "score-logtfidf", "score-logtf", "score-simple", or 
  "score-random" are specified, then the default is "score-logtfidf".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only one of the "checked" or "unchecked" options may be specified
  in the options parameter. 
  If neither "checked" nor "unchecked" are specified,
  then the default is "checked".</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "collation=<em>URI</em>" is not specified in the options parameter, 
  then the default collation is used. If a lexicon with that collation
  does not exist, an error is thrown.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "sample=<em>N</em>" is not specfied in the options parameter, 
  then all included words may be returned. If a <code>$query</code> parameter
  is not present, then "sample=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">If "truncate=<em>N</em>" is not specfied in the options parameter, 
  then words from all fragments selected by the <code>$query</code> parameter 
  are included.  If a <code>$query</code> parameter is not present, then  
  "truncate=<em>N</em>" has no effect.</p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "case-sensitive" nor "case-insensitive" 
    is present, $pattern is used to determine case sensitivity.
    If $pattern contains no uppercase, it specifies "case-insensitive".
    If $pattern contains uppercase, it specifies "case-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">
    If neither "diacritic-sensitive" nor "diacritic-insensitive" 
    is present, $pattern is used to determine diacritic sensitivity.
    If $pattern contains no diacritics, it specifies "diacritic-insensitive".
    If $pattern contains diacritics, it specifies "diacritic-sensitive".
  </p>
  <p xmlns="http://www.w3.org/1999/xhtml">Only words that can be matched with field-word-query are included.
  That is, only words present in immediate text node children of the 
  specified field as well as any text node children of child fields
  defined in the Admin Interface as field-word-query-throughs or 
  phrase-throughs. </p>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:field-word-match("animal","aardvark*")
  =&gt; ("aardvark","aardvarks")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="reverse-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a query matching the model nodes.  Use with a <code xmlns="http://www.w3.org/1999/xhtml">cts:search</code>
 or a <code xmlns="http://www.w3.org/1999/xhtml">cts:contains</code> over serialized <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> nodes. 
 The serialized <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> nodes can be either stored in the
 database or passed in as XML. 
</apidoc:summary>
    <apidoc:return>cts:reverse-query</apidoc:return>
    <apidoc:params>
      <apidoc:param name="nodes" type="node()*" optional="false">
    Some model nodes that contain serialized <code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> 
    constructors.
  </apidoc:param>
      <apidoc:param name="weight" type="xs:double?" optional="true">
    A weight for this query.
    Higher weights move search results up in the relevance
    order.  The default is 1.0. The 
    weight should be less than or equal to the absolute value of 16 (between 
    -16 and 16); weights greater than 16 will have the same effect as a 
    weight of 16. 
    Weights less than the absolute value of 0.0625 (between -0.0625 and
    0.0625) are rounded to 0, which means that they do not contribute to the 
    score.
  </apidoc:param>
    </apidoc:params>
    <apidoc:usage>
   When performing a <code xmlns="http://www.w3.org/1999/xhtml">cts:reverse-query</code> on a set of nodes, the 
   <code xmlns="http://www.w3.org/1999/xhtml">cts:similar-query</code> or <code xmlns="http://www.w3.org/1999/xhtml">cts:registered-query</code>
   components of any stored query will match all nodes. 
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
let $query := &lt;query&gt;{cts:word-query("hello")}&lt;/query&gt;
let $x := &lt;bar&gt;hello&lt;/bar&gt;
return
cts:contains($query, cts:reverse-query($x))
(: 
   returns true because the cts:word-query for "hello" 
   would match the document in $x
:)

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="reverse-query-nodes" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the nodes used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:reverse-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>node()*</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:reverse-query-nodes($query)
  =&gt; //function
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="reverse-query-weight" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the weight with which the specified query was constructed.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:reverse-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>xs:double</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:similar-query-weight($query)
  =&gt; 1
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="document-fragment-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a query that matches all documents where <code xmlns="http://www.w3.org/1999/xhtml">$query</code> matches
  any document fragment.  When searching documents, document-properties, or 
  document-locks, <code xmlns="http://www.w3.org/1999/xhtml">cts:document-fragment-query</code> provides a 
  convenient way to additionally constrain the search against any document 
  fragment.  
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:query" optional="false">
    A query to be matched against any document fragment.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:document-fragment-query</apidoc:return>
    <apidoc:usage>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:search(
xdmp:document-properties(),
  cts:document-fragment-query(
    cts:word-query("hello")))

=&gt;  All properties documents whose corresponding document
    (that is, the document at the same URI as the 
    proerties document) contain the word "hello".
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="document-fragment-query-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the query used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:document-fragment-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:document-fragment-query-query(cts:document-fragment-query(cts:word-query("word")))
  =&gt; cts:word-query("word")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="properties-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a query that matches all documents where <code xmlns="http://www.w3.org/1999/xhtml">$query</code> matches
  document-properties.  When searching documents or document-locks, 
  <code xmlns="http://www.w3.org/1999/xhtml">cts:properties-query</code> provides a convenient way to 
  additionally constrain the search against document-properties fragments.  
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:query" optional="false">
    A query to be matched against the properties fragment.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:properties-query</apidoc:return>
    <apidoc:usage>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:search(
  fn:collection(),
  cts:properties-query(
    cts:element-range-query(
        xs:QName("prop:last-modified"),"&gt;",
        current-dateTime() - xs:dayTimeDuration("P1D"))))

=&gt; All documents modified up to one day in the past.
    Note that this example requires a dateTime range index on:
    namespace: http://marklogic.com/xdmp/property
    local name: last-modified
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="properties-query-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the query used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:properties-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:properties-query-query(cts:properties-query(cts:word-query("word")))
  =&gt; cts:word-query("word")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="locks-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns a query that matches all documents where <code xmlns="http://www.w3.org/1999/xhtml">$query</code> matches
  document-locks.  When searching documents or document-properties, 
  <code xmlns="http://www.w3.org/1999/xhtml">cts:locks-query</code> provides a convenient way to 
  additionally constrain the search against document-locks fragments.  
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:query" optional="false">
    A query to be matched against the locks fragment.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:locks-query</apidoc:return>
    <apidoc:usage>
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:search(
  fn:collection(),
  cts:locks-query(
    cts:element-range-query(
        xs:QName("prop:last-modified"),"&gt;",
        current-dateTime() - xs:dayTimeDuration("P1D"))))

=&gt; All documents modified up to one day in the past.
    Note that this example requires a dateTime range index on:
    namespace: http://marklogic.com/xdmp/property
    local name: last-modified
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="locks-query-query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Returns the query used to construct the specified query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="cts:locks-query" optional="false">
    A query.
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
  cts:locks-query-query(cts:locks-query(cts:word-query("word")))
  =&gt; cts:word-query("word")
</pre></apidoc:example>
  </apidoc:function><apidoc:function name="query" type="builtin" lib="cts" category="SearchBuiltins" subcategory="cts:query Constructors" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Creates a query.
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="query" type="element()" optional="true">
    A query.</apidoc:param>
    </apidoc:params>
    <apidoc:return>cts:query</apidoc:return>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:query(
  &lt;cts:word-query xmlns:cts="http://marklogic.com/cts"&gt;
    &lt;cts:text&gt;word&lt;/cts:text&gt;
  &lt;/cts:word-query&gt;
)

</pre></apidoc:example>
  </apidoc:function><apidoc:function name="distinctive-terms" type="builtin" lib="cts" category="SearchBuiltins" subcategory="Search" hidden="false" bucket="MarkLogic Built-In Functions">
    <apidoc:summary>
  Return the most "relevant" terms in the model nodes (that is, the 
  terms with the highest scores).
</apidoc:summary>
    <apidoc:params>
      <apidoc:param name="nodes" type="node()*" optional="false">
    Some model nodes.
  </apidoc:param>
      <apidoc:param name="options" type="element()?" optional="true">
    <a id="db-term-options" xmlns="http://www.w3.org/1999/xhtml"></a>
    An XML representation of the options for defining which terms to 
    generate and how to evaluate them.
    The options node must be in the <code xmlns="http://www.w3.org/1999/xhtml">cts:distinctive-terms</code>
    namespace. The following is a sample options node:
    <pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
    &lt;options xmlns="cts:distinctive-terms"&gt;
      &lt;max-terms&gt;20&lt;/max-terms&gt;
    &lt;/options&gt; </pre>
    
    <p xmlns="http://www.w3.org/1999/xhtml">The 
    <code>cts:distinctive-terms</code> options (which are also valid for
    <code>cts:similar-query</code>, <code>cts:train</code>,
    and <code>cts:cluster</code>)
    include:</p>
    <dl xmlns="http://www.w3.org/1999/xhtml">
    <dt><p>&lt;<code>max-terms</code>&gt;</p></dt>
    <dd>An integer defining the maximum number of distinctive terms to list
    in the <code>cts:distinctive-terms</code> output.  The default is 16.
    </dd>
    <dt><p>&lt;<code>min-val</code>&gt;</p></dt>
    <dd>A double specifying the minimum value a term can
    have and still be considered a distinctive term. The default is 0.</dd>
    <dt><p>&lt;<code>min-weight</code>&gt;</p></dt>
    <dd>A number specifying the minimum weighted term frequency a term can
    have and still be considered a distinctive term.  In general this value 
    will be either 0 (include unweighted terms) or 1 (don't include unweighted
    terms). The default is 1.</dd>
    <dt><p>&lt;<code>score</code>&gt;</p></dt>
    <dd>A string defining which scoring method to use in comparing the values
    of the terms.
    The default is <code>logtfidf</code>.  See the description of scoring
    methods in the cts:search function for more details.
    Possible values are:
      <dl>
      <dt><p><code>logtfidf</code></p></dt>
      <dd>Compute scores using the logtfidf method.</dd>
      <dt><p><code>logtf</code></p></dt>
      <dd>Compute scores using the logtf method.</dd>
      <dt><p><code>simple</code></p></dt>
      <dd>Compute scores using the simple method.</dd>
      </dl>
    </dd>
    <dt><p>&lt;<code>use-db-config</code>&gt;</p></dt>
    <dd>A boolean value indicating whether to use the current DB configuration 
    for determining which terms to use.  The default is <code>true</code>.
    Setting the value to <code>false</code> means that the indexing 
    options in the options node will be used, as well as the default value
    for any of the options not specified. This may be used to easily
    target a small set of terms. 
    </dd>
    <dt><p>&lt;<code>complete</code>&gt;</p></dt>
    <dd>A boolean value indicating whether to return terms even if there is no 
    query associated with them.  The default is false.</dd>
    </dl>
    <p xmlns="http://www.w3.org/1999/xhtml">The options element also includes indexing options in the 
    <code>http://marklogic.com/xdmp/database</code> namespace.  
    These control which terms to use. </p>
    <p xmlns="http://www.w3.org/1999/xhtml">These database options include the following (shown here with 
    a <code>db</code> prefix to denote the
    <code>http://marklogic.com/xdmp/database</code> namespace.  The default 
    given below is the default value if <code>use-db-config</code> is set
    to <code>false</code>:
    </p>
    <dl xmlns="http://www.w3.org/1999/xhtml">
    <dt><p>&lt;<code>db:word-searches</code>&gt;</p></dt>
    <dd>Include terms for the words in the node. The default is 'false'.</dd>
    <dt><p>&lt;<code>db:stemmed-searches</code>&gt;</p></dt>
    <dd>Define whether to include terms for the stems in the node, and at 
    what level of stemming: <code>off</code>, <code>basic</code>, 
    <code>advanced</code>, or <code>decompounding</code>. The default is 'basic'.
    </dd>
    <dt><p>&lt;<code>db:fast-case-sensitive-searches</code>&gt;</p></dt>
    <dd>Include terms for case-sensitive variations of the words in the 
    node. The default is 'false'.</dd>
    <dt><p>&lt;<code>db:fast-diacritic-sensitive-searches</code>&gt;</p></dt>
    <dd>Include terms for diacritic-sensitive variations of the words in 
    the node.  The default is 'false'.</dd>
    <dt><p>&lt;<code>db:fast-phrase-searches</code>&gt;</p></dt><dd>Include 
    terms for two-word phrases in the node.  The default is 'true'.</dd>
    <dt><p>&lt;<code>db:phrase-throughs</code>&gt;</p></dt><dd>If phrase 
    terms are included, include terms for phrases that cross the given 
    elements.  The default is to have no such elements.</dd>
    <dt><p>&lt;<code>db:phrase-arounds</code>&gt;</p></dt><dd>If phrase 
    terms are included, include terms for phrases that skip over the 
    given elements.  The default is to have no such elements.</dd>
    <dt><p>&lt;<code>db:fast-element-word-searches</code>&gt;</p></dt>
    <dd>Include terms for words in particular elements.  The default is 'true'.</dd>
    <dt><p>&lt;<code>db:fast-element-phrase-searches</code>&gt;</p></dt>
    <dd>Include terms for phrases in particular elements. The default is 'true'.</dd>
    <dt><p>&lt;<code>db:element-word-query-throughs</code>&gt;</p></dt>
    <dd>Include terms for words in sub-elements of the given elements. The default is to have no such elements.</dd>
    <dt><p>&lt;<code>db:fast-element-character-searches</code>&gt;</p></dt>
    <dd>Include terms for characters in particular elements.  The default is 'false'.</dd>
    <dt><p>&lt;<code>db:range-element-indexes</code>&gt;</p></dt>
    <dd>Include terms for data values in specific elements.  The default is to have no such indexes.</dd>
    <dt><p>&lt;<code>db:range-element-attribute-indexes</code>&gt;</p></dt>
    <dd>Include terms for data values in specific attributes.  The default is to have no such indexes.</dd>
    <dt><p>&lt;<code>db:one-character-searches</code>&gt;</p></dt>
    <dd>Include terms for single character.  The default is 'false'.</dd>
    <dt><p>&lt;<code>db:two-character-searches</code>&gt;</p></dt>
    <dd>Include terms for two-character sequences. The default is 'false'.</dd>
    <dt><p>&lt;<code>db:three-character-searches</code>&gt;</p></dt>
    <dd>Include terms three-character sequences.  The default is 'false'.</dd>
    <dt><p>&lt;<code>db:trailing-wildcard-searches</code>&gt;</p></dt>
    <dd>Include terms for trailing wildcards. The default is 'false'.</dd>
    <dt><p>&lt;<code>db:fast-element-trailing-wildcard-searches</code>&gt;
    </p></dt>
    <dd>If trailing wildcard terms are included, include terms for 
    trailing wildcards by element.  The default is 'false'.</dd>
    <dt><p>&lt;<code>db:fields</code>&gt;</p></dt>
    <dd>Include terms for the defined fields.  The default is to have no fields.</dd>
    </dl>
  </apidoc:param>
    </apidoc:params>
    <apidoc:return>element(cts:class)</apidoc:return>
    <apidoc:usage>
<a id="output_format" xmlns="http://www.w3.org/1999/xhtml"><b>Output Format</b></a>
The output of the function is a <code xmlns="http://www.w3.org/1999/xhtml">cts:class</code> element containing a 
sequence of <code xmlns="http://www.w3.org/1999/xhtml">cts:term</code> elements.  (This is the same as the weights
form of a class for the SVM classifier; see cts:train.) Each 
<code xmlns="http://www.w3.org/1999/xhtml">cts:term</code> element identifies the term ID as well as a score, 
confidence, and fitness measure for the term, in addition to a 
<code xmlns="http://www.w3.org/1999/xhtml">cts:query</code> that corresponds to the term.  The correspondence of 
terms to queries is not precise: queries typically make use of multiple 
terms, and not all terms correspond to a query. However, a search using the 
query given for a term will match the model node that gave rise to it.
</apidoc:usage>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:distinctive-terms( fn:doc("book.xml"), 
   &lt;options xmlns="cts:distinctive-terms"&gt;&lt;max-terms&gt;3&lt;/max-terms&gt;&lt;/options&gt; ) 
== &gt;
&lt;cts:class name="dterms book.xml" offset="0" xmlns:cts="http://marklogic.com/cts"&gt;
  &lt;cts:term id="1230725848944963443" val="482" score="372" confidence="0.686441" fitness="0.781011"&gt;
    &lt;cts:element-word-query&gt;
      &lt;cts:element&gt;title&lt;/cts:element&gt;
      &lt;cts:text xml:lang="en"&gt;the&lt;/cts:text&gt;
      &lt;cts:option&gt;case-insensitive&lt;/cts:option&gt;
      &lt;cts:option&gt;diacritic-insensitive&lt;/cts:option&gt;
      &lt;cts:option&gt;stemmed&lt;/cts:option&gt;
      &lt;cts:option&gt;unwildcarded&lt;/cts:option&gt;
    &lt;/cts:element-word-query&gt;
  &lt;/cts:term&gt;
  &lt;cts:term id="2859044029148442125" val="435" socre="662" confidence="0.922555" fitness="0.971371"&gt;
    &lt;cts:word-query&gt;
      &lt;cts:text xml:lang="en"&gt;text&lt;/cts:text&gt;
      &lt;cts:option&gt;case-insensitive&lt;/cts:option&gt;
      &lt;cts:option&gt;diacritic-insensitive&lt;/cts:option&gt;
      &lt;cts:option&gt;stemmed&lt;/cts:option&gt;
      &lt;cts:option&gt;unwildcarded&lt;/cts:option&gt;
    &lt;/cts:word-query&gt;
  &lt;/cts:term&gt;
  &lt;cts:term id="17835615465481541363" val="221" score="237" confidence="0.65647" fitness="0.781263"&gt;
    &lt;cts:word-query&gt;
      &lt;cts:text xml:lang="en"&gt;of&lt;/cts:text&gt;
      &lt;cts:option&gt;case-insensitive&lt;/cts:option&gt;
      &lt;cts:option&gt;diacritic-insensitive&lt;/cts:option&gt;
      &lt;cts:option&gt;stemmed&lt;/cts:option&gt;
      &lt;cts:option&gt;unwildcarded&lt;/cts:option&gt;
    &lt;/cts:word-query&gt;
  &lt;/cts:term&gt;
&lt;/cts:class&gt;
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:distinctive-terms(//title,
    &lt;options xmlns="cts:distinctive-terms"&gt;
      &lt;use-db-config&gt;true&lt;/use-db-config&gt;
    &lt;/options&gt;)

=&gt; a cts:class element contianing the 16 most distinctive query terms
</pre></apidoc:example>
    <apidoc:example><pre xml:space="preserve" xmlns="http://www.w3.org/1999/xhtml">
cts:distinctive-terms(&lt;foo&gt;hello there you&lt;/foo&gt;,
    &lt;options xmlns="cts:distinctive-terms"
             xmlns:db="http://marklogic.com/xdmp/database"&gt;
            &lt;db:word-positions&gt;true&lt;/db:word-positions&gt;
    &lt;/options&gt;)

=&gt; a cts:class element contianing the 16 most distinctive query terms
</pre></apidoc:example>
  </apidoc:function></apidoc:module>