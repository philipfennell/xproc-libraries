<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="dialects.css" type="text/css" charset="UTF-8"?>
<XML>
<TITLE> </TITLE><Heading-1>
<A ID="pgfId-1043259"></A>
<A ID="_Toc61258621"></A>
XQuery Dialects in MarkLogic Server</Heading-1>
<pagenum>
<A ID="pgfId-1050164"></A>
13</pagenum>
<Body>
<A ID="pgfId-1050165"></A>
The XQuery specification is a formal recommendation from the W3C XQuery Working Group. MarkLogic Server 4.0 implements the W3C XQuery 1.0 Recommendation (<Hyperlink>
http://www.w3.org/TR/xquery/</Hyperlink>
). To maximize compatibility with MarkLogic Server 3.2 and to offer strict XQuery compliance to those who desire it, as well as to include extensions to the language to make it easier to build applications, MarkLogic Server supports three dialects of XQuery. This chapter describes these dialects, and includes the following sections:</Body>
<Body-bullet>
<A ID="pgfId-1050199"></A>
<A href="dialects.xml#id(_Toc61258622)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Overview of the XQuery Dialects</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1050203"></A>
<A href="dialects.xml#id(_Toc61258623)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Rules For Combining the Dialects</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054109"></A>
<A href="dialects.xml#id(_Toc61258624)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Specifying the XQuery Dialect in the Prolog</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1050204"></A>
<A href="dialects.xml#id(56854)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Strategies For Migrating Code to Enhanced Dialect</Hyperlink>
</A></Body-bullet>
<Heading-2>
<A ID="pgfId-1050167"></A>
<A ID="_Toc61258622"></A>
Overview of the XQuery Dialects</Heading-2>
<Body>
<A ID="pgfId-1043263"></A>
MarkLogic Server supports three dialects separate dialects of XQuery:</Body>
<Body-bullet>
<A ID="pgfId-1050208"></A>
<A href="dialects.xml#id(63368)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
MarkLogic Server Enhanced (XQuery 1.0-ml)</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1050212"></A>
<A href="dialects.xml#id(65735)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
MarkLogic Server 3.2 Compatibility (XQuery 0.9-ml)</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1050213"></A>
<A href="dialects.xml#id(30393)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Strict (XQuery 1.0)</Hyperlink>
</A></Body-bullet>
<Body>
<A ID="pgfId-1053855"></A>
You can use library modules from different dialects together, as described in <A href="dialects.xml#id(_Toc61258623)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Rules For Combining the Dialects' on page&#160;8</A>. Each dialect has a different set of pre-defined namespaces, as described in <A href="namespaces.xml#id(21104)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Predefined Namespace Prefixes for Each Dialect' on page&#160;52</A>.</Body>
<Heading-3>
<A ID="pgfId-1050214"></A>
<A ID="63368"></A>
MarkLogic Server Enhanced (XQuery 1.0-ml)</Heading-3>
<Body>
<A ID="pgfId-1050221"></A>
For a module to use the MarkLogic Server enhanced dialect, use the following for the XQuery version declaration on the first line of the XQuery module:</Body>
<Code>
<A ID="pgfId-1053734"></A>
xquery version &quot;1.0-ml&quot;;</Code>
<Body>
<A ID="pgfId-1053817"></A>
Note the semi-colon at the end of the declaration, which is required in <code>
1.0-ml</code>
. The enhanced dialect has the XQuery 1.0 syntax and also includes various extensions to the language such as <code>
try</code>
/<code>
catch</code>
. This dialect is the default for new App Servers, and should be considered the preferred dialect for new applications. For more details on the enhanced <code>
1.0-ml</code>
 dialect, see <A href="enhanced.xml#id(_Toc61258626)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'MarkLogic Server Enhanced XQuery Language' on page&#160;14</A>. </Body>
<Heading-3>
<A ID="pgfId-1050222"></A>
<A ID="65735"></A>
MarkLogic Server 3.2 Compatibility (XQuery 0.9-ml)</Heading-3>
<Body>
<A ID="pgfId-1053749"></A>
For a module to use the MarkLogic Server 3.2 compatibility dialect, use the following for the XQuery version declaration on the first line of the XQuery module:</Body>
<Code>
<A ID="pgfId-1053750"></A>
xquery version &quot;0.9-ml&quot;</Code>
<Body>
<A ID="pgfId-1054467"></A>
Note there is no semi-colon at the end of the declaration for <code>
0.9-ml</code>
. The 3.2 compatibility dialect allows you to write code that you can use with both 3.2 and 4.0. Any code you have from 3.2 releases is equivalent to <code>
0.9-ml</code>
. To use that code in 4.0, the best practice is to add the <code>
0.9-ml</code>
 XQuery declaration (shown above) as the first line of each XQuery module.</Body>
<Heading-3>
<A ID="pgfId-1050234"></A>
<A ID="30393"></A>
Strict (XQuery 1.0)</Heading-3>
<Body>
<A ID="pgfId-1053763"></A>
For a module to use the MarkLogic Server strict dialect, use the following for the XQuery version declaration on the first line of the XQuery module:</Body>
<Code>
<A ID="pgfId-1053764"></A>
xquery version &quot;1.0&quot;;</Code>
<Body>
<A ID="pgfId-1053838"></A>
Note the semi-colon at the end of the declaration, which is required in <code>
1.0</code>
. The strict mode is for compatibility with other XQuery 1.0 processors; if you write a library in <code>
1.0</code>
, you can use it with MarkLogic Server and you can also use it with other conforming processors. Similarly, you can use modules that are written in standard XQuery with MarkLogic Server. </Body>
<Body>
<A ID="pgfId-1054647"></A>
To use the MarkLogic Server built-in functions in <code>
1.0</code>
, you must bind a prefix (for example, <code>
xdmp</code>
) to the namespace for the MarkLogic Server functions; there is no need to import a library for these built-in functions, but you do need to bind the namespace to a prefix. To use the <code>
xdmp</code>
 functions in <code>
1.0</code>
, add prolog entries for the namespace bindings you are using in your query, as in the following example:</Body>
<Code>
<A ID="pgfId-1054246"></A>
xquery version &quot;1.0&quot;;
declare namespace xdmp = &quot;http://marklogic.com/xdmp&quot;;

xdmp:version()</Code>
<Heading-2>
<A ID="pgfId-1050413"></A>
<A ID="_Toc61258623"></A>
Rules For Combining the Dialects</Heading-2>
<Body>
<A ID="pgfId-1050414"></A>
MarkLogic Server has a very flexible way of combining the three XQuery dialects. You can import a library module written in any of the three dialects into any main or library module. For example, you might find an open source standards-compliant module that you found on the internet which is written in the strict XQuery&#160;1.0 dialect. You can then import this module into any MarkLogic Server XQuery program, regardless of dialect, and then use those functions in your code.</Body>
<Body>
<A ID="pgfId-1053801"></A>
When writing modules of different dialects, the best practice is to always use the XQuery version declaration as the first line, indicating which dialect the module is written in. That way, if the module is written in a different dialect than the default dialect for the App Server or the program, it will still work correctly (for details, see <A href="dialects.xml#id(45272)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Inheriting the Default XQuery Version From the App Server' on page&#160;11</A>). </Body>
<Heading-2>
<A ID="pgfId-1043265"></A>
<A ID="56854"></A>
Strategies For Migrating Code to Enhanced Dialect</Heading-2>
<Body>
<A ID="pgfId-1050335"></A>
If you are writing new XQuery code, the best practice is to use the <code>
1.0-ml</code>
 dialect. If you are updating code that was written in previous versions of MarkLogic Server, you can consider if you want to migrate that code to <code>
1.0-ml</code>
. This section describes things to think about when migrating your application code and includes the following parts:</Body>
<Body-bullet>
<A ID="pgfId-1053867"></A>
<A href="dialects.xml#id(90028)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
When To Migrate XQuery Code</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1053875"></A>
<A href="dialects.xml#id(46540)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
XQuery Changes From Previous MarkLogic Server Releases</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1053884"></A>
<A href="dialects.xml#id(45272)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Inheriting the Default XQuery Version From the App Server</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054040"></A>
<A href="dialects.xml#id(94986)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Porting 3.2 (0.9-ml) XQuery Code to Enhanced (1.0-ml)</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1050336"></A>
<A ID="90028"></A>
When To Migrate XQuery Code</Heading-3>
<Body>
<A ID="pgfId-1050340"></A>
Because of the flexibility of how you can interoperably use the various XQuery dialects, it is really up to you when and how you migrate your XQuery code. The differences between the dialects are mostly syntax changes in the prolog, but there are also some other differences that might cause subtle changes in behavior. For details on the differences between the XQuery dialects in 3.2 (<code>
0.9-ml</code>
) and 4.0 (<code>
1.0-ml</code>
), see <A href="dialects.xml#id(46540)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'XQuery Changes From Previous MarkLogic Server Releases' on page&#160;10</A>. When you decide to migrate XQuery code to <code>
1.0-ml</code>
 (or to <code>
1.0</code>
), there are several ways you can go about it:</Body>
<Body-bullet>
<A ID="pgfId-1053905"></A>
Migrate an entire application all at once. This method gets everything over with at once, and therefore focuses the effort. If you have a relatively small amount of code to migrate, it might make sense to just go ahead and migrate it all at once.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1053909"></A>
Migrate one module at a time. This method allows you to spread the migration work over a number of small tasks instead of one large task, and further allows you to test each module independently after migration. This technique is very flexible, as you can do a little bit at a time. A good first step for this one-by-one approach is to start by adding an XQuery <code>
0.9-ml</code>
 declaration to the first line of each XQuery file. Then, as you migrate a module, you can change the declaration to <code>
1.0-ml</code>
 and make any needed syntax changes to that module.</Body-bullet>
<Heading-3>
<A ID="pgfId-1050375"></A>
<A ID="46540"></A>
XQuery Changes From Previous MarkLogic Server Releases</Heading-3>
<Body>
<A ID="pgfId-1050379"></A>
While MarkLogic Server 4.0 includes a compatibility dialect to run your 3.2 code without changes (<code>
0.9-ml</code>
), the new enhanced mode offers several important improvements, so it is a good idea to migrate your code to the enhanced dialect (<code>
1.0-ml</code>
). Because you can mix modules in the old dialect with modules in the new, you can perform your migration one module at a time. This section highlights the major syntax and semantic changes between the XQuery used in MarkLogic Server 3.2 (<code>
0.9-ml</code>
) and MarkLogic Server 4.0 enhanced XQuery dialect (<code>
1.0-ml</code>
). Additionally, see the 'Known Incompatibilities' section of the <Emphasis>
Release Notes</Emphasis>
. The changes include:</Body>
<Body-bullet>
<A ID="pgfId-1050386"></A>
Semi-colons ( ; ) are now required at the end of each prolog declaration.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1050387"></A>
Prolog declarations that previously used <code>
define</code>
 now use <code>
declare</code>
. </Body-bullet>
<Body-bullet>
<A ID="pgfId-1050388"></A>
Variable declaration syntax is slightly different, and now uses the <code>
:=</code>
 syntax (for details and an example, see <A href="langoverview.xml#id(52597)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Declaring Variables' on page&#160;30</A>).</Body-bullet>
<Body-bullet>
<A ID="pgfId-1053709"></A>
Library module declarations now require the <code>
namespace</code>
 keyword and a prefix for the namespace, for example:</Body-bullet>
<Code>
<A ID="pgfId-1053715"></A>
module namespace my = &quot;my-namespace&quot;;</Code>
<Body-bullet>
<A ID="pgfId-1053722"></A>
Function declarations that return the empty sequence now require the empty sequence to be specified as follows:</Body-bullet>
<Code>
<A ID="pgfId-1054434"></A>
empty-sequence()</Code>
<Body-indent>
<A ID="pgfId-1054435"></A>
In <code>
0.9-ml</code>
, you specify <code>
empty()</code>
 for the empty sequence.</Body-indent>
<Body-bullet>
<A ID="pgfId-1054436"></A>
Some of the effective boolean value rules have changed. Notably, the following returns true in <code>
0.9-ml</code>
 and returns false in <code>
1.0-ml</code>
 (and throws an exception in <code>
1.0</code>
):</Body-bullet>
<Code>
<A ID="pgfId-1054045"></A>
(: returns true in 0.9-ml, false in 1.0-ml, and
&#160;&#160;&#160;throws XDMP-EFFBOOLVALUE in 1.0 :)
fn:boolean((fn:false(), fn:false()))</Code>
<Body-indent>
<A ID="pgfId-1054393"></A>
This change might affect applications that have <code>
if/then/else</code>
 statements where the <code>
if</code>
 test returns a sequence of boolean values. In these cases, you might see the <code>
if</code>
 statement evaluating to <code>
false</code>
 in cases where it previously evaluated to <code>
true</code>
, causing the <code>
else</code>
 statement to be evaluated intead of the <code>
then</code>
 statement.</Body-indent>
<Body-bullet>
<A ID="pgfId-1053723"></A>
The namespace used for durations now uses the <code>
xs</code>
 namespace prefix; previously it was the <code>
xdt</code>
 prefix. Any code you have that uses the <code>
xdt</code>
 namespace prefix will require a change to the <code>
xs</code>
 prefix. For example, if you have code that uses <code>
xdt:dayTimeDuration</code>
, you should change that to <code>
xs:dayTimeDuration</code>
.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054185"></A>
<code>
element()</code>
 tests in <code>
0.9-ml</code>
 are equivalent to <code>
schema-element()</code>
 test in <code>
1.0</code>
 and <code>
1.0-ml</code>
. Any code you have with <code>
element()</code>
 tests might not match some elements that previously matched. For example, substitution elements previously would match the base element name, but will now only match with <code>
schema-element()</code>
 test in <code>
1.0</code>
 and <code>
1.0-ml</code>
. For more information, see <Hyperlink>
element() Test in 0.9-ml Equivalent to schema-element() Test in 1.0-ml</Hyperlink>
 in the 4.0 <Emphasis>
Release Notes</Emphasis>
.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054296"></A>
Some changes to the XQuery standard functions. For example, there are subtle changes to <code>
fn:avg</code>
 and <code>
fn:sum</code>
, <code>
fn:error</code>
 has a different signature, and <code>
fn:node-kind</code>
 does not exist in 1.0 and 1.0-ml (it is replaced by <code>
xdmp:node-kind</code>
).</Body-bullet>
<Heading-3>
<A ID="pgfId-1054026"></A>
<A ID="45272"></A>
Inheriting the Default XQuery Version From the App Server</Heading-3>
<Body>
<A ID="pgfId-1054027"></A>
Each App Server has a setting for the default XQuery version. Any requests against that App Server that do not have explicitly specify an XQuery version declaration are treated as the default XQuery version value. Because of the way a request inherits it default XQuery version from the App Server environment, requests without an explicit declaration can be treated differently by different App Servers (if the App Servers have different default XQuery values). Therefore, it is best practice to specify the XQuery version in each module.</Body>
<Body>
<A ID="pgfId-1054451"></A>
The task server does not allow you to specify a default XQuery version, and if there is no explicit version declaration in the XQuery code evaluated on the task server, it defaults to <code>
1.0-ml</code>
. This makes it especially important to use XQuery version declarations in modules used by CPF or modules called from triggers. For details on CPF, see <Emphasis>
Content Processing Framework Guide</Emphasis>
.</Body>
<Body>
<A ID="pgfId-1054563"></A>
To ensure your code is always evaluated in the dialect in which you have written it, regardless of the context in which it is run, the best practice is to begin each XQuery module with a XQuery version declaration. For the syntax of the version declaration, see <A href="langoverview.xml#id(95538)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'XQuery Version Declaration' on page&#160;25</A>.</Body>
<Heading-2>
<A ID="pgfId-1054095"></A>
<A ID="_Toc61258624"></A>
Specifying the XQuery Dialect in the Prolog</Heading-2>
<Body>
<A ID="pgfId-1054096"></A>
You specify the dialect for an XQuery module with a version declaration. The version declaration is optional, and comes before the prolog in an XQuery module. It is best practice to put the XQuery version declaration in your code as the first line in the module, as having it there ensures it will work as expected in any environment. For example, to specify <code>
1.0-ml</code>
 as the XQuery version, begin your XQuery module with the following:</Body>
<Code>
<A ID="pgfId-1054575"></A>
xquery version &quot;1.0-ml&quot;;</Code>
<Heading-3>
<A ID="pgfId-1050402"></A>
<A ID="94986"></A>
Porting 3.2 (0.9-ml) XQuery Code to Enhanced (1.0-ml)</Heading-3>
<Body>
<A ID="pgfId-1050406"></A>
In most cases, porting any XQuery code used in 3.2 to the <code>
1.0-ml</code>
 dialect will be easy and straightforward. The bulk of the differences are syntax changes in the prolog. As stated earlier, you do not need to port all of your code at one time. A sensible approach is to migrate your code one XQuery module at a time. This section outlines the basic steps you should follow when migrating your XQuery code. </Body>
<Body>
<A ID="pgfId-1054015"></A>
The following are some basic steps to take when migrating 3.2 XQuery code (<code>
0.9-ml</code>
) to 4.0&#160;(<code>
1.0-ml</code>
):</Body>
<Number1>
<A ID="pgfId-1053968"></A>
Add XQuery version declarations to all of your existing modules. For code written in 3.2, the declarations will be as follows:</Number1>
<Code>
<A ID="pgfId-1053977"></A>
xquery version &quot;0.9-ml&quot;</Code>
<NumberList>
<Number>
<A ID="pgfId-1053978"></A>
Review the <Emphasis>
Release Notes</Emphasis>
 for any incompatibilities.</Number>
<Number>
<A ID="pgfId-1054582"></A>
For each module you migrate, change the version number string in the XQuery version declaration to <code>
1.0-ml</code>
 and add a semi-colon to the line so it looks as follows</Number>
</NumberList>
<Code>
<A ID="pgfId-1053985"></A>
xquery version &quot;1.0-ml&quot;;</Code>
<NumberList>
<Number>
<A ID="pgfId-1053986"></A>
Change all of the prolog declarations to the 1.0 syntax (change <code>
define</code>
 to <code>
declare</code>
, add semi-colons, and so on, as described in <A href="dialects.xml#id(46540)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'XQuery Changes From Previous MarkLogic Server Releases' on page&#160;10</A>). For the prolog syntax, see <A href="langoverview.xml#id(48211)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'XQuery Prolog' on page&#160;27</A>, the W3C specification (<Hyperlink>
<A href="http://www.w3.org/TR/xquery/#id-grammar" xml:link="simple" show="replace" actuate="user" CLASS="URL">http://www.w3.org/TR/xquery/#id-grammar</A></Hyperlink>
), or a third-party XQuery book.</Number>
<Number>
<A ID="pgfId-1054006"></A>
If you are modifying a main module and it has function declarations that are used in the same module, they must be declared in a namespace. The preferred way to put functions local to a main module is to prefix those functions definitions and function calls with the <code>
local:</code>
 prefix, which is predefined.</Number>
<Number>
<A ID="pgfId-1054204"></A>
If you have any durations that use the <code>
xdt</code>
 namespace prefix, change the prefix to <code>
xs</code>
 (for example, change <code>
xdt:dayTimeDuration </code>
to <code>
xs:dayTimeDuration</code>
).</Number>
<Number>
<A ID="pgfId-1054116"></A>
If you are modifying a library module, all XQuery standard functions need to be prefixed with the <code>
fn</code>
 namespace prefix. Alternately, you can declare the XQuery functions namespace as the default function namespace in the prolog as follows:</Number>
</NumberList>
<Code>
<A ID="pgfId-1054122"></A>
declare default function namespace
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&quot;http://www.w3.org/2005/xpath-functions&quot;; </Code>
<Body-indent>
<A ID="pgfId-1054135"></A>
If you do declare the default function namespace, then you will also need to prefix your own function definitions with the prefix defined in your module definition. Note that you can no longer use the XPath functions namespace as the library module namespace.</Body-indent>
<NumberList>
<Number>
<A ID="pgfId-1054010"></A>
If you are modifying a library module that is defined with the <code>
fn</code>
 namespace URI, you must change the namespace URI of that module; you cannot use the URI bound to the <code>
fn</code>
 namespace prefix as the URI for a library module in <code>
1.0</code>
 or <code>
1.0-ml</code>
. If you do change the namespace URI of a library module, you must also change the URI in any <code>
import module</code>
 statements in other modules that call the library.</Number>
<Number>
<A ID="pgfId-1054142"></A>
Test the module and correct any syntax errors that occur. </Number>
<Number>
<A ID="pgfId-1054072"></A>
After getting the module to run, test your code to make sure it behaves as it did before. Pay particular attention to parts of your code that might rely on boolean values that take boolean values of sequences, as those behave differently in <code>
0.9-ml</code>
 and <code>
1.0-ml</code>
 (see <A href="dialects.xml#id(46540)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'XQuery Changes From Previous MarkLogic Server Releases' on page&#160;10</A>). Check for any changes due to function mapping, which is described in <A href="enhanced.xml#id(55459)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Function Mapping' on page&#160;15</A>. </Number>
<Number>
<A ID="pgfId-1054089"></A>
Repeat this process for other modules you want to migrate.</Number>
</NumberList>
</XML>
