<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="xslt.css" type="text/css" charset="UTF-8"?>
<XML>
<TITLE> </TITLE><Heading-1>
<A ID="pgfId-1043259"></A>
<A ID="74932"></A>
XSLT in MarkLogic Server</Heading-1>
<pagenum>
<A ID="pgfId-1054143"></A>
<A ID="_Exploring_the_Use"></A>
63</pagenum>
<Body>
<A ID="pgfId-1043261"></A>
In MarkLogic Server, you have both the XQuery and XSLT languages available. You can use one or both of these languages as needed. This chapter briefly describes some of the XSLT language features and describes how to run XSLT in MarkLogic Server, and includes the following sections:</Body>
<Body-bullet>
<A ID="pgfId-1058412"></A>
<A href="xslt.xml#id(93788)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
XSLT 2.0</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1058915"></A>
<A href="xslt.xml#id(19423)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Invoking and Evaluating XSLT Stylesheets</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1063470"></A>
<A href="xslt.xml#id(32459)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
MarkLogic Server Extensions to XSLT</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1065277"></A>
<A href="xslt.xml#id(70125)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Invoking Stylesheets Directly Using the XSLT Rewriter</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1063481"></A>
<A href="xslt.xml#id(49592)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
XSLT, XQuery, or Both</Hyperlink>
</A></Body-bullet>
<Heading-2>
<A ID="pgfId-1059047"></A>
<A ID="93788"></A>
XSLT 2.0</Heading-2>
<Body>
<A ID="pgfId-1063210"></A>
MarkLogic Server implements the W3C XSLT 2.0 recommendation. XSLT 2.0 includes compatibility mode for 1.0 stylesheets. XSLT is a programming languages designed to make it easy to transform XML.</Body>
<Body>
<A ID="pgfId-1063236"></A>
For details about the XSLT 2.0 recommendation, see the W3C website:</Body>
<Body-bullet>
<A ID="pgfId-1063247"></A>
<Hyperlink>
<A href="http://www.w3.org/TR/xslt20/" xml:link="simple" show="replace" actuate="user" CLASS="URL">http://www.w3.org/TR/xslt20/</A></Hyperlink>
</Body-bullet>
<Body>
<A ID="pgfId-1064088"></A>
An XSLT stylesheet is an XML document. Each element is an instruction in the XSLT language. For a summary of the syntax of the various elements in an XSLT stylesheet, see <Hyperlink>
<A href="http://www.w3.org/TR/xslt#element-syntax-summary" xml:link="simple" show="replace" actuate="user" CLASS="URL">http://www.w3.org/TR/xslt#element-syntax-summary</A></Hyperlink>
.</Body>
<Heading-2>
<A ID="pgfId-1063203"></A>
<A ID="19423"></A>
Invoking and Evaluating XSLT Stylesheets</Heading-2>
<Body>
<A ID="pgfId-1059048"></A>
To run an XSLT stylesheet in MarkLogic Server, you run one of the following functions from an XQuery context:</Body>
<Body-bullet>
<A ID="pgfId-1063280"></A>
<code>
xdmp:xslt-invoke</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1063297"></A>
<code>
xdmp:xslt-eval</code>
</Body-bullet>
<Body>
<A ID="pgfId-1063287"></A>
The <code>
xdmp:xslt-invoke</code>
 function invokes an XSLT stylesheet from the App Server root, and the <code>
xdmp:xslt-eval</code>
 function takes a stylesheet as an element and evaluates it as an XSLT stylesheet. As part of running a stylesheet, you pass the stylesheet a node to operate on. For details on <code>
xdmp:xslt-invoke</code>
 and <code>
xdmp:xslt-eval</code>
, see the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
.</Body>
<Heading-2>
<A ID="pgfId-1063310"></A>
<A ID="32459"></A>
MarkLogic Server Extensions to XSLT</Heading-2>
<Body>
<A ID="pgfId-1063351"></A>
Besides the ability to invoke and evaluate XSLT stylesheets from an XQuery context (as described in <A href="xslt.xml#id(19423)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Invoking and Evaluating XSLT Stylesheets' on page&#160;57</A>), there are several extensions to XSLT available in MarkLogic Server. This section describes those extensions and includes the following parts:</Body>
<Body-bullet>
<A ID="pgfId-1063365"></A>
<A href="xslt.xml#id(87607)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Calling Built-In XQuery Functions in a Stylesheet</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1063389"></A>
<A href="xslt.xml#id(60484)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Importing XQuery Function Libraries to a Stylesheet</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1063504"></A>
<A href="xslt.xml#id(79069)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Try/Catch XSLT Instruction</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1064141"></A>
<A href="xslt.xml#id(74932)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
EXSLT Extensions</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1065107"></A>
<A href="xslt.xml#id(95467)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Notes on Importing Stylesheets With &lt;xsl:import&gt;</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1063379"></A>
<A ID="87607"></A>
Calling Built-In XQuery Functions in a Stylesheet</Heading-3>
<Body>
<A ID="pgfId-1063416"></A>
You can call any of the MarkLogic Server Built-In XQuery functions from an XSLT stylesheet.</Body>
<Heading-3>
<A ID="pgfId-1063409"></A>
<A ID="60484"></A>
Importing XQuery Function Libraries to a Stylesheet</Heading-3>
<Body>
<A ID="pgfId-1063402"></A>
In addition to using <code>
&lt;xsl:import&gt;</code>
 to import other XSLT stylesheets into your stylesheet, you can use the <code>
&lt;xdmp:import-module&gt;</code>
 instruction to import an XQuery library module to an XSLT stylesheet. Once you have imported the module, any functions defined in the module are available to that stylesheet. When using the <code>
&lt;xdmp:import-module&gt;</code>
 instruction, you must specify <code>
xdmp</code>
 as a value of the <code>
extension-element-prefixes</code>
 attribute on the <code>
&lt;xsl:stylesheet&gt;</code>
 instruction and you also must bind the <code>
xdmp</code>
 prefix to its namespace in the stylesheet XML.</Body>
<Body>
<A ID="pgfId-1063611"></A>
The following is an example of an <code>
&lt;xdmp:import-module&gt;</code>
 instruction:</Body>
<Code>
<A ID="pgfId-1063892"></A>
xquery version &quot;1.0-ml&quot;;

xdmp:xslt-eval(
&lt;xsl:stylesheet xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;
       xmlns:xdmp=&quot;http://marklogic.com/xdmp&quot;
       xmlns:search=&quot;http://marklogic.com/appservices/search&quot;
       extension-element-prefixes=&quot;xdmp&quot;
       version=&quot;2.0&quot;&gt;     
     &lt;xdmp:import-module 
           namespace=&quot;http://marklogic.com/appservices/search&quot;
           href=&quot;/MarkLogic/appservices/search/search.xqy&quot;/&gt;
     &lt;xsl:template match=&quot;/&quot;&gt;
     &lt;xsl:copy-of select=&quot;search:search('hello')&quot;/&gt;
     &lt;/xsl:template&gt;
   &lt;/xsl:stylesheet&gt;
,
document{ &lt;doc/&gt; })</Code>
<Body>
<A ID="pgfId-1065085"></A>
Similarly, you can import an XSLT sytlesheet into an XQuery library, as described in <A href="xslt.xml#id(60484)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Importing XQuery Function Libraries to a Stylesheet' on page&#160;58</A>.</Body>
<Heading-3>
<A ID="pgfId-1063515"></A>
<A ID="79069"></A>
Try/Catch XSLT Instruction</Heading-3>
<Body>
<A ID="pgfId-1064028"></A>
You can use the <code>
&lt;xdmp:try&gt;</code>
 instruction to create a try/catch expression in XSLT. When using the <code>
&lt;xdmp:try&gt;</code>
 instruction, you must specify <code>
xdmp</code>
 as a value of the <code>
extension-element-prefixes</code>
 attribute on the <code>
&lt;xsl:stylesheet&gt;</code>
 instruction and you also must bind the <code>
xdmp</code>
 prefix to its namespace in the stylesheet XML.</Body>
<Body>
<A ID="pgfId-1063630"></A>
The following is an example of a try/catch in XSLT. This example returns the error XML, which is bound to the variable named <code>
e</code>
 in the name attribute of the <code>
&lt;xdmp:catch&gt;</code>
 instruction.</Body>
<Code>
<A ID="pgfId-1063846"></A>
xquery version &quot;1.0-ml&quot;;

xdmp:xslt-eval(
&lt;xsl:stylesheet xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;
                   xmlns:xdmp=&quot;http://marklogic.com/xdmp&quot;
                   extension-element-prefixes=&quot;xdmp&quot;
                   version=&quot;2.0&quot;&gt;
     &lt;xsl:template match=&quot;/&quot;&gt;
     &lt;xdmp:try&gt;
     &lt;xsl:value-of select=&quot;error(xs:QName('MY-ERROR'), 
                                 'This is an error')&quot;/&gt;
     &lt;xdmp:catch name=&quot;e&quot;&gt;
           &lt;xsl:copy-of select=&quot;$e&quot;/&gt;
     &lt;/xdmp:catch&gt;
     &lt;/xdmp:try&gt;
     &lt;/xsl:template&gt;
   &lt;/xsl:stylesheet&gt;
,
document{&lt;doc&gt;hello&lt;/doc&gt;})</Code>
<Heading-3>
<A ID="pgfId-1064152"></A>
<A ID="74932"></A>
EXSLT Extensions</Heading-3>
<Body>
<A ID="pgfId-1064203"></A>
MarkLogic Server includes many of the EXSLT extensions (<Hyperlink>
<A href="http://www.exslt.org/" xml:link="simple" show="replace" actuate="user" CLASS="URL">http://www.exslt.org/</A></Hyperlink>
). The extensions include the <code>
exslt:node-set</code>
 and <code>
exslt:object-type</code>
 functions and the <code>
exsl:document</code>
 instruction. For details about the functions, see the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
 and the EXSLT web site.</Body>
<Body>
<A ID="pgfId-1064335"></A>
The following is an example of the <code>
exsl:document</code>
 instruction. Note that this is essentially the same as the <code>
xsl:result-document</code>
 instruction, which is part of XSLT 2.0.</Body>
<Code>
<A ID="pgfId-1064717"></A>
xquery version &quot;1.0-ml&quot;;
(: Assumes this is run from a file called c:/mypath/exsl.xqy :)
xdmp:set-response-content-type(&quot;text/html&quot;),
let $nodes := xdmp:xslt-eval(
&lt;xsl:stylesheet  xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;
                   xmlns:exsl=&quot;http://exslt.org/common&quot;
                   extension-element-prefixes=&quot;exsl&quot;
                   xmlns:xdmp=&quot;http://marklogic.com/xdmp&quot;
                   version=&quot;2.0&quot;&gt;
&lt;xsl:template match=&quot;/&quot;&gt;
  &lt;html&gt;
    &lt;head&gt;&lt;title&gt;Frame example&lt;/title&gt;&lt;/head&gt;
    &lt;frameset cols=&quot;20%, 80%&quot;&gt;
      &lt;frame src=&quot;toc.html&quot;/&gt;
      &lt;exsl:document href=&quot;toc.html&quot;&gt;
        &lt;html&gt;
          &lt;head&gt;&lt;title&gt;Table of Contents&lt;/title&gt;&lt;/head&gt;
          &lt;body&gt;
             &lt;xsl:apply-templates mode=&quot;toc&quot; select=&quot;*&quot;/&gt;
          &lt;/body&gt;
        &lt;/html&gt;
      &lt;/exsl:document&gt;
      &lt;frame src=&quot;body.html&quot;/&gt;
      &lt;exsl:document href=&quot;body.html&quot;&gt;
        &lt;html&gt;
          &lt;head&gt;&lt;title&gt;Body&lt;/title&gt;&lt;/head&gt;
          &lt;body&gt;
             &lt;xsl:apply-templates select=&quot;*&quot;/&gt;
          &lt;/body&gt;
        &lt;/html&gt;
      &lt;/exsl:document&gt;
    &lt;/frameset&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;,
document{element p { &quot;hello&quot; }})
for $node at $i in $nodes
return 
if ( fn:document-uri($node) )
then xdmp:save(
       fn:resolve-uri(fn:document-uri($node), 
       &quot;C://mypath/exsl.xqy&quot;), $node)
else ($node) </Code>
<Body>
<A ID="pgfId-1064366"></A>
The above query will save the two documents created with <code>
exsl:document</code>
 to the App Server root on the filesystem, making them available to the output document with the frameset. For more details about the exsl:document instruction, see the EXSLT web site.</Body>
<Heading-3>
<A ID="pgfId-1064205"></A>
<A ID="95467"></A>
Notes on Importing Stylesheets With &lt;xsl:import&gt;</Heading-3>
<Body>
<A ID="pgfId-1065125"></A>
XSLT includes the <code>
&lt;xsl:import&gt;</code>
 instruction, which is used to import other stylesheets into a stylesheet. The MarkLogic implementation of the <code>
&lt;xsl:import&gt;</code>
 instruction is conformant to the specification, but the <code>
&lt;xsl:import&gt;</code>
 instruction can be complicated. For details on the <code>
&lt;xsl:import&gt;</code>
 instruction, see the XSLT specification or your favorite XSLT programming book.</Body>
<Body>
<A ID="pgfId-1065192"></A>
Some of the important points to note about the <code>
&lt;xsl:import&gt;</code>
 instruction are as follows:</Body>
<Body-bullet>
<A ID="pgfId-1065212"></A>
Any absolute URI references in the <code>
href</code>
 attribute are resolved in the context of the current MarkLogic Server database URIs. Relative paths are resolved relative to current module in the App Server root. For details, see <A href="../dev_guide/import_modules.xml#id(45509)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
XQuery Library Modules and Main Modules</Hyperlink>
</A> in the <Emphasis>
Application Developer's Guide</Emphasis>
.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1065238"></A>
Any code imported in an <code>
&lt;xsl:import&gt;</code>
 instruction follows the rules of precedence for XSLT imports. In general, that means that a stylesheet that imports has precedence over an imported stylesheet.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1065774"></A>
Any XQuery library modules imported into a styleheet follow the rules for XQuery imports, not the rules for XSLT imports. Notably, only functions and variables in the imported module are directly available to the stylesheet, not functions and variables that the XQuery library might import. XQuery library module imports use the <code>
&lt;xdmp:import-module&gt;</code>
 extension instruction, as described in <A href="xslt.xml#id(60484)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Importing XQuery Function Libraries to a Stylesheet' on page&#160;58</A>.</Body-bullet>
<Heading-2>
<A ID="pgfId-1065118"></A>
<A ID="70125"></A>
Invoking Stylesheets Directly Using the XSLT Rewriter</Heading-2>
<Body>
<A ID="pgfId-1065295"></A>
As described in <A href="xslt.xml#id(19423)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Invoking and Evaluating XSLT Stylesheets' on page&#160;57</A>, you invoke a stylesheet from an XQuery program. To set up an HTTP App Server to invoke a stylesheet by directly calling it from the App Server, you can set up a URL rewriter. For general information on using a URL rewriter, see <A href="../dev_guide/appserver-control.xml#id(13050)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Setting Up URL Rewriting for an HTTP App Server</Hyperlink>
</A> in the <Emphasis>
Application Developer's Guide</Emphasis>
.</Body>
<Body>
<A ID="pgfId-1065314"></A>
This section describes the sample URL rewriter for XSLT stylesheets and includes the following parts:</Body>
<Body-bullet>
<A ID="pgfId-1065366"></A>
<A href="xslt.xml#id(34949)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
About the Sample Rewriter</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1065383"></A>
<A href="xslt.xml#id(73722)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Setting Up the Sample Rewriter in Your HTTP App Server</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1065325"></A>
<A ID="34949"></A>
About the Sample Rewriter</Heading-3>
<Body>
<A ID="pgfId-1065342"></A>
The sample XSLT rewriter consists of two files, both installed in the <code>
&lt;marklogic-dir&gt;/Samples/xslt</code>
 directory:</Body>
<Body-bullet>
<A ID="pgfId-1065398"></A>
<code>
xslt-invoker.xqy</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1065422"></A>
<code>
xslt-rewrite-handler.xqy</code>
</Body-bullet>
<Body>
<A ID="pgfId-1065409"></A>
Once you set up the rewriter as described in the next section, URLs to the App Server of the form:</Body>
<Code>
<A ID="pgfId-1065436"></A>
/filename.xsl?doc=/url-of-context-node.xml</Code>
<Body>
<A ID="pgfId-1065447"></A>
will invoke the <code>
filename.xsl</code>
 stylesheet and pass it the context node at the URI specified in the <code>
doc</code>
 request field.</Body>
<Body>
<A ID="pgfId-1065463"></A>
It will also take URLs if the form:</Body>
<Code>
<A ID="pgfId-1065474"></A>
/styled/url-of-context-node.xml?stylesheet=/stylesheet.xsl</Code>
<Body>
<A ID="pgfId-1065481"></A>
will invoke the stylesheet at the path specified in the stylesheet request field passing in the context node in the path after <code>
/styled</code>
 (/url-of-context-node.xml in the above sample).</Body>
<Body>
<A ID="pgfId-1065518"></A>
The following table describes what the request fields you pass translate to when you are using the sample XSLT rewriter.</Body>
<TableAnchor>
<A ID="pgfId-1065531"></A>
</TableAnchor>
<TABLE>
<ROW>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1065538"></A>
Request Field</CellHeading>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1065540"></A>
Description</CellHeading>
</TH>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CodeLeft>
<A ID="pgfId-1065542"></A>
doc</CodeLeft>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1065544"></A>
Specifies the URI of the document to be passed into the stylesheet as the context node. If there is no <code>
doc</code>
 request field, then it defaults to a context node of <code>
default.xml</code>
. If no document with the URI <code>
default.xml</code>
 exists in the database, then the rewriter will throw an exception.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CodeLeft>
<A ID="pgfId-1065546"></A>
stylesheet</CodeLeft>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1065548"></A>
Used with paths that start with <code>
/styled</code>
. Specifies the path to the stylesheet to invoke. If it is not present, uses the stylesheet at <code>
default.xslt</code>
.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CodeLeft>
<A ID="pgfId-1065550"></A>
mode</CodeLeft>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1065552"></A>
The name of the initial mode to pass into the stylesheet. If not present, no mode is passed.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CodeLeft>
<A ID="pgfId-1065554"></A>
template</CodeLeft>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1065556"></A>
The name of the initial template to pass into the stylesheet. If not present, no template is passed in.</CellBody>
</CELL>
</ROW>
</TABLE>
<Heading-3>
<A ID="pgfId-1065349"></A>
<A ID="73722"></A>
Setting Up the Sample Rewriter in Your HTTP App Server</Heading-3>
<Body>
<A ID="pgfId-1065359"></A>
You can use the sample rewriter as-is or you can modify it to suit your needs. For example, if it makes sense for your stylesheets, you can modify it to always pass a certain node as the context node.</Body>
<Body>
<A ID="pgfId-1065598"></A>
To use the sample XSLT rewriter, perform the following steps:</Body>
<Number1>
<A ID="pgfId-1065609"></A>
Copy the <code>
xslt-invoker.xqy</code>
 and <code>
xslt-rewrite-handler.xqy</code>
 modules from the <code>
&lt;marklogic-dir&gt;/Samples/xsl</code>
t directory to your App Server root. The files must be at the top of the root of the App Server, not a subdirectory of the root. For example, if your root is set to <code>
/space/my-app-server</code>
, the new files should be copied to <code>
/space/my-app-server/xslt-invoker.xqy</code>
 and <code>
/space/my-app-server/xslt-rewrite-handler.xqy</code>
. If your root is in a modules database, then you must load the 2 files as text document (with any needed permissions) with URIs that begin with the App Server root.</Number1>
<NumberList>
<Number>
<A ID="pgfId-1065647"></A>
In the Admin Interface, navigate to the HTTP App Server configuration for the App Server in which want to directly invoke XSLT stylesheets. </Number>
<Number>
<A ID="pgfId-1065705"></A>
On the HTTP Server Configuration page, find the <code>
url rewriter</code>
 field (it is towards the bottom of the page).</Number>
<Number>
<A ID="pgfId-1065723"></A>
Enter /xslt-rewrite-handler.xqy into the <code>
url rewriter</code>
 field.</Number>
<Number>
<A ID="pgfId-1065742"></A>
Click OK.</Number>
</NumberList>
<Body>
<A ID="pgfId-1065749"></A>
Request against the App Server will now be automatically rewritten to directly invoke stylesheets as described in the previous section.</Body>
<Heading-2>
<A ID="pgfId-1065288"></A>
<A ID="49592"></A>
XSLT, XQuery, or Both</Heading-2>
<Body>
<A ID="pgfId-1059011"></A>
Both XQuery and XSLT are <Emphasis>
Turing Complete</Emphasis>
 programming languages; that is, in theory, you can use either language to compute whatever you need to compute. XQuery and XSLT share the same data model and share XPath 2.0, so there are a lot of commonalities between the two languages.</Body>
<Body>
<A ID="pgfId-1063441"></A>
On some level, choosing which language to perform a specific task is one of style. Different programmers have different styles, and so there is no 'correct' answer to what you should do in XQuery and what you should do in XSLT.</Body>
<Body>
<A ID="pgfId-1063452"></A>
In practice, however, XSLT is very convenient for performing XML transformation. You can do these transformations in XQuery too, and you can do them well in XQuery, but some programmers find it more natural to write a transformation in XSLT. </Body>
</XML>
