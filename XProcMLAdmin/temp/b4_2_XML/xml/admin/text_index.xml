<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="text_index.css" type="text/css" charset="UTF-8"?>
<XML>
<TITLE> </TITLE><Heading-1>
<A ID="pgfId-1038002"></A>
<A ID="37170"></A>
Text Indexing</Heading-1>
<pagenum>
<A ID="pgfId-1044502"></A>
231</pagenum>
<Body>
<A ID="pgfId-1038003"></A>
Before loading documents into a database, you have the option of specifying a number of parameters that will impact how the text components of those documents will be treated. This chapter describes those parameters and includes the following sections:</Body>
<Body-bullet>
<A ID="pgfId-1038008"></A>
<A href="text_index.xml#id(24289)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Text Indexes</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1038012"></A>
<A href="text_index.xml#id(29138)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Phrasing and Element-Word-Query Boundary Control</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1049001"></A>
<A href="text_index.xml#id(29854)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Query Behavior with Reindex Settings Enabled and Disabled</Hyperlink>
</A></Body-bullet>
<Body>
<A ID="pgfId-1038017"></A>
Text indexes and phrasing parameters are set on a per-database basis. </Body>
<Heading-2>
<A ID="pgfId-1038018"></A>
<A ID="24289"></A>
Text Indexes</Heading-2>
<Body>
<A ID="pgfId-1048186"></A>
MarkLogic Server allows you to configure, at the database level, which types of text indexes are constructed and maintained during document loading and updating. Each type of index accelerates the performance of a certain type of query. You can specify whether or not each different type of index is maintained for a given database. </Body>
<Note>
<A ID="pgfId-1048187"></A>
The index settings are designed to apply to an entire database. If you change any index settings on a database in which documents are already loaded, you must reindex your existing data, either by setting the <code>
reindexer enable</code>
 setting to <code>
true</code>
 for that database or by reloading the data. </Note>
<Body>
<A ID="pgfId-1050035"></A>
Understanding your likely query set will help you determine which of these index types to maintain. The cost of supporting additional indexes is increased disk space and document load times. As more and more indexes are maintained, document load speed decreases. By default, MarkLogic Server builds a set of indexes that is designed to yield the fast query performance in general usage scenarios.</Body>
<Body>
<A ID="pgfId-1050040"></A>
Text index types are configured on a per-database basis. This configuration should be completed before any documents are loaded into the specified database, although it can be changed later. If you change any index settings on a database in which documents are already loaded, you must reindex your existing data, either by setting the <code>
reindexer enable</code>
 setting to <code>
true</code>
 for that database or by reloading the data. </Body>
<Body>
<A ID="pgfId-1050086"></A>
In addition to the standard indexes, you can configure indexes on individual elements and attributes in a database. You can create range indexes and/or lexicons on individual elements or attributes in a database. For information on these indexes, see <A href="range_index.xml#id(21361)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Element and Attribute Range Indexes and Lexicons' on page&#160;232</A>. You can also create named fields which can explicitly include or exclude specified elements. For details on fields, see <A href="fields.xml#id(61682)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Fields Database Settings' on page&#160;126</A>.</Body>
<Body>
<A ID="pgfId-1050041"></A>
This section describes the text indexes in MarkLogic Server and includes the following subsections:</Body>
<Body-bullet>
<A ID="pgfId-1050045"></A>
<A href="text_index.xml#id(20530)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Understanding the Text Index Settings</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1050066"></A>
<A href="text_index.xml#id(45614)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Viewing Text Index Configuration</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1050049"></A>
<A href="text_index.xml#id(24432)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Configuring Text Indexes</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1050059"></A>
<A ID="20530"></A>
Understanding the Text Index Settings</Heading-3>
<Body>
<A ID="pgfId-1050062"></A>
The following table describes the different types of indexes available. The indexes are not mutually independent. If both the word search and stemmed search indexes are disabled, the configuration of the remaining indexes is irrelevant, as they all depend on the existence of the word and/or stemmed-search index. </Body>
<TableAnchor>
<A ID="pgfId-1038056"></A>
</TableAnchor>
<TABLE>
<ROW>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1043856"></A>
Index</CellHeading>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1043862"></A>
Default Setting</CellHeading>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1043868"></A>
Description</CellHeading>
</TH>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063504"></A>
language</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063506"></A>
en</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063508"></A>
Specifies the default language for content in this database. Any content without an <code>
xml:lang</code>
 attribute will be indexed in the language specified here. You should have a license key if you specify a non-English language; if you specify a non-english language and do not have a license for that language, the stemming and tokenization will be generic.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1043775"></A>
<code>
stemmed searches</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1043777"></A>
Basic (index is built, each word stems to a single stem)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1043779"></A>
Enables searches to return relevance ranked results by matching word stems. A word <Emphasis>
stem</Emphasis>
 is the word that has the same meaning as the specified word, and other words can also have that same stem; therefore, stemmed searches will return more matching results than the exact words specified in the query. A stemmed search for a word finds the exact same terms as well as terms that derive from the same meaning and part of speech as the search term. For example, a stemmed search for <code>
run</code>
 returns results containing <code>
run</code>
, <code>
running</code>
, <code>
runs</code>
, and <code>
ran</code>
. For details on stemming, see the chapter <A href="../search-dev-guide/stemming.xml#id(90878)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Understanding and Using Stemmed Searches</Hyperlink>
</A> in the <Emphasis>
Search Developer's Guide</Emphasis>
.</CellBody>
<CellBody>
<A ID="pgfId-1063252"></A>
There are three types of stemming: basic (one stem per word), advanced (one or more stems per word), and decompounding (advanced plus smaller component words of large compound words).</CellBody>
<CellBody>
<A ID="pgfId-1044229"></A>
Without either this index or the word searches index, MarkLogic Server is unable to perform relevance ranking and will refuse to execute any <code>
cts:word-query()</code>
-related built-in function. </CellBody>
<CellBody>
<A ID="pgfId-1044436"></A>
If both the stemmed search and word search indexes are enabled, MarkLogic Server defaults to performing stemmed searches (unless an unstemmed search is explicitly specified).</CellBody>
<CellBody>
<A ID="pgfId-1043780"></A>
Turn this index off if you want to disable stemmed searches. If word and stemmed search indexes are both off, then full-text searches are effectively disabled.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1044479"></A>
<code>
word searches</code>
 (unstemmed)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1044481"></A>
Off (index is not built)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1044483"></A>
Enables MarkLogic Server to return relevance ranked results which match exact words in text elements. Either this index or the stemmed search index is needed for MarkLogic Server to execute any <code>
cts:word-query()</code>
-related function.</CellBody>
<CellBody>
<A ID="pgfId-1044487"></A>
For many applications, keeping this word search index off and the stemmed search index on is sufficient to return the desired results for queries.</CellBody>
<CellBody>
<A ID="pgfId-1044488"></A>
Turn this index on if you want to do exact word-only matches. If word and stemmed search indexes are both off, then full-text searches are effectively disabled.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063289"></A>
<code>
word positions</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063291"></A>
Off (index is not built)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063293"></A>
Speeds up the performance of proximity queries that use the <code>
cts:near-query</code>
 function and of multi-word phrase searches. </CellBody>
<CellBody>
<A ID="pgfId-1063294"></A>
Turn this index off if you are not interested in proximity queries or phrase searches and if you want to conserve disk space and decrease loading time. If you turn this option on, you might find that you no longer need <code>
fast phrase searches</code>
, as they have some overlapping functionality.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1038036"></A>
<code>
fast phrase searches</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1038038"></A>
On (index is built)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1038040"></A>
Accelerates phrase searches by building additional indexes that describe sequences of words at load (or reindex) time. Without this index, MarkLogic Server will still perform phrase searches, just more slowly.</CellBody>
<CellBody>
<A ID="pgfId-1038041"></A>
Turn this index off if only a small percentage of your queries will contain phrase searches, and if conserving disk space and enhancing load speed is more important than the performance of those queries.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1038043"></A>
<code>
fast case sensitive searches</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1038045"></A>
On (index is built)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1038047"></A>
Accelerates case sensitive searches by building both case sensitive and case insensitive indexes at load time. Without this index, MarkLogic Server will still perform case sensitive searches, just more slowly.</CellBody>
<CellBody>
<A ID="pgfId-1038048"></A>
Turn this index off if only a small percentage of your text searches will be case sensitive, and if conserving disk space and enhancing load speed is more important than the performance of those queries.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1049973"></A>
<code>
fast reverse searches</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1049975"></A>
Off (index is not built)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1049977"></A>
Speeds up revers query searches by indexing stored queries. Turn this option on to speed up searches that use <code>
cts:reverse-query</code>
. </CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1066819"></A>
<code>
fast diacritic sensitive searches</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1066821"></A>
On (index is built)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1066823"></A>
Speeds up diacritic-sensitive searches by eliminating some false positive results. Turn this option off if you do not want to do diacritic-sensitive searches.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1038050"></A>
<code>
fast element word searches</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1038052"></A>
On (index is built)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1038054"></A>
Accelerates searches that look for words in specific elements by building additional indexes at load time. Without this index, MarkLogic Server will still perform these searches, just more slowly.</CellBody>
<CellBody>
<A ID="pgfId-1038055"></A>
Turn this index off if only a small percentage of your queries rely on finding words within specific document elements, and if conserving disk space and enhancing load speed is more important than the performance of those queries.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063299"></A>
<code>
element word positions</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063301"></A>
Off (index is not built)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063303"></A>
Speeds up the performance of proximity queries that use the <code>
cts:near-query</code>
 function in an element and of multi-word element phrase searches. </CellBody>
<CellBody>
<A ID="pgfId-1063304"></A>
Turn this index off if you are not interested in proximity queries and if you want to conserve disk space and decrease loading time.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1048205"></A>
<code>
fast element phrase searches</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1048207"></A>
On (index is built)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1048276"></A>
Accelerates phrase searches on elements by building additional indexes that describe sequences of words in elements at load (or reindex) time. Without this index, MarkLogic Server will still perform phrase searches, just more slowly.</CellBody>
<CellBody>
<A ID="pgfId-1048280"></A>
Turn this index off if only a small percentage of your queries will contain phrase searches at the element level, and if conserving disk space and enhancing load speed is more important than the performance of those queries.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063310"></A>
<code>
element value positions</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063312"></A>
Off (index is not built)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063314"></A>
Speeds up the performance of proximity queries that use the <code>
cts:element-value-query</code>
 function. </CellBody>
<CellBody>
<A ID="pgfId-1063315"></A>
Turn this index off if you are not interested in proximity queries and if you want to conserve disk space and decrease loading time.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1066844"></A>
<code>
attribute value positions</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1066846"></A>
Off (index is not built)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1066848"></A>
Speeds up the performance of proximity queries that use the <code>
cts:element-attribute-value-query</code>
 function and speeds up <code>
cts:element-query</code>
 searches that us attribute query constructors. </CellBody>
<CellBody>
<A ID="pgfId-1066849"></A>
Turn this index off if you are not interested in proximity queries and if you want to conserve disk space and decrease loading time.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063321"></A>
<code>
trailing wildcard searches</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063323"></A>
Off (index is not built)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063325"></A>
Speeds up wildcard searches where the wildcard is at the end of the search pattern (for example, <code>
abc*</code>
). The trailing wildcard index is more efficient than the three character index, but it does not speed up queries where the wildcard character is at the beginning of the term. </CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063331"></A>
<code>
trailing wildcard word positions</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063333"></A>
Off (index is not built)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063335"></A>
Speeds up the performance proximity queries that use trailing-wildcard word searches, such as wildcard queries that use the <code>
cts:near-query</code>
 function and multi-word phrase searches that contain one or more wildcard terms. </CellBody>
<CellBody>
<A ID="pgfId-1063336"></A>
Turn this index on if you are using trailing wildcard searches and proximity queries together in the same search.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1049994"></A>
<code>
fast element trailing wildcard searches</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1049996"></A>
Off (index is not built)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1049998"></A>
Faster wildcard searches with the wildcard at the end of the search pattern within a specific element, but slower document loads and larger database files.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063352"></A>
<code>
three character searches</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063354"></A>
Off (index is not built)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063356"></A>
Enables wildcard searches where the search pattern contains three or more consecutive non-wildcard characters (for example, <code>
abc*x</code>
, <code>
*abc</code>
, <code>
a?bcd</code>
). When combined with a codepoint word lexicon, speeds the performance of any wildcard search (including searches with fewer than three consecutive non-wildcard characters). MarkLogic recommends combining the <code>
three character search</code>
 index with a codepoint collation word lexicon. For details on wildcard characters, see the chapter on wildcard searches in the <Emphasis>
Application Developer's Guide</Emphasis>
.</CellBody>
<CellBody>
<A ID="pgfId-1063360"></A>
When character indexing is turned on in the database, the system will also deliver higher performance for<code>
 fn:contains()</code>
, <code>
fn:matches()</code>
, <code>
fn:starts-with()</code>
 and <code>
fn:ends-with()</code>
 for most query expressions.</CellBody>
<CellBody>
<A ID="pgfId-1063361"></A>
Turn this index on if you want to enable wildcard searches that match three or more characters. If you need your wildcard searches to match only two or one characters, then you should enable two character searches and/or one character searches. </CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1049696"></A>
<code>
three character word positions</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1049698"></A>
Off (index is not built)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1049700"></A>
Speeds up the performance of proximity queries that use three-character word searches, such as queries that use the <code>
cts:near-query</code>
 function and multi-word phrase searches that contain one or more wildcard terms. </CellBody>
<CellBody>
<A ID="pgfId-1049701"></A>
Turn this index on if you are using wildcard searches and proximity queries together in the same search.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063363"></A>
<code>
two character searches</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063365"></A>
Off (index is not built)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063367"></A>
Enables wildcard searches where the search pattern contains two or more consecutive non-wildcard characters. For details on wildcard characters, see the chapter on wildcard searches in the <Emphasis>
Application Developer's Guide</Emphasis>
.</CellBody>
<CellBody>
<A ID="pgfId-1063371"></A>
When character indexing is turned on in the database, the system will also deliver higher performance for<code>
 fn:contains()</code>
, <code>
fn:matches()</code>
, <code>
fn:starts-with()</code>
 and <code>
fn:ends-with()</code>
 for most query expressions.</CellBody>
<CellBody>
<A ID="pgfId-1063372"></A>
Turn this index on if you want to enable wildcard searches that match two or more characters (for example, <code>
ab*</code>
). This index is not needed if you have <code>
three character searches</code>
 and a word lexicon.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063374"></A>
<code>
one character searches</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063376"></A>
Off (index is not built)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063378"></A>
Enables wildcard searches where the search pattern contains only a single non-wildcard character. For details on wildcard characters, see the chapter on wildcard searches in the <Emphasis>
Application Developer's Guide</Emphasis>
.</CellBody>
<CellBody>
<A ID="pgfId-1063382"></A>
When character indexing is turned on in the database, the system will also deliver higher performance for<code>
 fn:contains()</code>
, <code>
fn:matches()</code>
, <code>
fn:starts-with()</code>
 and <code>
fn:ends-with()</code>
 for most query expressions.</CellBody>
<CellBody>
<A ID="pgfId-1063383"></A>
Turn this index on if you want to enable wildcard searches that match one or more characters (for example, <code>
a*</code>
). This index is not needed if you have <code>
three character searches</code>
 and a word lexicon.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063342"></A>
<code>
fast element character searches</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063344"></A>
Off (index is not built)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063346"></A>
Enables searches to return results which match the wildcard characters. Also, speeds up element-based wildcard searches. For details on wildcard characters, see the chapter on wildcard searches in the <Emphasis>
Application Developer's Guide</Emphasis>
.</CellBody>
<CellBody>
<A ID="pgfId-1063350"></A>
Turn this index on if you want to enable wildcard searches. </CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063389"></A>
<code>
word lexicons</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063391"></A>
Off (index is not built)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063393"></A>
Maintains a lexicon of all of the words in a database, with uniqueness determined by a specified collation. For details on lexicons, see <A href="range_index.xml#id(21361)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Element and Attribute Range Indexes and Lexicons' on page&#160;232</A> and the chapter on lexicons in the <Emphasis>
Application Developer's Guide</Emphasis>
. For details on collations, see the <A href="../search-dev-guide/languages.xml#id(40505)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Language Support in MarkLogic Server</Hyperlink>
</A> chapter in the <Emphasis>
Search Developer's Guide</Emphasis>
.</CellBody>
<CellBody>
<A ID="pgfId-1067093"></A>
Speeds up wildcard searches. Works in combination with any other available wildcard indexes to improve search index resolution and performance. When used in conjunction with the <code>
three character search</code>
 index, improves wildcard index resolution and speeds up wildcard searches. If you have <code>
three character search</code>
 and a word lexicon enabled for a database, then there is no need for either the <code>
one character</code>
 or <code>
two character search</code>
 indexes. For best performance, the word lexicon should be in the codepoint collation (<code>
http://marklogic.com/collation/codepoint</code>
). For details on wildcard searches, see the chapter on wildcard searches in the <Emphasis>
Application Developer's Guide</Emphasis>
.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063401"></A>
<code>
uri lexicon</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063403"></A>
Off (index is not built)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1063405"></A>
Maintains a lexicon of all of the URIs used in a database. The URI lexicon speeds up queries that constrain on URIs. It is like a range index of all of the URIs in the database. To access values from the URI lexicon, use the <code>
cts:uris</code>
 or <code>
cts:uri-match</code>
 APIs.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1050480"></A>
<code>
collection lexicon</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1050482"></A>
Off (index is not built)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1050484"></A>
Maintains a lexicon of all of the collection URIs used in a database. The collection lexicon speeds up queries that constrain on collections. It is like a range index of all of the collection URIs in the database. To access values from the collection lexicon, use the <code>
cts:collections</code>
 or <code>
cts:collection-match</code>
 APIs.</CellBody>
</CELL>
</ROW>
</TABLE>
<Heading-3>
<A ID="pgfId-1050092"></A>
<A ID="45614"></A>
Viewing Text Index Configuration</Heading-3>
<Body>
<A ID="pgfId-1038071"></A>
To view text index configuration for a particular database, complete the following procedure:</Body>
<Number1>
<A ID="pgfId-1038072"></A>
Click on the Databases icon on the left tree menu.</Number1>
<NumberList>
<Number>
<A ID="pgfId-1048359"></A>
Locate the database for which you want to view text index configuration settings, either in the tree menu or in the Database Summary table.</Number>
<Number>
<A ID="pgfId-1048360"></A>
Click the name of the database for which you want to view the settings. </Number>
<Number>
<A ID="pgfId-1038076"></A>
Scroll down until the text index settings are visible. The following screen shots show the default configuration of text indexing for a database:</Number>
</NumberList>
<Body-indent>
<A ID="pgfId-1038081"></A>
<IMAGE xml:link="simple" href="images/index_options.gif" show="embed" actuate="auto"/>
</Body-indent>
<Body-indent>
<A ID="pgfId-1063444"></A>
<IMAGE xml:link="simple" href="images/index_options2.gif" show="embed" actuate="auto"/>
</Body-indent>
<Body-indent>
<A ID="pgfId-1063448"></A>
<IMAGE xml:link="simple" href="images/index_options3.gif" show="embed" actuate="auto"/>
</Body-indent>
<Heading-3>
<A ID="pgfId-1038082"></A>
<A ID="24432"></A>
Configuring Text Indexes</Heading-3>
<Body>
<A ID="pgfId-1038083"></A>
To configure text indexes for a particular database, complete the following procedure:</Body>
<Number1>
<A ID="pgfId-1038084"></A>
Click on the Databases icon on the left tree menu.</Number1>
<NumberList>
<Number>
<A ID="pgfId-1048377"></A>
Locate the database for which you want to view text index configuration settings, either in the tree menu or in the Database Summary table.</Number>
<Number>
<A ID="pgfId-1048378"></A>
Click the name of the database for which you want to view the settings. </Number>
<Number>
<A ID="pgfId-1038088"></A>
Scroll down until the text indexing controls are visible.</Number>
<Number>
<A ID="pgfId-1038089"></A>
Configure the text indexes for this database by selecting the appropriate radio buttons for each index type.</Number>
</NumberList>
<Body-indent>
<A ID="pgfId-1038090"></A>
Click on the <code>
true</code>
 radio button for a particular text index type if you want that index to be maintained. Click on the <code>
false</code>
 radio button for a particular text index type if you do not want that index to be maintained.</Body-indent>
<Note>
<A ID="pgfId-1038091"></A>
If word searches and stemmed searches are disabled (that is, the <code>
false</code>
 radio button is selected for <code>
word searches</code>
 and off is selected for <code>
stemmed searches</code>
), the settings for the other text indexes are ignored, as explained above.</Note>
<NumberList>
<Number>
<A ID="pgfId-1038092"></A>
Leave the rest of the parameters unchanged.</Number>
<Number>
<A ID="pgfId-1038093"></A>
Scroll to the top or bottom of the right frame and click OK.</Number>
</NumberList>
<EndList-root>
<A ID="pgfId-1038094"></A>
The database now has the new text indexing configurations.</EndList-root>
<Heading-2>
<A ID="pgfId-1038096"></A>
<A ID="29138"></A>
Phrasing and Element-Word-Query Boundary Control</Heading-2>
<Body>
<A ID="pgfId-1038097"></A>
MarkLogic Server allows you to specify how XML element constructors impact text phrasing and element-word-query boundaries for searches. This section has the following parts:</Body>
<Body-bullet>
<A ID="pgfId-1048458"></A>
<A href="text_index.xml#id(88260)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Phrasing Control</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1048462"></A>
<A href="text_index.xml#id(93943)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Element Word Query Throughs</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1048463"></A>
<A href="text_index.xml#id(36816)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Procedures</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1048464"></A>
<A ID="88260"></A>
Phrasing Control</Heading-3>
<Body>
<A ID="pgfId-1038098"></A>
By default, MarkLogic Server assumes that any XML element constructor acts as a phrase boundary. This means that phrase searches (for example, searches for sequences of terms) will not match a sequence of terms that contains one or more XML element constructors. Phrasing control lets you specify which XML elements should be transparent to phrase boundaries (for example, a bold or italic element), and which XML elements should be ignored for phrase purposes (for example, footnotes or graphic captions).</Body>
<Body>
<A ID="pgfId-1038099"></A>
For example, consider the following sample XML fragment:</Body>
<Code>
<A ID="pgfId-1048766"></A>
&lt;paragraph&gt;
&#160;&#160;These two words &lt;italic&gt;are italicized&lt;/italic&gt;. The italic element
&#160;&#160;&lt;footnote&gt;Elements are defined in the W3C XML standard.&lt;/footnote&gt;
&#160;&#160;is a standard part of this document's schema.
&lt;/paragraph&gt;</Code>
<Body>
<A ID="pgfId-1038101"></A>
By default, MarkLogic Server would extract the following five sequences of text for phrase matching purposes (ignoring punctuation and case for simplicity):</Body>
<Body-bullet>
<A ID="pgfId-1038102"></A>
'these two words'</Body-bullet>
<Body-bullet>
<A ID="pgfId-1038103"></A>
'are italicized'</Body-bullet>
<Body-bullet>
<A ID="pgfId-1038104"></A>
'the italic element'</Body-bullet>
<Body-bullet>
<A ID="pgfId-1038105"></A>
'elements are defined in the w3c xml standard'</Body-bullet>
<Body-bullet>
<A ID="pgfId-1038106"></A>
'is a standard part of this document's schema'</Body-bullet>
<Body>
<A ID="pgfId-1038107"></A>
If you then attempted to match the phrases 'words are italicized' or 'element is a standard part' against this XML fragment, no matches would be found, because of the embedded XML element constructors.</Body>
<Body>
<A ID="pgfId-1038108"></A>
In fact, a human looking at this XML fragment would realize that the <code>
italic</code>
 element should be transparent for phrasing purposes, and that the <code>
footnote</code>
 element is a completely independent text container. Seen from this viewpoint, the XML fragment shown above contains only two text sequences (again, ignoring punctuation and case for simplicity):</Body>
<Body-bullet>
<A ID="pgfId-1038109"></A>
'these two words are italicized the italic element is a standard part of this document's schema'</Body-bullet>
<Body-bullet>
<A ID="pgfId-1038110"></A>
'elements are defined in the w3c xml standard'</Body-bullet>
<Body>
<A ID="pgfId-1038111"></A>
In this case, 'words are italicized' and 'element is a standard part' would each properly generate a match. But a search for 'the w3c xml standard is a standard' would not result in a match.</Body>
<Body>
<A ID="pgfId-1038112"></A>
MarkLogic Server lets you achieve this type of phrasing control by specifying particular XML element names as phrase-through, phrase-around, and element-word-query-through elements:</Body>
<TableAnchor>
<A ID="pgfId-1038127"></A>
</TableAnchor>
<TABLE>
<ROW>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1044348"></A>
Type</CellHeading>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1044350"></A>
Definition</CellHeading>
</TH>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1038120"></A>
<code>
Phrase-through</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1038122"></A>
Elements that should not create phrase boundaries (as in the example above, <code>
italic</code>
 should be specified as a phrase-through element).</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1038124"></A>
<code>
Phrase-around</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1038126"></A>
Elements whose content should be completely ignored in the context of the current phrase (as in the example above, <code>
footnote</code>
 should be specified as a phrase-around element).</CellBody>
</CELL>
</ROW>
</TABLE>
<Body>
<A ID="pgfId-1038129"></A>
Phrase controls are configured on a per-database basis. You should complete this configuration before loading any documents into the specified database; otherwise, in order for the changes to take effect with your existing content, you must either reload the content or reindex the database after changing the configuration. </Body>
<Heading-3>
<A ID="pgfId-1038130"></A>
<A ID="93943"></A>
Element Word Query Throughs</Heading-3>
<Body>
<A ID="pgfId-1048424"></A>
Element-word-query-throughs allow you to specify elements that should be included in text searches that use <code>
cts:element-word-query</code>
 on a parent element. For example, consider the following XML fragment:</Body>
<Code>
<A ID="pgfId-1048425"></A>
&lt;a&gt;
&#160;&#160;&lt;b&gt;hello&lt;/b&gt;
&#160;&#160;&lt;c&gt;goodbye&lt;/c&gt;
&lt;/a&gt;</Code>
<Body>
<A ID="pgfId-1048787"></A>
If you perform a <code>
cts:element-word-query</code>
 on <code>
&lt;a&gt;</code>
 searching for the word <code>
hello</code>
, the search does not find any matches in this fragment. The following query shows this pattern:</Body>
<Code>
<A ID="pgfId-1048884"></A>
cts:search(fn:doc(), cts:element-word-query(xs:QName(&quot;a&quot;), &quot;hello&quot;))</Code>
<Body>
<A ID="pgfId-1048880"></A>
This query does not find any matches because <code>
cts:element-word-query</code>
 only searches for text nodes that are immediate children of the element <code>
&lt;a&gt;</code>
, not text nodes that are children of any child nodes of <code>
&lt;a&gt;</code>
. Because <code>
hello</code>
 is in a text node that is a child of <code>
&lt;b&gt;</code>
, it does not satisfy the <code>
cts:element-word-query</code>
.</Body>
<Body>
<A ID="pgfId-1048824"></A>
If you add an element-word-query-through for the element <code>
&lt;b&gt;</code>
, however, then the <code>
cts:element-word-query</code>
 on <code>
&lt;a&gt;</code>
 searching for the word <code>
hello</code>
 returns a match. The element-word-query-through on <code>
&lt;b&gt;</code>
 causes the text node children of <code>
&lt;b&gt;</code>
 behave like the text node children of its parent (in this case, <code>
&lt;a&gt;</code>
).</Body>
<Note>
<A ID="pgfId-1048833"></A>
If an element is specified as a phrase-through, then it is also behaves as an element-word-query-through, and therefore you do not need to specify it as an element-word-query-through.</Note>
<Heading-3>
<A ID="pgfId-1048469"></A>
<A ID="36816"></A>
Procedures</Heading-3>
<Body>
<A ID="pgfId-1048420"></A>
Use the following procedures to configure phrase controls for a particular database:</Body>
<Body-bullet>
<A ID="pgfId-1038134"></A>
<A href="text_index.xml#id(18283)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Viewing Phrasing and Element-Word-Query Settings</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1038138"></A>
<A href="text_index.xml#id(41854)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Configuring Phrasing and Element-Word-Query Settings</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1038142"></A>
<A href="text_index.xml#id(98975)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Deleting a Phrasing or Element-Word-Query Setting</Hyperlink>
</A></Body-bullet>
<Heading-4>
<A ID="pgfId-1038143"></A>
<A ID="18283"></A>
Viewing Phrasing and Element-Word-Query Settings</Heading-4>
<Body>
<A ID="pgfId-1038144"></A>
To view element-word-query-through, phrase-through, and phrase-around settings for a particular database, complete the following procedure in the Admin Interface:</Body>
<Number1>
<A ID="pgfId-1038145"></A>
Click on the Databases icon on the left tree menu.</Number1>
<NumberList>
<Number>
<A ID="pgfId-1048568"></A>
Locate the database for which you want to view element-word-query-through, phrase-through, or phrase-around settings, either in the tree menu or in the Database Summary table.</Number>
<Number>
<A ID="pgfId-1048569"></A>
Click the name of the database for which you want to view the settings. </Number>
<Number>
<A ID="pgfId-1038150"></A>
Click the Element-Word-Query-Throughs, Phrase-Throughs, or Phrase-Arounds icon, depending on which one you want to view.</Number>
<Number>
<A ID="pgfId-1038151"></A>
The configuration page displays.</Number>
</NumberList>
<EndList-root>
<A ID="pgfId-1038152"></A>
The following example shows that the Documents database has been configured with a number of phrase-through elements, including the <code>
&lt;abbr&gt;</code>
, <code>
&lt;acronym&gt;</code>
, <code>
&lt;b&gt;</code>
, <code>
&lt;big&gt;</code>
, <code>
&lt;br&gt;</code>
 and <code>
&lt;center&gt;</code>
 elements of the XHTML namespace:</EndList-root>
<Body>
<A ID="pgfId-1038156"></A>
<IMAGE xml:link="simple" href="images/phrase.gif" show="embed" actuate="auto"/>
</Body>
<Heading-4>
<A ID="pgfId-1038157"></A>
<A ID="41854"></A>
Configuring Phrasing and Element-Word-Query Settings</Heading-4>
<Body>
<A ID="pgfId-1038158"></A>
To configure element-word-query-through, phrase-through, and phrase-around settings for a particular database, perform the following procedure in the Admin Interface:</Body>
<Number1>
<A ID="pgfId-1038159"></A>
Click the Databases icon in the left tree menu.</Number1>
<NumberList>
<Number>
<A ID="pgfId-1048616"></A>
Locate the database for which you want to configure element-word-query-through, phrase-through, or phrase-around settings, either in the tree menu or in the Database Summary table.</Number>
<Number>
<A ID="pgfId-1048617"></A>
Click the name of the database for which you want to configure the settings. </Number>
<Number>
<A ID="pgfId-1048618"></A>
Click the Element-Word-Query-Throughs, Phrase-Throughs, or Phrase-Arounds icon, depending on which one you want to configure.</Number>
</NumberList>
<Note>
<A ID="pgfId-1038165"></A>
The remainder of this procedure will assume that you have chosen to configure phrase-through settings. If you wish to configure phrase-around or element-word-query-through settings, the steps are completely analogous, once you have clicked on the corresponding icon.</Note>
<NumberList>
<Number>
<A ID="pgfId-1038166"></A>
<A ID="65981"></A>
Click the Create tab at the top right. The Phrase-Throughs Configuration page displays:</Number>
</NumberList>
<Body-indent>
<A ID="pgfId-1038171"></A>
<IMAGE xml:link="simple" href="images/phrase-through.gif" show="embed" actuate="auto"/>
</Body-indent>
<NumberList>
<Number>
<A ID="pgfId-1038172"></A>
<A ID="20223"></A>
Enter the namespace URI of the XML element that you are specifying as a phrase-through element.</Number>
</NumberList>
<Body-indent>
<A ID="pgfId-1038173"></A>
Every XML element is associated with a namespace. For the phrase-through setting to be precise, you must specify the namespace of the XML element. Leaving the namespace URI field blank specifies the universal unnamed namespace.</Body-indent>
<Body-indent>
<A ID="pgfId-1038174"></A>
Alternatively, you can specify that the element is namespace independent by putting an asterisk (*) in the namespace URI field.</Body-indent>
<NumberList>
<Number>
<A ID="pgfId-1038175"></A>
<A ID="77397"></A>
Enter the element name in the localname field.</Number>
</NumberList>
<Body-indent>
<A ID="pgfId-1038176"></A>
The local name is the name of the XML element that you are specifying as a phrase-through element. If you want to specify more than one element that is associated with the specified namespace, you can provide a comma-separated list of element names.</Body-indent>
<NumberList>
<Number>
<A ID="pgfId-1038177"></A>
To add more phrase-throughs, click the More Items button and repeat step <A href="text_index.xml#id(20223)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
6</Hyperlink>
</A> - step <A href="text_index.xml#id(77397)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
7</Hyperlink>
</A> for each phrase-through element as needed.</Number>
<Number>
<A ID="pgfId-1038178"></A>
Scroll to the top or bottom and click OK.</Number>
</NumberList>
<EndList-root>
<A ID="pgfId-1038179"></A>
The new phrase-through is added.</EndList-root>
<Note>
<A ID="pgfId-1048727"></A>
If you change the element-word-query-through, phrase-through, or phrase-around settings for a particular database after documents have already been loaded, you should reindex your existing data, either by setting the <code>
reindexer enable</code>
 setting to <code>
true</code>
 for that database or by reloading the data. </Note>
<Heading-4>
<A ID="pgfId-1048729"></A>
<A ID="98975"></A>
Deleting a Phrasing or Element-Word-Query Setting</Heading-4>
<Body>
<A ID="pgfId-1048730"></A>
To delete an element-word-query-through, phrase-through, or phrase-around setting for a particular database, perform the following procedure in the Admin Interface:</Body>
<Number1>
<A ID="pgfId-1038183"></A>
Click the Databases icon in the left tree menu.</Number1>
<NumberList>
<Number>
<A ID="pgfId-1048696"></A>
Locate the database for which you want to delete element-word-query-through, phrase-through, or phrase-around settings, either in the tree menu or in the Database Summary table.</Number>
<Number>
<A ID="pgfId-1048697"></A>
Click the name of the database for which you want to delete the settings. </Number>
<Number>
<A ID="pgfId-1048698"></A>
Click the Element-Word-Query-Throughs, Phrase-Throughs, or Phrase-Arounds icon, depending on which one you want to delete.</Number>
</NumberList>
<Body-indent>
<A ID="pgfId-1038190"></A>
The appropriate configuration page displays.</Body-indent>
<NumberList>
<Number>
<A ID="pgfId-1038191"></A>
Scroll down to the element that you want to delete.</Number>
<Number>
<A ID="pgfId-1038192"></A>
Click the Drop button next to the element that you want to delete.</Number>
</NumberList>
<Body-indent>
<A ID="pgfId-1038193"></A>
A confirmation message displays.</Body-indent>
<NumberList>
<Number>
<A ID="pgfId-1038194"></A>
Confirm the delete operation and click OK.</Number>
</NumberList>
<Body-indent>
<A ID="pgfId-1038195"></A>
The Phrase-Through or Phrase-Around element is deleted from the database.</Body-indent>
<Note>
<A ID="pgfId-1048690"></A>
If you change the element-word-query-through, phrase-through, or phrase-around settings for a particular database after documents have already been loaded, you should reindex your existing data, either by setting the <code>
reindexer enable</code>
 setting to <code>
true</code>
 for that database or by reloading the data. </Note>
<Heading-2>
<A ID="pgfId-1049002"></A>
<A ID="29854"></A>
Query Behavior with Reindex Settings Enabled and Disabled</Heading-2>
<Body>
<A ID="pgfId-1049006"></A>
When you load a document into a database, it is indexed based on the index settings at the time of the load. When you issue a query to a database, it is evaluated based on a consistent view of the index settings. This consistent view might not include all of the index features that are enabled in the database. This section describes the behavior of queries at various index-setting states of the database, and includes the following parts:</Body>
<Body-bullet>
<A ID="pgfId-1049012"></A>
<A href="text_index.xml#id(22354)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Understanding the Reindexer Enable Settings</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1049017"></A>
<A href="text_index.xml#id(20592)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Query Evaluation According to the Lowest Common Denominator</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1050602"></A>
<A href="text_index.xml#id(19479)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Reindexing Does Not Apply to Point-In-Time Versions of Fragments</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1049018"></A>
<A href="text_index.xml#id(32380)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Example Scenario</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1049013"></A>
<A ID="22354"></A>
Understanding the Reindexer Enable Settings</Heading-3>
<Body>
<A ID="pgfId-1049022"></A>
At the database level, you can enable or disable automatic reindexing by setting the <code>
reindexer enable</code>
 setting to <code>
true</code>
 or <code>
false</code>
 for that database. When the reindexer is enabled, any index or fragment changes to the database settings will cause all documents in the database that are not indexed/fragmented according to the settings to initiate a reindex operation. Note the following about the database settings and the reindex operation:</Body>
<Body-bullet>
<A ID="pgfId-1049058"></A>
When reindexing is enabled, the reindex operation runs as a background task. You can set a higher or lower priority on the reindexing task by increasing or decreasing the setting of the <code>
reindexer throttle</code>
.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1049065"></A>
Any new documents added to or updated in the database will get the new database settings. This is true both with reindexing enabled and with reindexing disabled.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1049062"></A>
After changing index or fragmentation settings in a database, because new or modified documents get the new settings, the database can get into a state where some documents are indexed/fragmented differently from other documents in the database. </Body-bullet>
<Body-bullet>
<A ID="pgfId-1049077"></A>
After changing index or fragmentation settings in a database in which reindexing is enabled, the old documents are reindexed according to the new settings, but the new settings do not take effect for queries until the reindex operation has completed and all documents are indexed to the state matching the database settings.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1049076"></A>
After changing index or fragmentation settings in a database in which reindexing is disabled, new and changed documents get the current settings, but queries will not take advantage of the new settings until all documents in the database match the database settings.</Body-bullet>
<Heading-3>
<A ID="pgfId-1049023"></A>
<A ID="20592"></A>
Query Evaluation According to the Lowest Common Denominator</Heading-3>
<Body>
<A ID="pgfId-1049027"></A>
When queries are evaluated, they use the index settings that are calculated for the database at a given time. The current index settings for a query are determined at the time of query evaluation, and are based on the lowest common denominator of (that is, the index/fragmentation settings that are the least of) the following:</Body>
<Body-bullet>
<A ID="pgfId-1049100"></A>
The index/fragmentation settings defined in the database configuration.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1049104"></A>
The actual index/fragmentation of documents/fragments in the database.</Body-bullet>
<Body>
<A ID="pgfId-1049108"></A>
At any given time, the current lowest common denominator is invalidated upon the following events:</Body>
<Body-bullet>
<A ID="pgfId-1049109"></A>
system startup</Body-bullet>
<Body-bullet>
<A ID="pgfId-1049114"></A>
a change to the database configuration settings</Body-bullet>
<Body-bullet>
<A ID="pgfId-1049115"></A>
when a reindexing operation completes</Body-bullet>
<Body>
<A ID="pgfId-1049128"></A>
If the lowest common denominator is invalidated, it is recalculated the next time a query is issued against the database.</Body>
<Body>
<A ID="pgfId-1049132"></A>
The net impact is that, when index/fragmentation settings have changed on a database after any data is loaded, queries cannot take advantage of the new settings until the new settings meet the lowest common denominator criteria. Depending on the types of index setting changes you make, this can cause queries that behaved one way before index settings were changed to behave differently after the changes. The next section provides a sample scenario to help illustrate this behavior.</Body>
<Heading-3>
<A ID="pgfId-1049028"></A>
<A ID="19479"></A>
Reindexing Does Not Apply to Point-In-Time Versions of Fragments</Heading-3>
<Body>
<A ID="pgfId-1050606"></A>
If you have set a <code>
merge timestamp</code>
 on the database to retain older versions of fragments for point-in-time queries, the older versions of the fragments will retain the indexing properties of the database at the time when they were updated. Because of this, reindexing a database that uses point-in-time queries can cause unpredictable query results. MarkLogic recommends that you do not reindex a database that has the <code>
merge timestamp</code>
 parameter set to anything but 0. For details on point-in-time queries, see the 'Point-In-Time Queries' chapter in the <Emphasis>
Application Developer's Guide</Emphasis>
. For details on setting the <code>
merge timestamp</code>
 parameter, see <A href="merges.xml#id(55318)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Merges and Point-In-Time Queries' on page&#160;146</A>.</Body>
<Heading-3>
<A ID="pgfId-1050603"></A>
<A ID="32380"></A>
Example Scenario</Heading-3>
<Body>
<A ID="pgfId-1049032"></A>
This section describes a simple scenario showing the effect of changing index settings on query behavior over time.</Body>
<Body>
<A ID="pgfId-1049294"></A>
The following figure shows how changing the index settings can effect queries that initiate after index setting changes occur.</Body>
<Body>
<A ID="pgfId-1049302"></A>
<IMAGE xml:link="simple" href="text_index-6.gif" show="embed" actuate="auto"/>
</Body>
<Body>
<A ID="pgfId-1049141"></A>
In this scenario, the query issued at time T3 sees the <code>
doc1</code>
 document with stemming and 3-character wildcard indexes enabled. Wildcard queries such as <code>
abc*</code>
 will be successful. The same wildcard query at time T5, however, will not be successful, because the 3-character index (which is required for the <code>
abc*</code>
 query) was disabled at time T4. Note that the document <code>
doc1</code>
 is actually indexed with 3-character and stemming, but the query at time T5 only is able to use the stemming index. At time T7, the database has <code>
doc1</code>
 indexed with both stemming and 3-character indexes, but <code>
doc2</code>
 only has the stemming index. With reindexing disabled, the query at T7 will use the lowest common denominator, which is in this case stemming.</Body>
</XML>
