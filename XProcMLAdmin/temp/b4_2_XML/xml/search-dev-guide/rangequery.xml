<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="rangequery.css" type="text/css" charset="UTF-8"?>
<XML>
<TITLE> </TITLE><Heading-1>
<A ID="pgfId-1053802"></A>
<A ID="19990"></A>
 Using Range Queries in cts:query Expressions</Heading-1>
<pagenum>
<A ID="pgfId-1053806"></A>
95</pagenum>
<Body>
<A ID="pgfId-1049471"></A>
MarkLogic Server allows you to access range indexes in a <code>
cts:query</code>
 expression to constrain a search by a range of values in an element or attribute. This chapter describes some details about these range queries and includes the following sections:</Body>
<Body-bullet>
<A ID="pgfId-1053734"></A>
<A href="rangequery.xml#id(60182)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Overview of Range Queries</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054824"></A>
<A href="rangequery.xml#id(39727)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Range Query cts:query Constructors</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054825"></A>
<A href="rangequery.xml#id(69464)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Examples of Range Queries</Hyperlink>
</A></Body-bullet>
<Heading-2>
<A ID="pgfId-1053740"></A>
<A ID="60182"></A>
Overview of Range Queries</Heading-2>
<Body>
<A ID="pgfId-1055437"></A>
This section provides an overview of what range queries are and why you might want to use them, and includes the following sections:</Body>
<Body-bullet>
<A ID="pgfId-1055571"></A>
<A href="rangequery.xml#id(93272)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Uses for Range Queries</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055585"></A>
<A href="rangequery.xml#id(54686)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Requirements for Using Range Queries</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055575"></A>
<A href="rangequery.xml#id(10755)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Performance and Coding Advantages of Range Queries</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1055493"></A>
<A ID="93272"></A>
Uses for Range Queries</Heading-3>
<Body>
<A ID="pgfId-1055586"></A>
Range queries are designed to constrain searches on ranges of a value. For example, if you want to find all articles that were published in 2005, and if your content has an element (or an attribute or a property) named <code>
PUBLISHDATE</code>
 with type <code>
xs:date</code>
, you can create a range index on the element <code>
PUBLISHDATE</code>
, then specify in a search that you want all articles with a <code>
PUBLISHDATE</code>
 greater than December 31, 2004 and less than January 1, 2006. Because that element has a range index, MarkLogic Server can resolve the query extremely efficiently.</Body>
<Body>
<A ID="pgfId-1055613"></A>
Because you can create range indexes on a wide variety of XML datatypes, there is a lot of flexibility in the types of content with which you can use range queries to constrain searches. In general, if you need to constrain on a value, it is possible to create a range index and use range queries to express the ranges in which you want to constrain the results. </Body>
<Heading-3>
<A ID="pgfId-1055584"></A>
<A ID="54686"></A>
Requirements for Using Range Queries</Heading-3>
<Body>
<A ID="pgfId-1055497"></A>
Keep in mind the following requirements for using range queries in your <code>
cts:search</code>
 operations:</Body>
<Body-bullet>
<A ID="pgfId-1055473"></A>
Range queries require a range index to be defined on the element or attribute in which you want to constrain the results.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055477"></A>
The range index must be in the same collation as the one specified in the range query.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055478"></A>
If no collation is specified in the range query, then the query takes on the collation of the query (for example, if a collation is specified in the XQuery prolog, that is used). For details on collation defaults, see <A href="encodings_collations.xml#id(80895)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'How Collation Defaults are Determined' on page&#160;215</A>.</Body-bullet>
<Body>
<A ID="pgfId-1055967"></A>
Because range queries require range indexes, keep in mind that range indexes take up space, add to memory usage on the machine(s) in which MarkLogic Server runs, and increase loading/reindexing time. As such, they are not exactly 'free', although, particularly if you have a relatively small number of them, they will not use a huge amount of resources. The amount of resources used depends a lot on the content; how many documents have the elements and/or attributes specified, how often do those elements/attributes appear in the content, how large is the content set, and so on. As with many performance improvements, there are trade-offs to analyze, and the best way to analyze the impact is to experiment and see if the cost is worth the performance improvement. For details about range indexes and procedures for creating them, see the <A href="../admin/range_index.xml#id(21361)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Element and Attribute Range Indexes and Lexicons</Hyperlink>
</A> chapter in the <Emphasis>
Administrator's Guide</Emphasis>
.</Body>
<Heading-3>
<A ID="pgfId-1055498"></A>
<A ID="10755"></A>
Performance and Coding Advantages of Range Queries</Heading-3>
<Body>
<A ID="pgfId-1055502"></A>
Most of what you can express using range queries you can also express using predicates in XPath expressions. There are two big advantages of using range queries over XPath predicates:</Body>
<Body-bullet>
<A ID="pgfId-1055549"></A>
Performance </Body-bullet>
<Body-bullet>
<A ID="pgfId-1055554"></A>
Ease of coding</Body-bullet>
<Body>
<A ID="pgfId-1055527"></A>
Using range queries in <code>
cts:query</code>
 expressions can produce faster performance than using XPath predicates. Range indexes are in-memory structures, and because range indexes are required for range queries, they are usually very fast. There is no requirement for the range index when specifying an XPath predicate, and it is therefore possible to specify a predicate that might need to scan a large number of fragments, which could take considerable time. Additionally, because range queries are <code>
cts:query</code>
 objects, you can use registered queries to pre-compile them, adding more performance advantages.</Body>
<Body>
<A ID="pgfId-1055532"></A>
There are also coding advantages to range queries over XPath predicates. Because range queries are leaf-level <code>
cts:query</code>
 constructors, they can be combined with other constructors (including other range query constructors) to form complex expressions. It is fairly easy to write XQuery code that takes user input from a form (from drop-down lists, text boxes, radio buttons, and so on) and use that user input to generate extremely complex <code>
cts:query</code>
 expressions. It is very difficult to do that with XPath expressions. For details on <code>
cts:query</code>
 expressions, see <A href="cts_query.xml#id(51991)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Composing cts:query Expressions' on page&#160;56</A>.</Body>
<Heading-2>
<A ID="pgfId-1055438"></A>
<A ID="39727"></A>
Range Query cts:query Constructors</Heading-2>
<Body>
<A ID="pgfId-1055459"></A>
The following XQuery APIs are included in the range query constructors:</Body>
<Body-bullet>
<A ID="pgfId-1055460"></A>
<code>
cts:element-attribute-range-query</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055461"></A>
<code>
cts:element-range-query</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055462"></A>
corresponding accessor functions</Body-bullet>
<Body>
<A ID="pgfId-1055465"></A>
Each API takes QNames, the type of operator (for example, &gt;=, &lt;=, and so on), values, and a collation as inputs. For details of these APIs and for their signatures, see the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
.</Body>
<Note>
<A ID="pgfId-1055981"></A>
For release 3.2, range queries do not contribute to the score, regardless of the weight specified in the <code>
cts:query</code>
 constructor.</Note>
<Heading-2>
<A ID="pgfId-1055452"></A>
<A ID="69464"></A>
Examples of Range Queries</Heading-2>
<Body>
<A ID="pgfId-1055456"></A>
The following are some examples that use range query constructors.</Body>
<Body>
<A ID="pgfId-1055749"></A>
Consider a document with a URI <code>
/dates.xml</code>
 with the following structure:</Body>
<Code>
<A ID="pgfId-1055751"></A>
&lt;root&gt;
  &lt;entry&gt;
    &lt;date&gt;2007-01-01&lt;/date&gt;
    &lt;info&gt;Some information.&lt;/info&gt;
  &lt;/entry&gt;
  &lt;entry&gt;
    &lt;date&gt;2006-06-23&lt;/date&gt;
    &lt;info&gt;Some other information.&lt;/info&gt;
  &lt;/entry&gt;
  &lt;entry&gt;
    &lt;date&gt;1971-12-23&lt;/date&gt;
    &lt;info&gt;Some different information.&lt;/info&gt;
  &lt;/entry&gt;
&lt;/root&gt; </Code>
<Body>
<A ID="pgfId-1055819"></A>
Assume you have defined an element range index of type <code>
xs:date</code>
 on the QName <code>
date</code>
 (note that you must either load the document after defining the range index or complete a reindex of the database after defining the range index).</Body>
<Body>
<A ID="pgfId-1055834"></A>
You can now issue queries using the <code>
cts:element-range-query</code>
 constructor. The following query searches the <code>
entry</code>
 element of the document <code>
/dates.xml</code>
 for entries that occurred on or before January 1, 2000.</Body>
<Code>
<A ID="pgfId-1055820"></A>
cts:search(doc(&quot;/dates.xml&quot;)/root/entry, 
  cts:element-range-query(xs:QName(&quot;date&quot;), &quot;&lt;=&quot;,
      xs:date(&quot;2000-01-01&quot;) ) )</Code>
<Body>
<A ID="pgfId-1055859"></A>
This query returns the following node, because it is the only one that satisfies the range query:</Body>
<Code>
<A ID="pgfId-1055846"></A>
&lt;entry&gt;
    &lt;date&gt;1971-12-23&lt;/date&gt;
    &lt;info&gt;Some different information.&lt;/info&gt;
&lt;/entry&gt;</Code>
<Body>
<A ID="pgfId-1055854"></A>
The following query uses a <code>
cts:and-query</code>
 to combine two date ranges, dates after January&#160;1,&#160;2006 and dates before January 1, 2008.</Body>
<Code>
<A ID="pgfId-1055855"></A>
cts:search(doc(&quot;/dates.xml&quot;)/root/entry, 
  cts:and-query((
   cts:element-range-query(xs:QName(&quot;date&quot;), &quot;&gt;&quot;,
      xs:date(&quot;2006-01-01&quot;) ),
   cts:element-range-query(xs:QName(&quot;date&quot;), &quot;&lt;&quot;,
      xs:date(&quot;2008-01-01&quot;) ) )) )</Code>
<Body>
<A ID="pgfId-1055875"></A>
This query returns the following two nodes:</Body>
<Code>
<A ID="pgfId-1055876"></A>
&lt;entry&gt;
    &lt;date&gt;2007-01-01&lt;/date&gt;
    &lt;info&gt;Some information.&lt;/info&gt;
&lt;/entry&gt;

&lt;entry&gt;
    &lt;date&gt;2006-06-23&lt;/date&gt;
    &lt;info&gt;Some other information.&lt;/info&gt;
&lt;/entry&gt;</Code>
</XML>
