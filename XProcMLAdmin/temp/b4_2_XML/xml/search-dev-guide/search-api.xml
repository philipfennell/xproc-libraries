<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="search-api.css" type="text/css" charset="UTF-8"?>
<XML>
<TITLE> </TITLE><Heading-1>
<A ID="pgfId-1059573"></A>
<A ID="71050"></A>
Search API: Understanding and Using</Heading-1>
<pagenum>
<A ID="pgfId-1059577"></A>
55</pagenum>
<Body>
<A ID="pgfId-1059578"></A>
This chapter describes the Search API, which is an XQuery API designed to make it easy to create search applications that contain facets, search results, and snippets. This chapter includes the following sections:</Body>
<Body-bullet>
<A ID="pgfId-1059579"></A>
<A href="search-api.xml#id(16593)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Understanding the Search API</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1059580"></A>
<A href="search-api.xml#id(12693)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Controlling the Search With the Options Node</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1059581"></A>
<A href="search-api.xml#id(95581)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Generating Search API Options with Application Builder</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1062548"></A>
<A href="search-api.xml#id(34509)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Search Term Completion Using search:suggest</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1062558"></A>
<A href="search-api.xml#id(49750)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Creating a Custom Constraint</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1063062"></A>
<A href="search-api.xml#id(44520)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Modifying and Extending the Search Parsing Grammar</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1062568"></A>
<A href="search-api.xml#id(61050)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
More Search API Examples</Hyperlink>
</A></Body-bullet>
<Body>
<A ID="pgfId-1070015"></A>
This chapter provides background, design patterns, and examples of using the Search API. For the function signatures and descriptions, see the Search documentation under XQuery Library Modules in the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
.</Body>
<Heading-2>
<A ID="pgfId-1054048"></A>
<A ID="16593"></A>
Understanding the Search API</Heading-2>
<Body>
<A ID="pgfId-1055106"></A>
The Search API is an XQuery library that combines searching, search parsing, search grammar, faceting, snippeting, search term completion, and other search application features into a single API. The Search API makes it easy to create search applications without needing to understand many of the details of the underlying <code>
cts:search</code>
 and <code>
cts:query</code>
 APIs. The Search API is designed for large-scale, production applications. This section provides an overview and describes some of the features of the Search API, and contains the following topics:</Body>
<Body-bullet>
<A ID="pgfId-1059280"></A>
<A href="search-api.xml#id(81423)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
XQuery Library Module</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1059294"></A>
<A href="search-api.xml#id(32545)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Simple search:search Example and Response Output</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1059308"></A>
<A href="search-api.xml#id(41745)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Automatic Query Text Parsing and Grammar</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1073682"></A>
<A href="search-api.xml#id(77403)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Constrained Searches and Faceted Navigation</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1070374"></A>
<A href="search-api.xml#id(65347)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Built-In Snippetting</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1070904"></A>
<A href="search-api.xml#id(39268)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Search Term Completion</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1075234"></A>
<A href="search-api.xml#id(28383)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Search Customization Via Options and Extensions</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1070919"></A>
<A href="search-api.xml#id(98851)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Speed and Accuracy</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1059241"></A>
<A ID="81423"></A>
XQuery Library Module</Heading-3>
<Body>
<A ID="pgfId-1059394"></A>
The Search API is implemented as an XQuery library module. You can use it by importing the module into your XQuery module with the following XQuery prolog statement:</Body>
<Code>
<A ID="pgfId-1059633"></A>
import module namespace search = 
  &quot;http://marklogic.com/appservices/search&quot;
  at &quot;/MarkLogic/appservices/search/search.xqy&quot;;</Code>
<Body>
<A ID="pgfId-1059644"></A>
The Search API uses the prefix <code>
search:</code>
, which is not predefined in the server. The Search API has the following core functions to perform searches and provide search results, snippets, and query-completion suggestions: <code>
search:search</code>
, <code>
search:snippet</code>
, and <code>
search:suggest</code>
. There are also other functions to perform these activities at finer granularities and to provide convenience tools.</Body>
<Body>
<A ID="pgfId-1059727"></A>
For the Search API function signatures and details about each individual function, see the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
 for the Search API. </Body>
<Heading-3>
<A ID="pgfId-1059387"></A>
<A ID="32545"></A>
Simple search:search Example and Response Output</Heading-3>
<Body>
<A ID="pgfId-1059353"></A>
The <code>
search:search</code>
 function takes search terms, parses them into an appropriate <code>
cts:query</code>
, and returns a response with snippets and URIs for matching nodes in the database. You can get started with the Search API with a very simple query:</Body>
<Code>
<A ID="pgfId-1059417"></A>
xquery version &quot;1.0-ml&quot;;

import module namespace search = 
  &quot;http://marklogic.com/appservices/search&quot;
  at &quot;/MarkLogic/appservices/search/search.xqy&quot;;

search:search(&quot;hello world&quot;)
=&gt;
&lt;search:response total=&quot;1&quot; start=&quot;1&quot; page-length=&quot;10&quot;
&#160;&#160;xmlns:search=&quot;http://marklogic.com/appservices/search&quot;&gt;
  &lt;search:result index=&quot;1&quot; uri=&quot;/hello.xml&quot;
&#160;&#160;&#160;&#160;path=&quot;doc(&amp;quot;/hello.xml&amp;quot;)&quot; score=&quot;136&quot;
&#160;&#160;&#160;&#160;confidence=&quot;0.67393&quot; fitness=&quot;0.67393&quot;&gt;
    &lt;search:snippet&gt;
      &lt;search:match path=&quot;doc(&amp;quot;/hello.xml&amp;quot;)/hello&quot;&gt;This is 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;where you say &quot;&lt;search:highlight&gt;Hello&lt;/search:highlight&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;search:highlight&gt;World&lt;/search:highlight&gt;&quot;.
&#160;&#160;&#160;&#160;&#160;&#160;&lt;/search:match&gt;
    &lt;/search:snippet&gt;
  &lt;/search:result&gt;
  &lt;search:qtext&gt;hello world&lt;/search:qtext&gt;
  &lt;search:metrics&gt;
    &lt;search:query-resolution-time&gt;PT0.328S
&#160;&#160;&#160;&#160;&#160;&#160;&lt;/search:query-resolution-time&gt;
    &lt;search:total-time&gt;PT0.352S&lt;/search:total-time&gt;
  &lt;/search:metrics&gt;
&lt;/search:response&gt;</Code>
<Body>
<A ID="pgfId-1060794"></A>
The output is a <code>
search:response</code>
 element, and it contains everything needed to build a search results page. It includes an estimate of the total number of documents that match the search, the URI and XPath for each result, pagination of the search results, a snippet of the result content, the original query text submitted, and metrics on the response time. </Body>
<Body>
<A ID="pgfId-1075454"></A>
To try the Search API on your own content, run a simple search like the above example against a database of your own content, and then examine the search results. </Body>
<Body>
<A ID="pgfId-1060879"></A>
The <code>
search:search</code>
 function is highly customizable, but by default it includes sensible settings that will provide good results for many applications. With the results of <code>
search:search</code>
, it is easy to build useful results pages that are as simple or as complex as you like. </Body>
<Heading-3>
<A ID="pgfId-1075160"></A>
<A ID="41745"></A>
Automatic Query Text Parsing and Grammar</Heading-3>
<Body>
<A ID="pgfId-1075161"></A>
In a typical search application, a user enters text into a search box in a browser. The Search API takes query text input (for example, from text that a user enters into a search box) and parses it into a <code>
cts:query</code>
 for efficient and powerful searches. By default, the query text is parsed using a grammar similar to the Google grammar. For example, double-quoted phrases in query text such as the following are treated as phrases in a search:</Body>
<Code>
<A ID="pgfId-1075162"></A>
&quot;this is a phrase&quot;</Code>
<Body>
<A ID="pgfId-1075163"></A>
The default grammar also supports <code>
AND</code>
, <code>
OR</code>
, grouping with parenthesis ( <code>
( )</code>
 ), negation with a minus sign ( <code>
-</code>
 ), and user-configured constraints with a colon ( <code>
:</code>
 ). The following is a summary of the default grammar:</Body>
<Body-bullet>
<A ID="pgfId-1075164"></A>
Terms may be free standing:</Body-bullet>
<Code>
<A ID="pgfId-1075165"></A>
cat</Code>
<Body-bullet>
<A ID="pgfId-1075166"></A>
<code>
AND</code>
 and <code>
OR</code>
 operators, with <code>
AND</code>
 having higher precedence.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1075167"></A>
Parentheses operators can override default precedence:</Body-bullet>
<Code>
<A ID="pgfId-1075168"></A>
(cat OR dog) AND horse</Code>
<Body-bullet>
<A ID="pgfId-1075169"></A>
Multiple terms are combined as an <code>
AND</code>
:</Body-bullet>
<Code>
<A ID="pgfId-1075170"></A>
cat dog</Code>
<Body-bullet>
<A ID="pgfId-1075171"></A>
Phrases are surrounded by double-quotes:</Body-bullet>
<Code>
<A ID="pgfId-1075172"></A>
&quot;cat and dog&quot;</Code>
<Body-bullet>
<A ID="pgfId-1075173"></A>
Terms are excluded through a leading minus:</Body-bullet>
<Code>
<A ID="pgfId-1075174"></A>
cat -dog</Code>
<Body-bullet>
<A ID="pgfId-1075175"></A>
Colon operators indicate configured constraint or operator searches (for details, see <A href="search-api.xml#id(95820)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Constraint Options' on page&#160;22</A> and <A href="search-api.xml#id(30002)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Operator Options' on page&#160;31</A>):</Body-bullet>
<Code>
<A ID="pgfId-1075182"></A>
tag:value</Code>
<Body-bullet>
<A ID="pgfId-1075183"></A>
Constraint and operator searches may operate over phrases:</Body-bullet>
<Code>
<A ID="pgfId-1075184"></A>
tag:&quot;a phrase value&quot;</Code>
<Body-bullet>
<A ID="pgfId-1075185"></A>
A query text can comprise any number of these types of searches in any order.</Body-bullet>
<Body>
<A ID="pgfId-1075186"></A>
The query text parsing happens automatically, with no additional coding. The parsing takes into account constraints and operators specified in an options node at search runtime. Additionally, you can change, extend, and modify the default search parsing grammar in the options node. Most applications will not need to modify the search grammar, as the default grammar is quite robust and full-featured. For details on modifying the default grammar, see <A href="search-api.xml#id(44520)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Modifying and Extending the Search Parsing Grammar' on page&#160;49</A>. For details on the options node for the Search API, see <A href="search-api.xml#id(12693)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Controlling the Search With the Options Node' on page&#160;21</A>. </Body>
<Heading-3>
<A ID="pgfId-1059332"></A>
<A ID="77403"></A>
Constrained Searches and Faceted Navigation</Heading-3>
<Body>
<A ID="pgfId-1059370"></A>
The Search API makes it easy to constrain your searches to a subset of the content. For example, you can create a search that only returns results for documents with titles that include the word <code>
hello</code>
, or you can create a search that constrains the results to a particular decade. Furthermore, the Search API makes it easy to express these kinds of searches in a simple query text string. For example, you can write a query such that the following query text represents a search that constrains to a particular decade:</Body>
<Code>
<A ID="pgfId-1076251"></A>
decade:2000s</Code>
<Body>
<A ID="pgfId-1076227"></A>
These types of searches are useful in creating facets, which allow a user to drill down by narrowing the search criteria. Facets also typically have counts of the number of results that match, and the Search API returns these counts to use in facets. The following is an example of a facet in an end-user application:</Body>
<Body>
<A ID="pgfId-1061096"></A>
<IMAGE xml:link="simple" href="images/facet.gif" show="embed" actuate="auto"/>
</Body>
<Body>
<A ID="pgfId-1070677"></A>
Users can click on any of the links to narrow the results of the search by decade. For example, the query generated by clicking the top link contains the string <code>
decade:2000s</code>
, and constrains the search to that decade. </Body>
<Body>
<A ID="pgfId-1070691"></A>
The facet also includes counts for each constraint value. The number to the right of the link represents the number of search results returned if you constrain it to that decade. </Body>
<Body>
<A ID="pgfId-1061112"></A>
The Search API returns XML in its response that contains all of the information to create a facet like the above example. The facets returned from the Search API include the counts and values needed to generate the user interface. For example, the following XML, returned from the Search API, was used to create the above facet:</Body>
<Code>
<A ID="pgfId-1061476"></A>
&lt;search:response total=&quot;2370&quot; start=&quot;1&quot; page-length=&quot;10&quot;
&#160;&#160;&#160;xmlns:search=&quot;http://marklogic.com/appservices/search&quot;&gt;
&#160;&#160;&lt;search:facet name=&quot;decade&quot;&gt;
    &lt;search:facet-value name=&quot;2000s&quot; count=&quot;240&quot;&gt;
&#160;&#160;&#160;&#160;&#160;2000s&lt;/search:facet-value&gt;
    &lt;search:facet-value name=&quot;1990s&quot; count=&quot;300&quot;&gt;
&#160;&#160;&#160;&#160;&#160;1990s&lt;/search:facet-value&gt;
    &lt;search:facet-value name=&quot;1980s&quot; count=&quot;300&quot;&gt;
&#160;&#160;&#160;&#160;&#160;1980s&lt;/search:facet-value&gt;
    &lt;search:facet-value name=&quot;1970s&quot; count=&quot;300&quot;&gt;
&#160;&#160;&#160;&#160;&#160;1970s&lt;/search:facet-value&gt;
    &lt;search:facet-value name=&quot;1960s&quot; count=&quot;299&quot;&gt;
&#160;&#160;&#160;&#160;&#160;1960s&lt;/search:facet-value&gt;
    &lt;search:facet-value name=&quot;1950s&quot; count=&quot;300&quot;&gt;
&#160;&#160;&#160;&#160;&#160;1950s&lt;/search:facet-value&gt;
    &lt;search:facet-value name=&quot;1940s&quot; count=&quot;324&quot;&gt;
&#160;&#160;&#160;&#160;&#160;1940s&lt;/search:facet-value&gt;
    &lt;search:facet-value name=&quot;1930s&quot; count=&quot;245&quot;&gt;
&#160;&#160;&#160;&#160;&#160;1930s&lt;/search:facet-value&gt;
    &lt;search:facet-value name=&quot;1920s&quot; count=&quot;61&quot;&gt;
&#160;&#160;&#160;&#160;&#160;1920s&lt;/search:facet-value&gt;
&#160;&#160;&lt;/search:facet&gt;
&lt;/search:response&gt;</Code>
<Body>
<A ID="pgfId-1061085"></A>
The counts and values in the response are also filtered by any other active query in the search, so they represent the counts for that particular search. There are many kinds of constraints and facets you can build with the Search API. For more details about constraints, see <A href="search-api.xml#id(95820)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Constraint Options' on page&#160;22</A>.</Body>
<Heading-3>
<A ID="pgfId-1070343"></A>
<A ID="65347"></A>
Built-In Snippetting</Heading-3>
<Body>
<A ID="pgfId-1073700"></A>
A search results page typically shows portions of matching documents with the search matches highlighted, perhaps with some text showing the context of the search matches. These search result pieces are known as <Emphasis>
snippets</Emphasis>
. For example, a search for <code>
MarkLogic Server</code>
 might produce the following snippet:</Body>
<Code>
<A ID="pgfId-1073730"></A>
<Bold>
MarkLogic Server</Bold>
 is an XML Server that provides the agility you need to build and ... Use <Bold>
MarkLogic Server's</Bold>
 geospatial capability to create new dynamic ...</Code>
<Body>
<A ID="pgfId-1073707"></A>
The Search API includes snippets in the search:response output, and makes it easy to create search results pages that show the matches in the context of the document. Providing the best snippet for a given content set is often very application specific, however. Therefore, the Search API allows you to customize the snippets, either using the built-in snippetting algorithm or by adding your own snippetting code. For details on ways to customize the snippetting behavior for your searches, see <A href="search-api.xml#id(58295)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Modifying Your Snippet Results' on page&#160;33</A>.</Body>
<Heading-3>
<A ID="pgfId-1070722"></A>
<A ID="39268"></A>
Search Term Completion</Heading-3>
<Body>
<A ID="pgfId-1075211"></A>
Search application often offer suggestions for search terms as the user types into the search box. The suggestions are based on terms that are in the database, and are typically used to make the user interface more interactive and to quickly suggest search terms that are appropriate to the application. The <code>
search:suggest</code>
 function in the Search API is designed to supply the terms to a search-completion user interface. For more details on how to use search term completion, see <A href="search-api.xml#id(34509)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Search Term Completion Using search:suggest' on page&#160;37</A>.</Body>
<Heading-3>
<A ID="pgfId-1075204"></A>
<A ID="28383"></A>
Search Customization Via Options and Extensions</Heading-3>
<Body>
<A ID="pgfId-1070743"></A>
The Search API is designed to make it easy to customize your searches. A wide range of customizations are available directly through the options that you pass into the search. There are a large number of options controlling nearly every aspect of the search you are performing.</Body>
<Body>
<A ID="pgfId-1070752"></A>
For cases where the built-in options do not do what you need, there is an extension mechanism built into the Search API. The mechanism includes hooks in the Search API which allow you to call out to your own XQuery code. The hooks allow you to specify the location and name of the function containing your own implementation of a function to replace the implementation of that function in the Search API. The Search API uses function values to pass your custom function as a parameter, replacing the default Search API functionality. For details on function values, see <A href="../dev_guide/function-values.xml#id(86523)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Function Values</Hyperlink>
</A> in the <Emphasis>
Application Developer's Guide</Emphasis>
. </Body>
<Body>
<A ID="pgfId-1072156"></A>
The basic pattern to specify your extension function using the attributes <code>
apply</code>
, <code>
ns</code>
, and <code>
at</code>
 as attributes on various elements in the <code>
search:options</code>
 node. These correspond to the localname of your implemented function, the namespace of the function, and the location of the function library module in which the code exists, respectively. For example, consider the following:</Body>
<Code>
<A ID="pgfId-1072168"></A>
&lt;transform-results apply=&quot;my-snippet&quot; ns=&quot;my-namespace&quot;
&#160;&#160;&#160;&#160;&#160;at=&quot;/my-module.xqy&quot; /&gt;</Code>
<Body>
<A ID="pgfId-1072179"></A>
In this example, the <code>
transform-results</code>
 option specifies to use the <code>
my-snippet</code>
 function in the library module <code>
my-module</code>
 under your App Server root instead of the default snippeting function that the Search API uses. For additional details about working with <code>
transform-results</code>
, see <A href="search-api.xml#id(58295)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Modifying Your Snippet Results' on page&#160;33</A>.</Body>
<Body>
<A ID="pgfId-1076331"></A>
Any search option that has an <code>
apply</code>
 attribute can use this extension pattern to point to your own implementation for the functionality of that option, including <code>
transform-results</code>
, several <code>
grammar</code>
 options, <code>
custom</code>
 constraints, and so on.</Body>
<Heading-3>
<A ID="pgfId-1070806"></A>
<A ID="98851"></A>
Speed and Accuracy</Heading-3>
<Body>
<A ID="pgfId-1070821"></A>
The Search API is designed to be fast. When creating any search application, you make trade-offs between speed and guaranteed accuracy. The values of various options in the Search API control things like filtered versus unfiltered search, diacritic and case-sensitivity, and other options. These options affect the accuracy of search estimates in MarkLogic Server. The default values of these type of options in the Search API are designed to be sensible for most application. All applications are different, however, and the Search API gives you the tools to control what makes sense for your specific application. </Body>
<Body>
<A ID="pgfId-1070870"></A>
Range constraints use lexicons to get fast accurate unique values and counts. Keep in mind, however, that certain operations might not produce accurate counts in all cases. For example, when you pass a <code>
cts:query</code>
 into a lexicon API (which the Search API does in some cases), it filters the lexicon calls based on the index resolution of the <code>
cts:query</code>
, not on the filtered search values, and the index resolution is not guaranteed to be accurate for all queries. For details on how search index resolution works, see <A href="../performance/unfiltered.xml#id(38698)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Fast Pagination and Unfiltered Searches</Hyperlink>
</A> in <Emphasis>
Query Performance and Tuning Guide</Emphasis>
.</Body>
<Body>
<A ID="pgfId-1070836"></A>
Other factors such as fragmentation and what you search for (<code>
searchable-expression</code>
 in the Search API options) can also contribute to whether the index resolution for a search is correct, as can various options to lexicons. The Search API default values for these various options make the trade-offs that are sensible for many search applications. For example, the value of the <code>
total</code>
 attribute in the <code>
search:response</code>
 output is the result of an <code>
cts:remainder</code>
, which will always be fast but is not guaranteed to be accurate for all searches. For details, see <A href="count_estimate.xml#id(49739)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Using fn:count vs. xdmp:estimate' on page&#160;130</A>.</Body>
<Heading-2>
<A ID="pgfId-1055142"></A>
<A ID="12693"></A>
Controlling the Search With the Options Node</Heading-2>
<Body>
<A ID="pgfId-1059200"></A>
The <code>
search:search</code>
 function and most of the other functions in the Search API take an optional options node as a parameter. The options node allows you to specify the behavior of the Search API. If you do not specify an options node, the API uses a set of defaults that are designed to be sensible for many applications. You can use the <code>
search:get-default-options</code>
 function to see the default options. The options node allows you to specify constraints, custom grammar, search options, what parts of the response to return, what expression to search over, and so on. </Body>
<Body>
<A ID="pgfId-1060898"></A>
The options node is in the following namespace:</Body>
<Code>
<A ID="pgfId-1070048"></A>
<code>
http://marklogic.com/appservices/search</code>
</Code>
<Body>
<A ID="pgfId-1060917"></A>
This section describes the following portions of the options node:</Body>
<Body-bullet>
<A ID="pgfId-1060928"></A>
<A href="search-api.xml#id(46535)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Checking an Options Node With search:check-options</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1062812"></A>
<A href="search-api.xml#id(95820)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Constraint Options</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1060938"></A>
<A href="search-api.xml#id(30002)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Operator Options</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1062590"></A>
<A href="search-api.xml#id(97754)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Return Options</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1062601"></A>
<A href="search-api.xml#id(43671)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Searchable Expression Option</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1071661"></A>
<A href="search-api.xml#id(32762)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Other Search Options</Hyperlink>
</A></Body-bullet>
<Body>
<A ID="pgfId-1061984"></A>
For details the syntax of each option, see the <code>
search:search</code>
 function documentation in <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
.</Body>
<Heading-3>
<A ID="pgfId-1059516"></A>
<A ID="46535"></A>
Checking an Options Node With search:check-options</Heading-3>
<Body>
<A ID="pgfId-1062826"></A>
The options XML node can be fairly complex, and there is a <code>
search:check-options</code>
 function that reports errors in your options node. The <code>
search:check-options</code>
 function validates your options node and reports any errors it finds. It returns empty if the options node is valid. If it finds errors, they are returned in the form of one or more <code>
search:report</code>
 nodes.</Body>
<Body>
<A ID="pgfId-1062861"></A>
It is a good idea to only use the <code>
search:check-options</code>
 function in development, as it will slow down queries to check the options on every search. You can also use the <code>
&lt;debug&gt;true&lt;/debug&gt;</code>
 option in the <code>
search:options</code>
 node, which will return the output of <code>
search:check-options</code>
 as part of your response. </Body>
<Body>
<A ID="pgfId-1076359"></A>
One common design pattern is to add a <code>
$debug</code>
 option to your code that defaults to <code>
false</code>
, and when <code>
true</code>
, have your code run <code>
search:check-options</code>
 on the options node or add the <code>
debug</code>
 option to the options node. If you have a variable called <code>
$debug</code>
 in your code that is normally set to <code>
false</code>
, then setting it to <code>
true</code>
 results in checking your options node. Then in production, you can set it back to <code>
false</code>
.</Body>
<Heading-3>
<A ID="pgfId-1062819"></A>
<A ID="95820"></A>
Constraint Options</Heading-3>
<Body>
<A ID="pgfId-1059533"></A>
A <Emphasis>
constraint</Emphasis>
 is a mechanism the Search API uses to define ways of constraining a search based on a slice of the database. Constraints provide the Search API with information about your database and specify how to query against those details of the database. They are designed to take advantage of range indexes, other configuration objects (such as word lexicons, collection lexicons, and fields) that exist in the database, and the structures of documents in the database (for example, element values, attribute values, words, and so on). Constraints are primarily used for the following purposes:</Body>
<Body-bullet>
<A ID="pgfId-1060972"></A>
To provide a way to specify the constraint in the search grammar. For information on search parsing and grammar, see <A href="search-api.xml#id(41745)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Automatic Query Text Parsing and Grammar' on page&#160;16</A>.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1060989"></A>
To return information designed to be used in creating facets in an application. For information on facets, see <A href="search-api.xml#id(77403)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Constrained Searches and Faceted Navigation' on page&#160;17</A>. </Body-bullet>
<Body-bullet>
<A ID="pgfId-1076375"></A>
To enhance search suggestions made by <code>
search:suggest</code>
. For information on search suggestions, see <A href="search-api.xml#id(39268)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Search Term Completion' on page&#160;19</A>.</Body-bullet>
<Body>
<A ID="pgfId-1075902"></A>
Each constraint is named, and the name must be unique across all operators and constraints in your options node. When you specify a constraint as query text in a Search API call, you use the name as a constraint in the search grammar followed by the <code>
apply=&quot;constraint&quot;</code>
 <Emphasis>
joiner</Emphasis>
 string (a colon character [<code>
:</code>
] by default). The joiner string joins the constraint (or the operator) with its value. For example, the following query text:</Body>
<Code>
<A ID="pgfId-1072256"></A>
decade:1980s </Code>
<Body>
<A ID="pgfId-1072268"></A>
specifies the constraint named <code>
decade</code>
 with a value of <code>
1980s</code>
. The following figure shows each portion of the constraint query text:</Body>
<Body>
<A ID="pgfId-1072319"></A>
<IMAGE xml:link="simple" href="search-api-2.gif" show="embed" actuate="auto"/>
</Body>
<Body>
<A ID="pgfId-1072330"></A>
For more details about the search grammar, see <A href="search-api.xml#id(41745)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Automatic Query Text Parsing and Grammar' on page&#160;16</A> and <A href="search-api.xml#id(44520)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Modifying and Extending the Search Parsing Grammar' on page&#160;49</A>.</Body>
<Body>
<A ID="pgfId-1061119"></A>
The following table lists the types of constraints you can build with the Search API. </Body>
<TableAnchor>
<A ID="pgfId-1061130"></A>
</TableAnchor>
<TABLE>
<ROW>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1061140"></A>
Constraint</CellHeading>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1061142"></A>
Description</CellHeading>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1061144"></A>
<code>
cts:query</code>
 Equivalent for constraint</CellHeading>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1071028"></A>
Lexicon API Equivalent for Facets</CellHeading>
</TH>
</ROW>
<ROW>
<CELL ROWSPAN="2" COLSPAN="1">
<CellBody>
<A ID="pgfId-1061146"></A>
<code>
value</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1061148"></A>
Constrains on an element value or on an attribute value. </CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1061150"></A>
<code>
cts:element-value-query</code>
, <code>
cts:element-attribute-
&#160;&#160;value-query</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1071030"></A>
No facets for value constraints.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="3">
<CellBody>
<A ID="pgfId-1072414"></A>
Example <code>
value</code>
 constraint:</CellBody>
<Code>
<A ID="pgfId-1072483"></A>
&lt;options xmlns=&quot;http://marklogic.com/appservices/search&quot;&gt;
&#160;&#160;&lt;constraint name=&quot;my-value&quot;&gt;
    &lt;value&gt;
      &lt;element ns=&quot;my-namespace&quot; name=&quot;my-localname&quot;/&gt;
    &lt;/value&gt;
&#160;&#160;&lt;/constraint&gt;
&lt;/options&gt;</Code>
<CellBody>
<A ID="pgfId-1072456"></A>
For more details, see <A href="search-api.xml#id(73121)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Value Constraint Example' on page&#160;26</A></CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="2" COLSPAN="1">
<CellBody>
<A ID="pgfId-1061152"></A>
<code>
word</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1061154"></A>
Constrains on a word-query of either <code>
element</code>
, <code>
attribute</code>
, or <code>
field</code>
. </CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1061156"></A>
<code>
cts:element-word-query</code>
, <code>
cts:element-attribute-
&#160;&#160;word-query</code>
, <code>
cts:field-word-query</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1071032"></A>
No facets for word constraints.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="3">
<CellBody>
<A ID="pgfId-1072532"></A>
Example <code>
word</code>
 constraint:</CellBody>
<Code>
<A ID="pgfId-1072533"></A>
&lt;options xmlns=&quot;http://marklogic.com/appservices/search&quot;&gt;
&#160;&#160;&lt;constraint name=&quot;name&quot;&gt;
    &lt;word&gt;
      &lt;element ns=&quot;http://authors-r-us.com&quot; name=&quot;name&quot;/&gt;
    &lt;/word&gt;
&#160;&#160;&lt;/constraint&gt;
&lt;/options&gt;</Code>
<CellBody>
<A ID="pgfId-1072537"></A>
For more details, see <A href="search-api.xml#id(39116)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Word Constraint Examples' on page&#160;27</A></CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="2" COLSPAN="1">
<CellBody>
<A ID="pgfId-1061158"></A>
<code>
collection</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1061160"></A>
Requires the collection lexicon to be enabled in the database. </CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1061162"></A>
<code>
cts:collection-query</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1071110"></A>
<code>
cts:collections</code>
</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="3">
<CellBody>
<A ID="pgfId-1072587"></A>
Example <code>
collection</code>
 constraint:</CellBody>
<Code>
<A ID="pgfId-1072588"></A>
&lt;options xmlns=&quot;http://marklogic.com/appservices/search&quot;&gt;
&#160;&#160;&lt;constraint name=&quot;subject&quot;&gt;
&#160;&#160;&#160;&#160;&lt;collection prefix=&quot;/my-collections/&quot;/&gt;
&#160;&#160;&lt;/constraint&gt;
&lt;/options&gt;</Code>
<CellBody>
<A ID="pgfId-1072592"></A>
For more details, see <A href="search-api.xml#id(87303)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Collection Constraint Example' on page&#160;27</A></CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1061164"></A>
<code>
range</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1061166"></A>
Requires the underlying range index to exist in the database. All range constraints are type aware for the element or attribute values, and the constraint can optionally include either <code>
bucket</code>
 or <code>
computed-bucket</code>
 elements. For examples, see <A href="search-api.xml#id(25290)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Bucketed Range Constraint Example' on page&#160;28</A>, <A href="search-api.xml#id(13330)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Buckets Example' on page&#160;51</A>, and <A href="search-api.xml#id(22725)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Computed Buckets Example' on page&#160;53</A>. </CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1061168"></A>
The lexicon APIs, such as <code>
cts:element-range-query</code>
 and <code>
cts:element-attribute-
&#160;&#160;range-query</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1071135"></A>
<code>
cts:element-values</code>
, <code>
cts:element-attribute-
&#160;&#160;values</code>
, 
<code>
cts:element-value-
&#160;&#160;ranges</code>
,
<code>
cts:element-attribute-
&#160;&#160;value-ranges</code>
</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="2" COLSPAN="1">
<CellBody>
<A ID="pgfId-1079300"></A>
<code>
element-query</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1079302"></A>
Restricts qtext to a particular cts:element-query. Requires position indexes enabled on the database for the best performancce. </CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1079304"></A>
<code>
cts:element-query</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1079334"></A>
No facets for element-query constraints.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="3">
<CellBody>
<A ID="pgfId-1079310"></A>
Example <code>
element-query</code>
 constraint:</CellBody>
<Code>
<A ID="pgfId-1079311"></A>
&lt;options xmlns=&quot;http://marklogic.com/appservices/search&quot;&gt;
&#160;&#160;&lt;constraint name=&quot;sample-element-constraint&quot;&gt;
&#160;&#160;&#160;&#160;&lt;element-query name=&quot;title&quot; ns=&quot;http://my/namespace&quot; /&gt;
&#160;&#160;&lt;/constraint&gt;
&lt;/options&gt;</Code>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="2" COLSPAN="1">
<CellBody>
<A ID="pgfId-1079248"></A>
<code>
properties</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1079250"></A>
Finds matches on the corresponding properties documents.</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1079252"></A>
<code>
cts:properties-query</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1079348"></A>
No facets for properties constraints.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="3">
<CellBody>
<A ID="pgfId-1079258"></A>
Example <code>
element-query</code>
 constraint:</CellBody>
<Code>
<A ID="pgfId-1079259"></A>
&lt;options xmlns=&quot;http://marklogic.com/appservices/search&quot;&gt;
&#160;&#160;&lt;constraint name=&quot;sample-property-constraint&quot;&gt;
&#160;&#160;&#160;&#160;&lt;properties /&gt;
&#160;&#160;&lt;/constraint&gt;
&lt;/options&gt;</Code>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1061259"></A>
<code>
custom</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1061261"></A>
Create your own type of constraint by implementing your own functions for parsing and for creating facets. For an example, see <A href="search-api.xml#id(49750)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Creating a Custom Constraint' on page&#160;40</A>.</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1061263"></A>
Depends on what your custom code implements</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1071169"></A>
Depends on what your custom code implements</CellBody>
</CELL>
</ROW>
</TABLE>
<Body>
<A ID="pgfId-1062012"></A>
Constraints are designed to be fast. When they have facets, they must generate fast and accurate counts and distinct values. Therefore the constraints that allow facets require a range index on the element or attribute on which they apply, or require a particular lexicon to exist in the database. Other constraints (<code>
value</code>
 and <code>
word</code>
 constraints) do not require any special indexing, and they cannot be used to create facets.</Body>
<Body>
<A ID="pgfId-1067688"></A>
When the Search API parses a constraint (using <code>
search:parse</code>
 or <code>
search:search</code>
 for example), it looks for the joiner string and then applies the value to the right of the joiner string, parsing the value as a <code>
cts:query</code>
. If the constraint is not defined in your options node, then the Search API treats the joiner string as part of the whitespace-separated string. For example:</Body>
<Code>
<A ID="pgfId-1067768"></A>
search:parse('unrecognized-constraint:hello')
=&gt; 
&lt;cts:word-query qtextref=&quot;cts:text&quot;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;xmlns:cts=&quot;http://marklogic.com/cts&quot;&gt;
&#160;&#160;&#160;&lt;cts:text&gt;unrecognized-constraint:hello&lt;/cts:text&gt;
&lt;/cts:word-query&gt;</Code>
<Body>
<A ID="pgfId-1071224"></A>
If the constraint is not defined and your options node and the value is quoted text, then the Search API ignores the constraint and the joiner when parsing the query, but saves the original text as an attribute. For example:</Body>
<Code>
<A ID="pgfId-1067834"></A>
search:parse('unrecognized-constraint:&quot;hello world&quot;')
=&gt;
&lt;cts:word-query qtextpre=&quot;unrecognized-constraint:&amp;quot;&quot;
&#160;&#160;&#160;&#160;&#160;qtextref=&quot;cts:text&quot; qtextpost=&quot;&amp;quot;&quot;
&#160;&#160;&#160;&#160;&#160;xmlns:cts=&quot;http://marklogic.com/cts&quot;&gt;
&#160;&#160;&#160;&lt;cts:text&gt;hello world&lt;/cts:text&gt;
&lt;/cts:word-query&gt;</Code>
<Body>
<A ID="pgfId-1068352"></A>
The following examples show constraints of the following types:</Body>
<Body-bullet>
<A ID="pgfId-1068367"></A>
<A href="search-api.xml#id(73121)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Value Constraint Example</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1068377"></A>
<A href="search-api.xml#id(39116)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Word Constraint Examples</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1068384"></A>
<A href="search-api.xml#id(87303)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Collection Constraint Example</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1068391"></A>
<A href="search-api.xml#id(25290)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Bucketed Range Constraint Example</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1077644"></A>
<A href="search-api.xml#id(68918)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Exact Match (Unbucketed) Range Constraint Example</Hyperlink>
</A></Body-bullet>
<Body>
<A ID="pgfId-1068398"></A>
For an example of a custom constraint, see <A href="search-api.xml#id(49750)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Creating a Custom Constraint' on page&#160;40</A>.</Body>
<Heading-4>
<A ID="pgfId-1068423"></A>
<A ID="73121"></A>
Value Constraint Example</Heading-4>
<Body>
<A ID="pgfId-1068440"></A>
The following options node defines two value constraints: one for an element and one for an attribute.</Body>
<Code>
<A ID="pgfId-1068603"></A>
&lt;options xmlns=&quot;http://marklogic.com/appservices/search&quot;&gt;
&#160;&#160;&lt;constraint name=&quot;my-value&quot;&gt;
    &lt;value&gt;
      &lt;element ns=&quot;my-namespace&quot; name=&quot;my-localname&quot;/&gt;
    &lt;/value&gt;
&#160;&#160;&lt;/constraint&gt; 
&#160;&#160;&lt;constraint name=&quot;my-attribute-value&quot;&gt;
    &lt;value&gt;
      &lt;attribute ns=&quot;&quot; name=&quot;my-attribute&quot;/&gt;
      &lt;element ns=&quot;my-namespace&quot; name=&quot;my-localname&quot;/&gt;
    &lt;/value&gt;
&#160;&#160;&lt;/constraint&gt;
&lt;/options&gt;</Code>
<Body>
<A ID="pgfId-1068763"></A>
Using these constraints, you can issue query text such as the following (from <code>
search:search</code>
 or <code>
search:parse</code>
, for example) to use these constraints:</Body>
<Code>
<A ID="pgfId-1068773"></A>
my-value:&quot;This is an element value.&quot;
my-attribute-value:123456</Code>
<Body>
<A ID="pgfId-1071281"></A>
Both parts of the above query text would match the following document:</Body>
<Code>
<A ID="pgfId-1071292"></A>
&lt;my-document xmlns=&quot;my-namespace&quot;&gt;
&#160;&#160;&lt;my-localname&gt;This is an element value.&lt;/my-localname&gt;
&#160;&#160;&lt;my-localname my-attribute=&quot;123456&quot;&gt;
&lt;/my-document&gt;</Code>
<Heading-4>
<A ID="pgfId-1068433"></A>
<A ID="39116"></A>
Word Constraint Examples</Heading-4>
<Body>
<A ID="pgfId-1068454"></A>
The following options node defines two word constraints: one for a <code>
cts:element-word-query</code>
 and one for a <code>
cts:field-word-query</code>
:</Body>
<Code>
<A ID="pgfId-1068832"></A>
&lt;options xmlns=&quot;http://marklogic.com/appservices/search&quot;&gt;
&#160;&#160;&lt;constraint name=&quot;name&quot;&gt;
    &lt;word&gt;
      &lt;element ns=&quot;http://authors-r-us.com&quot; name=&quot;name&quot;/&gt;
    &lt;/word&gt;
&#160;&#160;&lt;/constraint&gt;
&#160;&#160;&lt;constraint name=&quot;description&quot;&gt;
    &lt;word&gt;
        &lt;field name=&quot;my-field&quot;/&gt;
    &lt;/word&gt;
&#160;&#160;&lt;/constraint&gt;
&lt;/options&gt;</Code>
<Body>
<A ID="pgfId-1068924"></A>
Using these constraints, you can issue query text such as the following (from <code>
search:search</code>
 or <code>
search:parse</code>
, for example) to use these constraints:</Body>
<Code>
<A ID="pgfId-1068925"></A>
name:raymond
description:author</Code>
<Body>
<A ID="pgfId-1071348"></A>
The first query text above would match the following document (because a <code>
cts:word-query(&quot;raymond&quot;)</code>
 would match):</Body>
<Code>
<A ID="pgfId-1071349"></A>
&lt;my-document xmlns=&quot;http://authors-r-us.com&quot;&gt;
&#160;&#160;&lt;name&gt;Raymond Carver&lt;/name&gt;
&lt;/my-document&gt;</Code>
<Body>
<A ID="pgfId-1076514"></A>
The second query text above matches the above document if the <code>
name</code>
 element was part of the field named <code>
my-field</code>
. For details on fields, see <A href="../admin/fields.xml#id(61682)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Fields Database Settings</Hyperlink>
</A> in the <Emphasis>
Administrator's Guide</Emphasis>
.</Body>
<Heading-4>
<A ID="pgfId-1068447"></A>
<A ID="87303"></A>
Collection Constraint Example</Heading-4>
<Body>
<A ID="pgfId-1068468"></A>
The following options node defines a collection constraint, which allows you to constrain your search to documents that are in a specified collection. To use this constraint, the collection lexicon must be enabled in the database, otherwise an exception is thrown. If <code>
prefix</code>
 is an attribute to the the <code>
collection</code>
 element in the constraint, then the collection name is derived from the <code>
prefix</code>
 concatenated with the constraint value. </Body>
<Body>
<A ID="pgfId-1071437"></A>
One use for a collection constraint is to allow faceted navigation based on collections. For example, if you have collections based on subjects (for example, one called <code>
history</code>
, one called <code>
math</code>
, and so on), then you can use a collection constraint to narrow the search to one of the subjects.</Body>
<Code>
<A ID="pgfId-1069011"></A>
&lt;options xmlns=&quot;http://marklogic.com/appservices/search&quot;&gt;
&#160;&#160;&lt;constraint name=&quot;subject&quot;&gt;
&#160;&#160;&#160;&#160;&lt;collection prefix=&quot;/my-collections/&quot;/&gt;
&#160;&#160;&lt;/constraint&gt;
&lt;/options&gt;</Code>
<Body>
<A ID="pgfId-1071459"></A>
Assuming that all documents in your database have collection URIs that begin with the string <code>
/my-collections/</code>
 like the following:</Body>
<Code>
<A ID="pgfId-1076559"></A>
<code>
/my-collections/</code>
math
<code>
/my-collections/</code>
economics
<code>
/my-collections/</code>
zoology</Code>
<Body>
<A ID="pgfId-1076545"></A>
Then the following query text examples will match documents in the corresponding collections:</Body>
<Code>
<A ID="pgfId-1071466"></A>
subject:math
subject:economics
subject:zoology</Code>
<Body>
<A ID="pgfId-1072819"></A>
If the database contains no documents in the specified collection, then the search returns no matches. For information on collections, see <A href="collections.xml#id(19337)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Collections' on page&#160;148</A>.</Body>
<Heading-4>
<A ID="pgfId-1068461"></A>
<A ID="25290"></A>
Bucketed Range Constraint Example</Heading-4>
<Body>
<A ID="pgfId-1068344"></A>
Range constraints operate on typed element or attribute values that have a corresponding range index in the database. Without the correct range index, range constraints will throw a runtime exception. Range constraint values can match on either all of the individual values for the element or attribute, or on specified <Emphasis>
buckets</Emphasis>
, which are named ranges of values. There are two types of buckets, specified with the <code>
bucket</code>
 and <code>
computed-bucket</code>
 elements in the <code>
range</code>
 constraint specification. The <code>
bucket</code>
 specification takes absolute ranges, and the <code>
computed-bucket</code>
 specification takes ranges that are relative to a given time. For more information about <code>
computed-bucket</code>
 range constraints, see <A href="search-api.xml#id(22725)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Computed Buckets Example' on page&#160;53</A>.</Body>
<Body>
<A ID="pgfId-1072701"></A>
The following example uses <code>
search:parse</code>
 with an options node that contains a <code>
bucket</code>
 range constraint. The following example is generated from the Oscars sample application, built using Application Builder:</Body>
<Code>
<A ID="pgfId-1072879"></A>
xquery version &quot;1.0-ml&quot;;

import module namespace search = 
  &quot;http://marklogic.com/appservices/search&quot;
  at &quot;/MarkLogic/appservices/search/search.xqy&quot;;

search:parse('decade:1980s', 
&lt;options xmlns=&quot;http://marklogic.com/appservices/search&quot;&gt;</Code>
<Code>
<A ID="pgfId-1072880"></A>
  &lt;constraint name=&quot;decade&quot;&gt;
    &lt;range type=&quot;xs:gYear&quot; facet=&quot;true&quot;&gt;
      &lt;bucket lt=&quot;1930&quot; ge=&quot;1920&quot; name=&quot;1920s&quot;&gt;1920s&lt;/bucket&gt;
      &lt;bucket lt=&quot;1940&quot; ge=&quot;1930&quot; name=&quot;1930s&quot;&gt;1930s&lt;/bucket&gt;
      &lt;bucket lt=&quot;1950&quot; ge=&quot;1940&quot; name=&quot;1940s&quot;&gt;1940s&lt;/bucket&gt;
      &lt;bucket lt=&quot;1960&quot; ge=&quot;1950&quot; name=&quot;1950s&quot;&gt;1950s&lt;/bucket&gt;
      &lt;bucket lt=&quot;1970&quot; ge=&quot;1960&quot; name=&quot;1960s&quot;&gt;1960s&lt;/bucket&gt;
      &lt;bucket lt=&quot;1980&quot; ge=&quot;1970&quot; name=&quot;1970s&quot;&gt;1970s&lt;/bucket&gt;
      &lt;bucket lt=&quot;1990&quot; ge=&quot;1980&quot; name=&quot;1980s&quot;&gt;1980s&lt;/bucket&gt;
      &lt;bucket lt=&quot;2000&quot; ge=&quot;1990&quot; name=&quot;1990s&quot;&gt;1990s&lt;/bucket&gt;
      &lt;bucket ge=&quot;2000&quot; name=&quot;2000s&quot;&gt;2000s&lt;/bucket&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;facet-option&gt;limit=10&lt;/facet-option&gt;
      &lt;attribute ns=&quot;&quot; name=&quot;year&quot;/&gt;
      &lt;element ns=&quot;http://marklogic.com/wikipedia&quot; name=&quot;nominee&quot;/&gt;
    &lt;/range&gt;
  &lt;/constraint&gt;
&lt;/options&gt;)</Code>
<Body>
<A ID="pgfId-1068141"></A>
This query returns the following <code>
cts:query</code>
:</Body>
<Code>
<A ID="pgfId-1068162"></A>
&lt;cts:and-query qtextconst=&quot;decade:1980s&quot;
&#160;&#160;&#160;&#160;xmlns:cts=&quot;http://marklogic.com/cts&quot;&gt;
  &lt;cts:element-attribute-range-query qtextconst=&quot;decade:1980s&quot;
&#160;&#160;&#160;&#160;&#160;&#160;operator=&quot;&amp;gt;=&quot;&gt;
    &lt;cts:element xmlns:_1=&quot;http://marklogic.com/wikipedia&quot;&gt;
&#160;&#160;&#160;&#160;&#160;_1:nominee&lt;/cts:element&gt;
    &lt;cts:attribute&gt;year&lt;/cts:attribute&gt;
    &lt;cts:value xsi:type=&quot;xs:gYear&quot;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;
&#160;&#160;&#160;&#160;1980&lt;/cts:value&gt;
  &lt;/cts:element-attribute-range-query&gt;
  &lt;cts:element-attribute-range-query qtextconst=&quot;decade:1980s&quot;
&#160;&#160;&#160;&#160;operator=&quot;&amp;lt;&quot;&gt;
    &lt;cts:element xmlns:_1=&quot;http://marklogic.com/wikipedia&quot;&gt;
&#160;&#160;&#160;&#160;&#160;_1:nominee&lt;/cts:element&gt;
    &lt;cts:attribute&gt;year&lt;/cts:attribute&gt;
    &lt;cts:value xsi:type=&quot;xs:gYear&quot;
&#160;&#160;&#160;&#160;&#160;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;
&#160;&#160;&#160;&#160;&#160;1990&lt;/cts:value&gt;
  &lt;/cts:element-attribute-range-query&gt;
&lt;/cts:and-query&gt;</Code>
<Body>
<A ID="pgfId-1070134"></A>
See the Oscars sample application that you generate from Application Builder for sample data against which you can run this query. For other range constraint examples, see <A href="search-api.xml#id(13330)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Buckets Example' on page&#160;51</A> and <A href="search-api.xml#id(22725)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Computed Buckets Example' on page&#160;53</A>, and the following example.</Body>
<Heading-4>
<A ID="pgfId-1077630"></A>
<A ID="68918"></A>
Exact Match (Unbucketed) Range Constraint Example</Heading-4>
<Body>
<A ID="pgfId-1077436"></A>
The following example shows an exact match year range constraint against the Oscars sample application. It returns results that match the year 1964. To see the output, run this query against the Oscars database.</Body>
<Code>
<A ID="pgfId-1077465"></A>
xquery version &quot;1.0-ml&quot;;

import module namespace search = 
  &quot;http://marklogic.com/appservices/search&quot;
  at &quot;/MarkLogic/appservices/search/search.xqy&quot;;

let $options :=
&lt;options xmlns=&quot;http://marklogic.com/appservices/search&quot;&gt;
  &lt;constraint name=&quot;year&quot;&gt;
   &lt;range type=&quot;xs:gYear&quot; facet=&quot;true&quot;&gt;
   &lt;facet-option&gt;limit=10&lt;/facet-option&gt;
   &lt;attribute ns=&quot;&quot; name=&quot;year&quot;/&gt;
   &lt;element ns=&quot;http://marklogic.com/wikipedia&quot; 
            name=&quot;nominee&quot;/&gt;
   &lt;/range&gt;
  &lt;/constraint&gt;
&lt;/options&gt;
return 
search:search(&quot;year:1964&quot;, $options)</Code>
<Heading-3>
<A ID="pgfId-1059526"></A>
<A ID="30002"></A>
Operator Options</Heading-3>
<Body>
<A ID="pgfId-1059540"></A>
Search operators allow you to specify in the search grammar operators to provide runtime, user-controlled configuration and search choices. A typical search operator might control sorting, thereby allowing the user to specify the sort order directly in the query text. For example, you might have an operator named <code>
sort</code>
 that allows you to sort by relevance or by date, with the following options XML:</Body>
<Code>
<A ID="pgfId-1062281"></A>
&lt;options xmlns=&quot;http://marklogic.com/appservices/search&quot;&gt;
&#160;&lt;search:operator name=&quot;sort&quot;&gt;
&#160;&#160;&#160;&lt;search:state name=&quot;relevance&quot;&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;search:sort-order&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;search:score/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;/search:sort-order&gt;
&#160;&#160;&#160;&lt;/search:state&gt;
&#160;&#160;&#160;&lt;search:state name=&quot;date&quot;&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;search:sort-order direction=&quot;descending&quot; type=&quot;xs:dateTime&quot;&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;search:element ns=&quot;my-ns&quot; name=&quot;date&quot;/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;/search:sort-order&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;search:sort-order&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;search:score/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;/search:sort-order&gt;
&#160;&#160;&#160;&lt;/search:state&gt;
&#160;&lt;/search:operator&gt;
&lt;/options&gt;</Code>
<Body>
<A ID="pgfId-1062486"></A>
This operator options XML allows you to add text like the following to the search string, and the Search API will parse the string and sort it according to the operator specification.</Body>
<Code>
<A ID="pgfId-1062970"></A>
sort:date</Code>
<Code>
<A ID="pgfId-1062971"></A>
sort:relevance</Code>
<Body>
<A ID="pgfId-1075896"></A>
Each operator is named, and the name must be unique across all operators and constraints in your options node. When you specify an operator as query text in a Search API call, you use the name as an operator in the search grammar followed by the <code>
apply=&quot;constraint&quot;</code>
 <Emphasis>
joiner</Emphasis>
 string (a colon character [<code>
:</code>
] by default). The joiner string joins the operator (or the constraint) with its value. For example, the following query text:</Body>
<Code>
<A ID="pgfId-1073019"></A>
<code>
sort:date</code>
 </Code>
<Body>
<A ID="pgfId-1073027"></A>
specifies using the operator named <code>
sort</code>
 with a value of <code>
date</code>
. </Body>
<Body>
<A ID="pgfId-1073045"></A>
The following figure shows each portion of the operator query text:</Body>
<Body>
<A ID="pgfId-1073061"></A>
<IMAGE xml:link="simple" href="search-api-3.gif" show="embed" actuate="auto"/>
</Body>
<Body>
<A ID="pgfId-1073037"></A>
For more details about the search grammar, see <A href="search-api.xml#id(41745)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Automatic Query Text Parsing and Grammar' on page&#160;16</A> and <A href="search-api.xml#id(44520)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Modifying and Extending the Search Parsing Grammar' on page&#160;49</A>.</Body>
<Body>
<A ID="pgfId-1062637"></A>
The <code>
search:state</code>
 options element is a child of the <code>
search:operator</code>
 element, and the following options XML elements are allowed as a child of <code>
search:state</code>
 element:</Body>
<Body-bullet>
<A ID="pgfId-1062648"></A>
<code>
additional-query</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1062670"></A>
<code>
debug</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1062691"></A>
<code>
forest</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1062703"></A>
<code>
page-length</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1062715"></A>
<code>
quality-weight</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1062727"></A>
<code>
searchable-expression</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1062739"></A>
<code>
sort-order</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1062751"></A>
<code>
transform-results</code>
</Body-bullet>
<Body>
<A ID="pgfId-1073104"></A>
Operators use the same syntax as constraints, but control other aspects of the search (for example, the sort order) besides which results are returned. </Body>
<Heading-3>
<A ID="pgfId-1059251"></A>
<A ID="97754"></A>
Return Options</Heading-3>
<Body>
<A ID="pgfId-1061691"></A>
You can specify a number of options that control what is returned from the Search API. These include the following boolean options:</Body>
<Body-bullet>
<A ID="pgfId-1061701"></A>
<code>
&lt;return-constraints&gt;</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1061732"></A>
<code>
&lt;return-facets&gt;</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1061751"></A>
<code>
&lt;return-metrics&gt;</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1061763"></A>
<code>
&lt;return-qtext&gt;</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1061775"></A>
<code>
&lt;return-query&gt;</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1061787"></A>
<code>
&lt;return-results&gt;</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1061799"></A>
<code>
&lt;return-similar&gt;</code>
</Body-bullet>
<Body>
<A ID="pgfId-1061708"></A>
Setting each option to <code>
true</code>
 returns the specified option in the <code>
search:search</code>
 response element, setting to <code>
false</code>
 omits them from the response. For example, the following specifies to return query statistics and facets in the result, but not to return the search hits:</Body>
<Code>
<A ID="pgfId-1061876"></A>
&lt;options xmlns=&quot;http://marklogic.com/appservices/search&quot;&gt;
&#160;&#160;&#160;&lt;return-metrics&gt;true&lt;/return-metrics&gt;
&#160;&#160;&#160;&lt;return-facets&gt;true&lt;/return-facets&gt;
&#160;&#160;&#160;&lt;return-results&gt;false&lt;/return-results&gt;
&lt;/options&gt;</Code>
<Body>
<A ID="pgfId-1061869"></A>
Only the needed parts of the response are computed, so if you do not return results (as in the above example) or do not return something else, then the work needed to perform that part of the response is not done, and the search runs faster.</Body>
<Body>
<A ID="pgfId-1061969"></A>
For details on each return option, including their default values, see the <code>
search:search</code>
 function documentation in <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
.</Body>
<Heading-3>
<A ID="pgfId-1061677"></A>
<A ID="43671"></A>
Searchable Expression Option</Heading-3>
<Body>
<A ID="pgfId-1062046"></A>
Use the <code>
&lt;searchable-expression&gt;</code>
 option to specify what expression to search over and what is returned in the search results. The expression corresponds to the first parameter to <code>
cts:search</code>
, and must be a fully searchable expression. For details on fully searchable expressions, see <A href="../performance/query_meters.xml#id(17135)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Fully Searchable Paths and cts:search Operations</Hyperlink>
</A> in <Emphasis>
Query Performance and Tuning Guide</Emphasis>
. </Body>
<Body>
<A ID="pgfId-1062073"></A>
By default, the Search API searches over the whole database (<code>
fn:collection()</code>
). In most cases, your searchable-expression should search over fragment roots, although searching below fragment roots is allowed.</Body>
<Body>
<A ID="pgfId-1062093"></A>
The following example shows a searchable expression that searches over both CITATION elements and html elements:</Body>
<Code>
<A ID="pgfId-1062106"></A>
&lt;searchable-expression xmlns:xh=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&#160;&#160;&#160;&#160;/(xh:html | CITATION) 
&lt;/searchable-expression&gt;</Code>
<Body>
<A ID="pgfId-1062146"></A>
If an expression is not fully searchable, it will throw an <code>
XDMP-UNSEARCHABLE</code>
 exception at runtime.</Body>
<Heading-3>
<A ID="pgfId-1062036"></A>
<A ID="58295"></A>
Modifying Your Snippet Results</Heading-3>
<Body>
<A ID="pgfId-1072227"></A>
The <code>
transform-results</code>
 option allows you to specify options for the <Emphasis>
snippet</Emphasis>
 code for your application. A <Emphasis>
snippet</Emphasis>
 is the search result blurb (an abbreviated and highlighted summary) that typically comes up in search results. A snippet is created by taking the matching search result node and running it through transformation code. The transformation typically displays the portion of the result you want in your results page, perhaps highlighting the query matches and showing some text around it, often discarding the rest of the result. This section describes the following ways to control and modify the snippet results from the Search API:</Body>
<Body-bullet>
<A ID="pgfId-1073205"></A>
<A href="search-api.xml#id(36346)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Specifying transform-results Options</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1073215"></A>
<A href="search-api.xml#id(61707)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Specifying Your Own Code in transform-results</Hyperlink>
</A></Body-bullet>
<Heading-4>
<A ID="pgfId-1073191"></A>
<A ID="36346"></A>
Specifying transform-results Options</Heading-4>
<Body>
<A ID="pgfId-1073198"></A>
By default, the Search API has its own code to take search result matches and transform them into snippets used in the search results. By default, the Search API uses the <code>
apply=&quot;snippet&quot;</code>
 attribute on the <code>
transform-results</code>
 option. Snippets tend to be very application specific, and the built-in <code>
apply=&quot;snippet&quot;</code>
 option has several parameters that you can control with a <code>
transform-results</code>
 options node. </Body>
<Body>
<A ID="pgfId-1073296"></A>
The following is the default <code>
transform-results</code>
 options node:</Body>
<Code>
<A ID="pgfId-1073304"></A>
&lt;transform-results apply=&quot;snippet&quot;&gt;
    &lt;per-match-tokens&gt;30&lt;/per-match-tokens&gt;
    &lt;max-matches&gt;4&lt;/max-matches&gt;
    &lt;max-snippet-chars&gt;200&lt;/max-snippet-chars&gt;
    &lt;preferred-elements/&gt;
&lt;/transform-results&gt;</Code>
<Body>
<A ID="pgfId-1073460"></A>
The following table describes the <code>
transform-results</code>
 options when <code>
apply=&quot;snippet&quot;</code>
, each of which is configurable at search runtime by specifying your own values for the options:</Body>
<TableAnchor>
<A ID="pgfId-1073470"></A>
</TableAnchor>
<TABLE>
<ROW>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1073477"></A>
<code>
transform-results</code>
 Child Element</CellHeading>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1073479"></A>
Description</CellHeading>
</TH>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CodeLeft>
<A ID="pgfId-1073481"></A>
per-match-tokens</CodeLeft>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1073483"></A>
Maximum number of tokens (typically words) per matching node that surround the highlighted term(s) in the snippet.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CodeLeft>
<A ID="pgfId-1073485"></A>
max-matches</CodeLeft>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1073487"></A>
The maximum number of nodes containing a highlighted term that will display in the snippet.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CodeLeft>
<A ID="pgfId-1073489"></A>
max-snippet-chars</CodeLeft>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1073491"></A>
Limit total snippet size to this many characters.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CodeLeft>
<A ID="pgfId-1073493"></A>
preferred-elements</CodeLeft>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1073495"></A>
Specify zero or more elements that the snippet algorithm looks in first to find matches. For example, if you want any matches in the <code>
TITLE</code>
 element to take preference, specify <code>
TITLE</code>
 as a preferred element as in the following sample:</CellBody>
<Code>
<A ID="pgfId-1073556"></A>
&lt;transform-results apply=&quot;snippet&quot;&gt;
&#160;&#160;&lt;preferred-elements&gt;
&#160;&#160;&#160;&#160;&lt;element ns=&quot;&quot; name=&quot;TITLE&quot;/&gt;
&#160;&#160;&lt;/preferred-elements&gt;
&lt;/transform-results&gt;</Code>
</CELL>
</ROW>
</TABLE>
<Body>
<A ID="pgfId-1073298"></A>
There are also two other built-in snippetting options, which are exposed as attributes on the <code>
transform-results</code>
 options node:</Body>
<Body-bullet>
<A ID="pgfId-1073958"></A>
<code>
apply=&quot;raw&quot;</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1073987"></A>
<code>
apply=&quot;empty-snippet&quot;</code>
</Body-bullet>
<Body>
<A ID="pgfId-1073965"></A>
The <code>
apply=&quot;raw&quot;</code>
 snippetting option looks as follows:</Body>
<Code>
<A ID="pgfId-1073872"></A>
&lt;transform-results apply=&quot;raw&quot; /&gt;</Code>
<Body>
<A ID="pgfId-1073879"></A>
The <code>
apply=&quot;raw&quot;</code>
 option returns the whole node (with <Emphasis>
no</Emphasis>
 highlighting) in the <code>
search:response</code>
 output. You can then take the node and do your own transformation on it, or just return it as-is, or whatever else makes sense for your application.</Body>
<Body>
<A ID="pgfId-1073951"></A>
The <code>
apply=&quot;empty-snippet&quot;</code>
 snippetting option is as follows:</Body>
<Code>
<A ID="pgfId-1073860"></A>
&lt;transform-results apply=&quot;empty-snippet&quot; /&gt;</Code>
<Body>
<A ID="pgfId-1073905"></A>
The <code>
apply=&quot;empty-snippet&quot;</code>
 option returns no result node, but does return an empty <code>
search:snippet</code>
 element for each <code>
search:result</code>
. The <code>
search:result</code>
 wrapper element does have the information (for example, the URI and path to the node) needed to access the node and perform your own transformation on the matching search node(s), so you can write your own code outside of the Search API to process the results.</Body>
<Heading-4>
<A ID="pgfId-1073846"></A>
<A ID="61707"></A>
Specifying Your Own Code in transform-results</Heading-4>
<Body>
<A ID="pgfId-1073171"></A>
If the default snippet code does not meet your application requirements, you can use your own snippet code to use for a given search. </Body>
<Body>
<A ID="pgfId-1073127"></A>
To specify your own snippet code, use the design pattern described in <A href="search-api.xml#id(28383)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Search Customization Via Options and Extensions' on page&#160;19</A>. The function you implement must have a signature compatible with the following signature:</Body>
<Code>
<A ID="pgfId-1073141"></A>
declare function search:snippet(
&#160;&#160;&#160;$result as node(),
&#160;&#160;&#160;$ctsquery as schema-element(cts:query),
&#160;&#160;&#160;$options as element(search:transform-results)?
) as element(search:snippet)</Code>
<Body>
<A ID="pgfId-1073152"></A>
The Search API will pass the function the result node and the <code>
cts:query</code>
 XML representation and your custom function can transform it any way you see fit. An options node that specifies a custom transformation looks as follows:</Body>
<Code>
<A ID="pgfId-1073423"></A>
&lt;options xmlns=&quot;http://marklogic.com/appservices/search&quot;&gt;
&#160;&#160;&lt;transform-results apply=&quot;my-snippet&quot; ns=&quot;my-namespace&quot;
&#160;&#160;&#160;&#160;&#160;&#160;at=&quot;/my-snippet.xqy&quot;&gt;
&#160;&#160;&lt;/transform-results&gt;
&lt;/options&gt;</Code>
<Body>
<A ID="pgfId-1073412"></A>
If you create a custom function, you can optionally pass in options to your function by adding them as children of the <code>
transform-results</code>
 option. The Search API will pass the <code>
transform-results</code>
 element into your function, and if you want to use any part of the option, you can write code to parse the option and extract whatever you need from it.</Body>
<Heading-3>
<A ID="pgfId-1072216"></A>
<A ID="32762"></A>
Other Search Options</Heading-3>
<Body>
<A ID="pgfId-1071637"></A>
There are several other options in the Search API, including <code>
additional-query</code>
 (an additional <code>
cts:query</code>
 combined as an and-query to the active query in your search), <code>
term-option</code>
 (pass any of the <code>
cts:query</code>
 options such as <code>
case-sensitive</code>
 to your <code>
cts:query</code>
), and others. For details on what the other options do, see the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
.</Body>
<Heading-2>
<A ID="pgfId-1071626"></A>
<A ID="95581"></A>
Generating Search API Options with Application Builder</Heading-2>
<Body>
<A ID="pgfId-1059271"></A>
Application Builder uses the Search API in the applications it generates. It provides an easy-to-use user interface to build constraints and facets, and you can use it to help you construct a search options XML node. It cannot construct all kinds of options nodes, but you can often use it as a starting point for an options node that you can modify later. To view the options XML node for the current application in Application Builder, select Application Configuration from the menu with your application name (towards the upper-right corner of Application Builder).</Body>
<Body>
<A ID="pgfId-1062208"></A>
<IMAGE xml:link="simple" href="images/export-proj.gif" show="embed" actuate="auto"/>
</Body>
<Body>
<A ID="pgfId-1062237"></A>
The Application Configuration XML displays in a browser window, and one of the elements is the <code>
search:options</code>
 node for that application. You can use that options node in a Search API call to run searches with the configuration you created using Application Builder.</Body>
<Body>
<A ID="pgfId-1062180"></A>
For details on Application Builder, see the <Emphasis>
Application Builder Developer's Guide</Emphasis>
.</Body>
<Heading-2>
<A ID="pgfId-1075027"></A>
<A ID="34509"></A>
Search Term Completion Using search:suggest</Heading-2>
<Body>
<A ID="pgfId-1075028"></A>
The <code>
search:suggest</code>
 function returns suggestions that match a wildcarded string, and it is used in query-completion applications. For an example of an application that uses search:suggest, see the Oscars sample application that you can generate with Application Builder, as described in <A href="../appbuilder/intro.xml#id(21750)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Building the Oscars Sample Application</Hyperlink>
</A> in the <Emphasis>
Application Builder Developer's Guide</Emphasis>
.</Body>
<Body>
<A ID="pgfId-1075038"></A>
A typical way to use the <code>
search:suggest</code>
 function in an application is to have a Javascript event listen for changes in the text box, and then upon those changes it asynchronously submits a <code>
search:suggest</code>
 call to MarkLogic Server. The result is that, after every letter is typed in, new suggestions appear in the user interface. The remainder of this sections describes the following details of the search:suggest function:</Body>
<Body-bullet>
<A ID="pgfId-1075045"></A>
<A href="search-api.xml#id(89118)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
default-suggestion-source Option</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1076720"></A>
<A href="search-api.xml#id(40748)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Choose Suggestions With the suggestion-source Option</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1075049"></A>
<A href="search-api.xml#id(91911)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Use Multiple Query Text Inputs to search:suggest</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1075053"></A>
<A href="search-api.xml#id(89196)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Make Suggestions Based on Cursor Position</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1077359"></A>
<A href="search-api.xml#id(87889)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
search:suggest Examples</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1075055"></A>
<A ID="89118"></A>
default-suggestion-source Option</Heading-3>
<Body>
<A ID="pgfId-1075056"></A>
To use <code>
search:suggest</code>
, it is best to specify a <code>
default-suggestion-source</code>
. The Search API uses the <code>
default-suggestion-source</code>
 to look for search term suggestions. If no <code>
default-suggestion-source </code>
is specified, then any call to <code>
search:suggest</code>
 returns only suggestions for constraints and operators, or if there are none, then it returns the empty sequence. The <code>
search:suggest</code>
 function suggests constraint and operator names if they match the query text string, and in the case of range index-based constraints, it will suggest matching constraint values. For details on the syntax of the <code>
default-suggestion-source</code>
 option, see the <code>
search:search</code>
 options documentation in the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
.</Body>
<Body>
<A ID="pgfId-1075060"></A>
For best performance, especially on large databases, use with a <code>
default-suggestion-source</code>
 with a <code>
range</code>
 or <code>
collection</code>
 instead of one with a <code>
word</code>
 lexicon. </Body>
<Body>
<A ID="pgfId-1075061"></A>
The following <code>
default-suggestion-source</code>
 example uses the string range index on the attribute named <code>
my-attribute</code>
 as a source for suggesting terms. Range suggestion sources tend to perform the best, especially for large databases. The range index must exist or an exception is thrown at search runtime.</Body>
<Code>
<A ID="pgfId-1075062"></A>
&lt;default-suggestion-source&gt;
  &lt;range type=&quot;xs:string&quot;&gt;
    &lt;element ns=&quot;my-namespace&quot; name=&quot;my-localname&quot;/&gt;
    &lt;attribute ns=&quot;&quot; name=&quot;my-attribute&quot;/&gt;
   &lt;/range&gt;
&lt;/default-suggestion-source&gt; </Code>
<Body>
<A ID="pgfId-1075063"></A>
The following example specifies using a field lexicon to look for search term suggestions. Fields can work well for suggestion sources, especially if the field is a relatively small subset of the whole database. A field word lexicon for the specified field must exist or an exception is thrown at search runtime.</Body>
<Code>
<A ID="pgfId-1076682"></A>
&lt;default-suggestion-source&gt;
    &lt;word collation=&quot;http://marklogic.com/collation/&quot;&gt;
        &lt;field name=&quot;my-field&quot;/&gt;
    &lt;/word&gt;
&lt;/default-suggestion-source&gt;</Code>
<Heading-3>
<A ID="pgfId-1076684"></A>
<A ID="40748"></A>
Choose Suggestions With the suggestion-source Option</Heading-3>
<Body>
<A ID="pgfId-1076697"></A>
For some applications, you want to have a very specific list from which to choose suggestions for a particular constraint. For example, you might have a constraint named name that has millions of unique values, but perhaps you only want to make suggestions for a specific 500 of them. In such cases, you can specify the <code>
suggestion-source</code>
 option to override the suggestions that <code>
search:suggest</code>
 returns for query text matching values in that constraint.</Body>
<Body>
<A ID="pgfId-1076778"></A>
You specify the constraint to override in the in the <code>
name</code>
 attribute of the <code>
suggestion-source</code>
 element. For example, the following options specify to use the values from the <code>
short-list-name</code>
 element instead of from the <code>
name</code>
 element when make suggestions for the <code>
name</code>
 constraint.</Body>
<Code>
<A ID="pgfId-1076803"></A>
&lt;constraint name=&quot;name&quot;&gt;
   &lt;range collation=&quot;http://marklogic.com/collation&quot; 
          type=&quot;xs:string&quot; facet=&quot;true&quot;&gt;
      &lt;element ns=&quot;my-namespace&quot; name=&quot;fullname&quot;/&gt;
   &lt;/range&gt;
 &lt;/constraint&gt;
 &lt;suggestion-source name=&quot;name&quot;&gt;
     &lt;range collation=&quot;http://marklogic.com/collation&quot; 
          type=&quot;xs:string&quot; facet=&quot;true&quot;&gt;
      &lt;element ns=&quot;my-namespace&quot; name=&quot;short-list-name&quot;/&gt;
   &lt;/range&gt;
 &lt;/suggestion-source&gt;</Code>
<Body>
<A ID="pgfId-1076747"></A>
For cases where you have a named constraint to use for searching and facets, but might want to use a slightly (or completely) different source for type-ahead suggestions without needing to re-parse your search terms, use the <code>
suggestion-source</code>
 option. </Body>
<Body>
<A ID="pgfId-1077007"></A>
If you want a particular constraint to not return suggestion, add an empty <code>
suggestion-source</code>
 for that constraint:</Body>
<Code>
<A ID="pgfId-1077018"></A>
&lt;suggestion-source name=&quot;socialsecuritynumber&quot; /&gt;</Code>
<Heading-3>
<A ID="pgfId-1075069"></A>
<A ID="91911"></A>
Use Multiple Query Text Inputs to search:suggest</Heading-3>
<Body>
<A ID="pgfId-1075070"></A>
You can specify one or more query text parameters to <code>
search:suggest</code>
. When you specify a sequence of more than one query text for <code>
search:search</code>
, the first item (or the one corresponding to the <code>
$focus</code>
 parameter) specifies the text to match against the suggestion source. Each of the other items in the sequence is parsed as a <code>
cts:query</code>
, and that query is used to constrain the search suggestions from the text-matching query text. Note that this is different from the other Search API functions, which combine multiple query texts with a <code>
cts:and-query</code>
.</Body>
<Body>
<A ID="pgfId-1075071"></A>
Consider a user interface that looks as follows:</Body>
<Body>
<A ID="pgfId-1075080"></A>
<IMAGE xml:link="simple" href="search-api-5.gif" show="embed" actuate="auto"/>
</Body>
<Body>
<A ID="pgfId-1075081"></A>
The search text box on top is where the user types text. The lower check box might be another control that the user can use to specify the decade. The <code>
decade:1980s</code>
 text shown might be the query text that is the result of that user interface control (possibly from a facet, for example). You can then construct a <code>
search:suggest</code>
 call from this user interface that uses the <code>
decade:1980s</code>
 text as a constraint to the terms matching <code>
comp</code>
 (from the specified suggestion source). The following is a <code>
search:suggest</code>
 call that can be generated from this example:</Body>
<Code>
<A ID="pgfId-1075082"></A>
search:suggest((&quot;comp&quot;, &quot;decade:1980s&quot;), $options)</Code>
<Body>
<A ID="pgfId-1075083"></A>
This ends up returning suggestions that match <code>
comp*</code>
 on fragments that match <code>
search:parse(&quot;decade:1980s&quot;)</code>
. For example, it might return a sequence including the words <code>
competent</code>
, <code>
component</code>
, and <code>
computer</code>
.</Body>
<Heading-3>
<A ID="pgfId-1076708"></A>
<A ID="89196"></A>
Make Suggestions Based on Cursor Position</Heading-3>
<Body>
<A ID="pgfId-1076709"></A>
The <code>
search:suggest</code>
 function makes search suggestions based on the position of the cursor (which you specify with the <code>
$cursor-position</code>
 parameter. The idea is that when the user changes the cursor position, you should suggest terms based on where the user is currently entering text.</Body>
<Heading-3>
<A ID="pgfId-1077043"></A>
<A ID="87889"></A>
search:suggest Examples</Heading-3>
<Body>
<A ID="pgfId-1077057"></A>
The following are some example <code>
search:suggest</code>
 queries with sample output.</Body>
<Body>
<A ID="pgfId-1077081"></A>
Assume a constraint named filesize for the following example:</Body>
<Code>
<A ID="pgfId-1077110"></A>
query:suggest(&quot;fi&quot;, $options)

(: Returns the &quot;filesize&quot; constraint name first, followed 
&#160;&#160;&#160;by words from the default source of word suggestions:

&#160;&#160;(&quot;filesize:&quot;, &quot;field&quot;, &quot;file&quot;, &quot;fitness&quot;, &quot;five&quot;,) &#160;:)</Code>
<Body>
<A ID="pgfId-1077070"></A>
The following example shows how search:suggest works with bucketed <code>
range</code>
 constraints:</Body>
<Code>
<A ID="pgfId-1077207"></A>
(: Assume $options contains the following:
  &lt;constraint name=&quot;date&quot;&gt;
   &lt;range type=&quot;xs:dateTime&quot;&gt;
      &lt;bucket name=&quot;today&quot;&gt;
      &lt;bucket name=&quot;yesterday&quot;&gt;
      &lt;bucket name=&quot;thismonth&quot;&gt;
      &lt;bucket name=&quot;thisyear&quot;&gt;
...

:)
search:suggest(&quot;date:&quot;, $options)
(: bucket names from the &quot;date&quot; range constraint are 
&#160;&#160;&#160;used to create suggestions 

(&quot;date:thismonth&quot;, &quot;date:thisyear&quot;, &quot;date:today&quot;, &quot;date:yesterday&quot;) :)</Code>
<Heading-2>
<A ID="pgfId-1064269"></A>
<A ID="49750"></A>
Creating a Custom Constraint</Heading-2>
<Body>
<A ID="pgfId-1061581"></A>
By default, the Search API supports many, but not all, types of constraints. If you need to create a constraint for which there is not one pre-defined in the Search API, there is a mechanism to extend the Search API to use your own constraint type. This type of constraint, called a <code>
custom</code>
 constraint, requires you to write XQuery functions to implement your own custom parsing and to generate your own custom facets. You specify your function implementations in the options XML as follows:</Body>
<Code>
<A ID="pgfId-1076109"></A>
&lt;constraint name=&quot;my-custom&quot;&gt;
    &lt;custom facet=&quot;true&quot;&gt; &lt;!-- or false --&gt;
       &lt;parse apply=&quot;parse&quot; ns=&quot;...&quot; at=&quot;...&quot; /&gt;
       &lt;start-facet apply=&quot;start&quot; ns=&quot;...&quot; at=&quot;...&quot; /&gt;
       &lt;finish-facet apply=&quot;finish&quot; ns=&quot;...&quot; at=&quot;...&quot; /&gt;
    &lt;/custom&gt;
&lt;/constraint&gt;</Code>
<Body>
<A ID="pgfId-1076110"></A>
The three functions you need to implement are <code>
parse</code>
, <code>
start-facet</code>
, and <code>
finish-facet</code>
. The <code>
apply</code>
 attribute specifies the localname of the function, the <code>
ns</code>
 attribute specifies the namespace, and the <code>
at</code>
 attribute specifies the location of the module containing the function. This section describes how to create a custom constraint and includes some example code for creating a custom geospatial constraint. This section includes the following parts:</Body>
<Body-bullet>
<A ID="pgfId-1064649"></A>
<A href="search-api.xml#id(34004)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Implementing the parse Function</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1064663"></A>
<A href="search-api.xml#id(16978)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Implementing the start-facet Function</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1064670"></A>
<A href="search-api.xml#id(62713)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Implementing the finish-facet Function</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1078031"></A>
<A href="search-api.xml#id(43914)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Example: Creating a Simple Custom Constraint</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1064677"></A>
<A href="search-api.xml#id(66428)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Example: Creating a Custom Constraint Geospatial Facet</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1064684"></A>
<A ID="34004"></A>
Implementing the parse Function</Heading-3>
<Body>
<A ID="pgfId-1076139"></A>
The purpose of the <code>
parse</code>
 function is to parse the custom constraint and generate the correct <code>
cts:query</code>
 from the query text. The custom function you implement must have a signature compatible with the following signature:</Body>
<Code>
<A ID="pgfId-1065179"></A>
declare function geoexample:parse(
&#160;&#160;$constraint-qtext as xs:string, 
&#160;&#160;$right as schema-element(cts:query))
as schema-element(cts:query)</Code>
<Body>
<A ID="pgfId-1076150"></A>
You can use any namespace and localname for the function, but the number and order of the parameters must be compatible and the return type must be compatible. </Body>
<Body>
<A ID="pgfId-1065248"></A>
The <code>
$constraint-qtext</code>
 parameter is the constraint name and joiner part of the query text <Emphasis>
for the portion of the query pertaining to this constraint</Emphasis>
. For example, if the constraint name is <code>
geo</code>
 and the joiner is the default joiner, then the value of <code>
$constraint-qtext</code>
 will be <code>
geo:</code>
. The <code>
$constraint-qtext</code>
 value is used in the <code>
qtextconst</code>
 attribute, which is needed by <code>
search:unparse</code>
 to re-create the query text from the annotated <code>
cts:query</code>
.</Body>
<Body>
<A ID="pgfId-1065249"></A>
The <code>
$right</code>
 parameter contains the value of the constraint parsed as a <code>
cts:query</code>
. In other words, it is the text to the right of what is passed into <code>
$constraint-qtext</code>
 in the query text, and then that text is parsed by the Search API as a <code>
cts:query</code>
, and returned to the parse function as the XML representation of a <code>
cts:query</code>
. The value of <code>
$right</code>
 is what the parse function uses for generating its custom <code>
cts:query</code>
. For details on how <code>
cts:query</code>
 constructors work, see <A href="cts_query.xml#id(51991)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Composing cts:query Expressions' on page&#160;56</A>.</Body>
<Body>
<A ID="pgfId-1065348"></A>
The <code>
parse</code>
 function you implement takes the <code>
cts:query</code>
 from the <code>
$right</code>
 parameter, parses it as you see fit, and then returns a <code>
cts:query</code>
 XML element. For example, if the value of <code>
$right</code>
 is as follows:</Body>
<Code>
<A ID="pgfId-1065374"></A>
&lt;cts:word-query&gt;
&#160;&#160;&lt;cts:text&gt;1@2@3@4&lt;/cts:text&gt;
&lt;/cts:word-query&gt;</Code>
<Body>
<A ID="pgfId-1071684"></A>
Your code must process the <code>
cts:text</code>
 element to construct the cts:query you need. For example, you can tokenize on the <code>
@</code>
 character of the <code>
cts:text</code>
 element, then use each value to construct a part of the query. As part of constructing the <code>
cts:query</code>
, you can optionally add <code>
cts:annotation</code>
 elements and annotation attributes to the <code>
cts:query</code>
 you generate. These annotations allow the Search API to unparse the <code>
cts:query</code>
 back into its original form. If you do not add the proper annotations, then <code>
search:unparse</code>
 might not return the original query text. For a sample function that does something similar, see <A href="search-api.xml#id(66428)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Example: Creating a Custom Constraint Geospatial Facet' on page&#160;45</A>.</Body>
<Heading-3>
<A ID="pgfId-1064702"></A>
<A ID="16978"></A>
Implementing the start-facet Function</Heading-3>
<Body>
<A ID="pgfId-1070245"></A>
The sole purpose of the <code>
start-facet</code>
 function is to make a lexicon API call that returns the values and counts that are used in constructing a facet. For details on lexicons, see <A href="lexicon.xml#id(29002)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Browsing With Lexicons' on page&#160;80</A>. The custom function you implement must have a signature compatible with the following signature:</Body>
<Code>
<A ID="pgfId-1070249"></A>
declare function my-namespace:start-facet(
  $constraint as element(search:constraint), 
  $query as cts:query?, 
  $facet-options as xs:string*, 
  $quality-weight as xs:double?, 
  $forests as xs:unsignedLong*) 
as item()*</Code>
<Body>
<A ID="pgfId-1064826"></A>
You can use any namespace and localname for the function, but the number and order of the parameters must be compatible and the return type must be compatible. </Body>
<Body>
<A ID="pgfId-1064927"></A>
Each of the parameters is passed into the function by the Search API. The <code>
$query</code>
 parameter includes any custom query your <code>
parse</code>
 function implements, combined with any other query that the Search API generates (which depends on other options passed into the original search such as <code>
additional-query</code>
). All other parameters are specified in the <code>
search:options</code>
 XML node passed into the Search API call. You can choose to use them or not, as is needed to perform your custom action.</Body>
<Body>
<A ID="pgfId-1071789"></A>
When implementing a lexicon call in the <code>
start-facet</code>
 function, you must add the <code>
&quot;concurrent&quot;</code>
 option to the <code>
$facet-options</code>
 parameter and use the combined sequence as input to the <code>
$options</code>
 parameter of the lexicon API. The <code>
&quot;concurrent&quot;</code>
 option takes advantage of concurrency, and can greatly speed performance, especially for applications with many facets. For a sample function, see <A href="search-api.xml#id(66428)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Example: Creating a Custom Constraint Geospatial Facet' on page&#160;45</A>.</Body>
<Note>
<A ID="pgfId-1064981"></A>
The <code>
start-facet</code>
 function is optional, but is the recommended way to create a custom facet that uses any of the MarkLogic Server lexicon functions. If you do not use the <code>
start-facet</code>
 function, then the <code>
finish-facet</code>
 function must do all of the work to construct the facet (including constructing the values for the facet). For details on the lexicon functions, see the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
 and <A href="lexicon.xml#id(29002)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Browsing With Lexicons' on page&#160;80</A>.</Note>
<Heading-3>
<A ID="pgfId-1064715"></A>
<A ID="62713"></A>
Implementing the finish-facet Function</Heading-3>
<Body>
<A ID="pgfId-1076159"></A>
The <code>
finish-facet</code>
 function takes input from the <code>
start-facet</code>
 function (if it is used) and constructs the <code>
facet</code>
 element. This function must have a signature compatible with the following signature:</Body>
<Code>
<A ID="pgfId-1076160"></A>
declare function my-namespace:finish-facet(
&#160;&#160;$start as item()*, 
&#160;&#160;$constraint as element(search:constraint), 
  $query as cts:query?, 
  $facet-options as xs:string*, 
  $quality-weight as xs:double?, 
  $forests as xs:unsignedLong*) 
as element(search:facet)</Code>
<Body>
<A ID="pgfId-1065005"></A>
You can use any namespace and localname for the function, but the number and order of the parameters must be compatible and the return type must be compatible. </Body>
<Body>
<A ID="pgfId-1065006"></A>
The parameters are passed into the function by the Search API. The <code>
$query</code>
 parameter includes any custom query your <code>
parse</code>
 function implemented, combined with any other query that the Search API generates (which depends on other options passed in to the original search such as <code>
additional-query</code>
). All of the remaining parameters are specified in the <code>
search:options</code>
 XML passed into the Search API call. You can choose to use them or not, as is needed to perform your custom action. For a sample function, see <A href="search-api.xml#id(66428)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Example: Creating a Custom Constraint Geospatial Facet' on page&#160;45</A>.</Body>
<Body>
<A ID="pgfId-1065007"></A>
If you do not use a <code>
start-facet</code>
 function, then the empty sequence is passed in for the <code>
$start</code>
 parameter. If you are not using a <code>
start-facet</code>
 function, then the <code>
finish-facet</code>
 function is responsible for constructing the values and counts used in the facet, as well as creating the facet XML.</Body>
<Heading-3>
<A ID="pgfId-1064731"></A>
<A ID="43914"></A>
Example: Creating a Simple Custom Constraint</Heading-3>
<Body>
<A ID="pgfId-1078049"></A>
The following is a library module that implements a very simple custom constraint. This constraint adds a <code>
cts:directory-query</code>
 for the values specified in the constraint. This constraint has no facets, so it does not need the <code>
start-facet</code>
 and <code>
finish-facet</code>
 functions. This code does very minimal parsing; your actual code might parse the <code>
$right</code>
 query more carefully.</Body>
<Code>
<A ID="pgfId-1078506"></A>
xquery version &quot;1.0-ml&quot;;
module namespace my=&quot;my-namespace&quot;;

declare variable $prefix := &quot;/mydocs/&quot; ;

declare function part(
  $constraint-qtext as xs:string,
  $right as schema-element(cts:query)) 
as schema-element(cts:query)
{
&lt;root&gt;{
  let $s := fn:string($right//cts:text/text())
  let $dir :=
    if ( $s eq &quot;book&quot;)
    then fn:concat($prefix, &quot;book-dir/&quot;)
    else if ( $s eq &quot;api&quot;)
    then ( fn:concat($prefix, &quot;api-dir1/&quot;), 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fn:concat($prefix, &quot;api-dir2/&quot;) )
&#160;&#160;&#160;&#160;(: if it does not match, just constrain on the prefix :)
    else $prefix
  return
&#160;&#160;(: make these an or-query so you can look through several dirs :)
    cts:or-query((
    for $x in $dir 
    return 
      cts:directory-query($x, &quot;infinity&quot;)
    ))
    }
&lt;/root&gt;/*
} ;</Code>
<Body>
<A ID="pgfId-1078313"></A>
If you put this module in a file named <code>
my-module.xqy</code>
 your App Server root, you can run this constraint with the following options node:</Body>
<Code>
<A ID="pgfId-1078331"></A>
&lt;options xmlns=&quot;http://marklogic.com/appservices/search&quot;&gt;
&#160;&#160;&lt;constraint name=&quot;part&quot;&gt;
&#160;&#160;&#160;&#160;&lt;custom facet=&quot;false&quot;&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;parse apply=&quot;part&quot; ns=&quot;my-namespace&quot; at=&quot;/my-module.xqy&quot;/&gt;
&#160;&#160;&#160;&#160;&lt;/custom&gt;
&#160;&#160;&lt;/constraint&gt;
&lt;/options&gt;</Code>
<Body>
<A ID="pgfId-1078420"></A>
The following query text results in constraining this search to the <code>
/mydocs/book-dir/</code>
 directory:</Body>
<Code>
<A ID="pgfId-1078427"></A>
part:book</Code>
<Heading-3>
<A ID="pgfId-1078042"></A>
<A ID="66428"></A>
Example: Creating a Custom Constraint Geospatial Facet</Heading-3>
<Body>
<A ID="pgfId-1066686"></A>
The following is a library module that implements a geospatial facet that uses a custom constraint. It tokenizes the constraint value on the <code>
@</code>
 character to produce input to the geospatial lexicon function. This is a simplified example, meant to demonstrate the design pattern, not meant for production, as it does not do any error checking to make it more robust at handling user input. </Body>
<Code>
<A ID="pgfId-1066705"></A>
xquery version &quot;1.0-ml&quot;;
module namespace geoexample = &quot;my-geoexample&quot;;
(: 
  Sample custom constraint for this example : 

  &lt;constraint name=&quot;geo&quot;&gt;
     &lt;custom&gt;
       &lt;parse apply=&quot;parse&quot; ns=&quot;my-geoexample&quot;
              at=&quot;/geoexample.xqy&quot;/&gt; 
       &lt;start-facet apply=&quot;start-facet&quot; ns=&quot;my-geoexample&quot; 
                     at=&quot;/geoexample.xqy&quot;/&gt;
       &lt;finish-facet apply=&quot;finish-facet&quot; ns=&quot;my-geoexample&quot; 
                     at=&quot;/geoexample.xqy&quot;/&gt;
        &lt;annotation&gt;
            &lt;regions&gt;
               &lt;region label=&quot;A&quot;&gt;[0, -180, 30, -90]&lt;/region&gt;
               &lt;region label=&quot;B&quot;&gt;[0, -90, 30, 0]&lt;/region&gt;
               &lt;region label=&quot;C&quot;&gt;[30, -180, 45, -90]&lt;/region&gt;
               &lt;region label=&quot;D&quot;&gt;[30, -90, 45, 0]&lt;/region&gt;
               &lt;region label=&quot;E&quot;&gt;[45, -180, 60, -90]&lt;/region&gt;
               &lt;region label=&quot;F&quot;&gt;[45, -90, 60, 0]&lt;/region&gt;
               &lt;region label=&quot;G&quot;&gt;[45, 90, 60, 180]&lt;/region&gt;
               &lt;region label=&quot;H&quot;&gt;[60, -180, 90, -90]&lt;/region&gt;
               &lt;region label=&quot;I&quot;&gt;[60, -90, 90, 0]&lt;/region&gt;
               &lt;region label=&quot;J&quot;&gt;[60, 90, 90, 180]&lt;/region&gt;
            &lt;/regions&gt;
        &lt;/annotation&gt;
      &lt;/custom&gt;
   &lt;/constraint&gt;

&#160;&#160;&#160;This example assumes the presence of an element-pair 
   geospatial index, on data structured as follows (note lat/lon 
   children of quake):

     &lt;quake&gt;
      &lt;area&gt;0&lt;/area&gt;
      &lt;perimeter&gt;0&lt;/perimeter&gt;
      &lt;quakesx020&gt;2&lt;/quakesx020&gt;
      &lt;quakesx0201&gt;26024&lt;/quakesx0201&gt;
      &lt;catalog_sr&gt;PDE&lt;/catalog_sr&gt;
      &lt;year&gt;1994&lt;/year&gt;
      &lt;month&gt;6&lt;/month&gt;
      &lt;day&gt;11&lt;/day&gt;
      &lt;origin_tim&gt;164453.48&lt;/origin_tim&gt;
      &lt;lat&gt;61.61&lt;/lat&gt;
      &lt;lon&gt;168.28&lt;/lon&gt;
      &lt;depth&gt;9&lt;/depth&gt;
      &lt;magnitude&gt;4.3&lt;/magnitude&gt;
      &lt;mag_scale&gt;mb&lt;/mag_scale&gt;
      &lt;mag_source/&gt;
      &lt;dt&gt;1994-06-11T16:44:53.48Z&lt;/dt&gt;
    &lt;/quake&gt;
:)

declare namespace search = &quot;http://marklogic.com/appservices/search&quot;;
(:
   The Search API calls the parse function during the parsing of the 
   query text.  It accepts the parsed-so-far query text for this 
   constraint, parses that query, and outputs a serialized cts:query 
   for the custom part.  The Search API passes the parameters to this 
   function based on the custom constraint in the search:options and
&#160;&#160;&#160;the query text passed into search:search.
:)
declare function geoexample:parse(
  $qtext as xs:string, 
  $right as schema-element(cts:query) )
as schema-element(cts:query)
{
    let $point := fn:tokenize(fn:string($right//cts:text), &quot;@&quot;)
    let $s := $point[1]
    let $w := $point[2]
    let $n := $point[3]
    let $e := $point[4]
    return
        element cts:element-pair-geospatial-query {
            attribute qtextconst { 
                fn:concat($qtext, fn:string($right//cts:text)) },
            element cts:annotation { 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&quot;this is a custom constraint for geo&quot; },
            element cts:element { &quot;quake&quot; },
            element cts:latitude {&quot;lat&quot;},
            element cts:longitude {&quot;lon&quot;},
            element cts:region { 
                attribute xsi:type { &quot;cts:box&quot; },
                fn:concat(&quot;[&quot;, fn:string-join(($s, $w, $n, $e), 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&quot;, &quot;), &quot;]&quot;)
            },
            element cts:option { &quot;coordinate-system=wgs84&quot; }
        }
};

(:
  The start-facet function starts the concurrent lexicon evaluation. 
:)
declare function geoexample:start-facet(
  $constraint as element(search:constraint), 
  $query as cts:query?, 
  $facet-options as xs:string*, 
  $quality-weight as xs:double?, 
  $forests as xs:unsignedLong*) 
as item()*
{
  let $latitude-bounds  := (0, 30, 45, 60, 90)
  let $longitude-bounds := (-180, -90, 0, 90, 180)
  return 
  cts:element-pair-geospatial-boxes(
        xs:QName(&quot;quake&quot;), xs:QName(&quot;lat&quot;), xs:QName(&quot;lon&quot;), $latitude-bounds,
        $longitude-bounds, ($facet-options, &quot;concurrent&quot;, &quot;gridded&quot;),
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$query, $quality-weight, $forests) 
};
    
(:
  The finish-facet function constructs the facet, based on the 
&#160;&#160;values from $start returned by the start-facet function.
:)
declare function geoexample:finish-facet(
  $start as item()*,
  $constraint as element(search:constraint), 
  $query as cts:query?,
  $facet-options as xs:string*,
  $quality-weight as xs:double?, 
  $forests as xs:unsignedLong*)
as element(search:facet)
{
(: Uses the annotation from the constraint to extract the regions :)
  let $labels := $constraint/search:custom/search:annotation/search:regions
  return
  element search:facet {
    attribute name {$constraint/@name},
    for $range in $start 
    return 
    element search:facet-value{ 
        attribute name { 
              $labels/search:region[. eq fn:string($range)]/@label }, 
        attribute count {cts:frequency($range)}, fn:string($range) }
  }
};</Code>
<Body>
<A ID="pgfId-1071823"></A>
To run a custom constraint that references the above custom code, put the above module in the App Server root in a file names <code>
geoexample.xqy</code>
 and run the following: </Body>
<Code>
<A ID="pgfId-1071841"></A>
xquery version &quot;1.0-ml&quot;;

import module namespace search = 
  &quot;http://marklogic.com/appservices/search&quot;
  at &quot;/MarkLogic/appservices/search/search.xqy&quot;;

let $options := 
&lt;options xmlns=&quot;http://marklogic.com/appservices/search&quot;&gt;
  &lt;constraint name=&quot;geo&quot;&gt;
     &lt;custom&gt;
       &lt;parse apply=&quot;parse&quot; ns=&quot;my-geoexample&quot;
              at=&quot;/geoexample.xqy&quot;/&gt; 
       &lt;start-facet apply=&quot;start-facet&quot; ns=&quot;my-geoexample&quot; 
                     at=&quot;/geoexample.xqy&quot;/&gt;
       &lt;finish-facet apply=&quot;finish-facet&quot; ns=&quot;my-geoexample&quot; 
                     at=&quot;/geoexample.xqy&quot;/&gt;
        &lt;annotation&gt;
            &lt;regions&gt;
               &lt;region label=&quot;A&quot;&gt;[0, -180, 30, -90]&lt;/region&gt;
               &lt;region label=&quot;B&quot;&gt;[0, -90, 30, 0]&lt;/region&gt;
               &lt;region label=&quot;C&quot;&gt;[30, -180, 45, -90]&lt;/region&gt;
               &lt;region label=&quot;D&quot;&gt;[30, -90, 45, 0]&lt;/region&gt;
               &lt;region label=&quot;E&quot;&gt;[45, -180, 60, -90]&lt;/region&gt;
               &lt;region label=&quot;F&quot;&gt;[45, -90, 60, 0]&lt;/region&gt;
               &lt;region label=&quot;G&quot;&gt;[45, 90, 60, 180]&lt;/region&gt;
               &lt;region label=&quot;H&quot;&gt;[60, -180, 90, -90]&lt;/region&gt;
               &lt;region label=&quot;I&quot;&gt;[60, -90, 90, 0]&lt;/region&gt;
               &lt;region label=&quot;J&quot;&gt;[60, 90, 90, 180]&lt;/region&gt;
            &lt;/regions&gt;
        &lt;/annotation&gt;
      &lt;/custom&gt;
   &lt;/constraint&gt;
&lt;/options&gt;
return
search:search(&quot;geo:1@2@3@4&quot;, $options)</Code>
<Heading-2>
<A ID="pgfId-1075102"></A>
<A ID="44520"></A>
Modifying and Extending the Search Parsing Grammar</Heading-2>
<Body>
<A ID="pgfId-1075103"></A>
You can customize the search parsing grammar by specifying a grammar element in the options XML. The following is the default search grammar (to see the defaults options, run <code>
search:get-default-options()</code>
).</Body>
<Code>
<A ID="pgfId-1079081"></A>
&lt;grammar xmlns=&quot;http://marklogic.com/appservices/search&quot;&gt;
  &lt;quotation&gt;&quot;&lt;/quotation&gt;
  &lt;implicit&gt;
    &lt;cts:and-query strength=&quot;20&quot; xmlns:cts=&quot;http://marklogic.com/cts&quot;/&gt;
  &lt;/implicit&gt;
  &lt;starter strength=&quot;30&quot; apply=&quot;grouping&quot; delimiter=&quot;)&quot;&gt;(&lt;/starter&gt;
  &lt;starter strength=&quot;40&quot; apply=&quot;prefix&quot; element=&quot;cts:not-query&quot;&gt;-&lt;/starter&gt;
  &lt;joiner strength=&quot;10&quot; apply=&quot;infix&quot; element=&quot;cts:or-query&quot; tokenize=&quot;word&quot;&gt;OR&lt;/joiner&gt;
  &lt;joiner strength=&quot;20&quot; apply=&quot;infix&quot; element=&quot;cts:and-query&quot; tokenize=&quot;word&quot;&gt;AND&lt;/joiner&gt;
  &lt;joiner strength=&quot;30&quot; apply=&quot;infix&quot; element=&quot;cts:near-query&quot; tokenize=&quot;word&quot;&gt;NEAR&lt;/joiner&gt;
  &lt;joiner strength=&quot;30&quot; apply=&quot;near2&quot; element=&quot;cts:near-query&quot;&gt;NEAR/&lt;/joiner&gt;
  &lt;joiner strength=&quot;50&quot; apply=&quot;constraint&quot;&gt;:&lt;/joiner&gt;
  &lt;joiner strength=&quot;50&quot; apply=&quot;constraint&quot; compare=&quot;LT&quot; tokenize=&quot;word&quot;&gt;LT&lt;/joiner&gt;
  &lt;joiner strength=&quot;50&quot; apply=&quot;constraint&quot; compare=&quot;LE&quot; tokenize=&quot;word&quot;&gt;LE&lt;/joiner&gt;
  &lt;joiner strength=&quot;50&quot; apply=&quot;constraint&quot; compare=&quot;GT&quot; tokenize=&quot;word&quot;&gt;GT&lt;/joiner&gt;
  &lt;joiner strength=&quot;50&quot; apply=&quot;constraint&quot; compare=&quot;GE&quot; tokenize=&quot;word&quot;&gt;GE&lt;/joiner&gt;
  &lt;joiner strength=&quot;50&quot; apply=&quot;constraint&quot; compare=&quot;NE&quot; tokenize=&quot;word&quot;&gt;NE&lt;/joiner&gt;
&lt;/grammar&gt;</Code>
<Body>
<A ID="pgfId-1078849"></A>
The default grammar provides a robust ability to generate complex queries. The following are some examples of queries that use the default grammar:</Body>
<Body-bullet>
<A ID="pgfId-1078865"></A>
<code>
(cat OR dog) NEAR vet</code>
</Body-bullet>
<Body-indent>
<A ID="pgfId-1078878"></A>
at least one of the terms <code>
cat</code>
 or <code>
dog</code>
 within 100 terms (the default distance for <code>
cts:near-query</code>
) of the word <code>
vet</code>
</Body-indent>
<Body-bullet>
<A ID="pgfId-1078885"></A>
<code>
dog NEAR/30 vet</code>
</Body-bullet>
<Body-indent>
<A ID="pgfId-1078907"></A>
the word <code>
dog</code>
 within 30 terms of the word <code>
vet</code>
</Body-indent>
<Body-bullet>
<A ID="pgfId-1078914"></A>
<code>
cat -dog</code>
</Body-bullet>
<Body-indent>
<A ID="pgfId-1078933"></A>
the word <code>
cat</code>
 where there is no word <code>
dog</code>
</Body-indent>
<Body>
<A ID="pgfId-1075105"></A>
The following table describes the concepts used in the search grammar:</Body>
<TableAnchor>
<A ID="pgfId-1075131"></A>
</TableAnchor>
<TABLE>
<ROW>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1075108"></A>
Concept</CellHeading>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1075110"></A>
Description</CellHeading>
</TH>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1079223"></A>
implicit</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1079225"></A>
The <Emphasis>
implicit</Emphasis>
 grammar element specifies the <code>
cts:query</code>
 to use by default to join two search terms together. By default, the search API uses a <code>
cts:and-query</code>
, but you can change it to any cts:query with the <code>
implicit</code>
 grammar option.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1075112"></A>
starter</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1075114"></A>
A <Emphasis>
starter</Emphasis>
 is a string that appears before a term to denote special parsing for the term, for example, the minus sign ( <code>
-</code>
 ) for negation. Additionally, when used with the <code>
delimiter</code>
 attribute, a starter specifies starting and ending strings that separate terms for grouping things together, and allows the grammar to set an order of precedence for terms when parsing a string.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1075116"></A>
joiner</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1075118"></A>
A <Emphasis>
joiner</Emphasis>
 is a string that combines two terms together. The grammar uses joiners for things like boolean logic:</CellBody>
<Code>
<A ID="pgfId-1075119"></A>
cat AND dog
cat OR dog</Code>
<Body>
<A ID="pgfId-1075120"></A>
It also uses joiners for the string that separates a constraint or operator from its value, as described in <A href="search-api.xml#id(95820)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Constraint Options' on page&#160;22</A> and <A href="search-api.xml#id(30002)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Operator Options' on page&#160;31</A>. If the <code>
tokenize=&quot;word&quot;</code>
 attribute is present, then the terms and the joiner must be whitespace-separated; otherwise the parse looks for the joiner string anywhere in the query text.</Body>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1075301"></A>
quotation</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1075303"></A>
The <code>
quotation</code>
 string specifies the string to use to indicate the start and end of a phrase. For example, in the default grammar, the following is parsed as a phrase (instead of a sequence of terms combined with an <code>
AND</code>
):</CellBody>
<Code>
<A ID="pgfId-1075309"></A>
&quot;this is a phrase&quot;</Code>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1076179"></A>
strength</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1076181"></A>
The <Emphasis>
strength</Emphasis>
 attribute provides the parser with information on which tokens are processed first. Higher strength tokens or groups are processed before lower strength tokens or groups. </CellBody>
</CELL>
</ROW>
</TABLE>
<Body>
<A ID="pgfId-1075132"></A>
The <code>
starter</code>
 elements define how to parse portions of the grammar. The <code>
apply</code>
 attributes specify the functions to which the <code>
starter</code>
 and the <code>
delimiter</code>
 apply. </Body>
<Body>
<A ID="pgfId-1075133"></A>
The <code>
joiner</code>
 elements define how to parse various operators, constraints, and other operations and specifies the functions that define the joiner's behavior. For example, if you wanted to change the <code>
OR</code>
 joiner above, which joins tokens with a <code>
cts:or-query</code>
, to use the pipe character ( <code>
|</code>
 ) instead, you would substitute the following <code>
joiner</code>
 element for the one above:</Body>
<Code>
<A ID="pgfId-1075134"></A>
&#160;&#160;&lt;search:joiner strength=&quot;10&quot; apply=&quot;infix&quot; element=&quot;cts:or-query&quot;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;tokenize=&quot;word&quot;&gt;|&lt;/search:joiner&gt;</Code>
<Body>
<A ID="pgfId-1075135"></A>
The <code>
tokenize=&quot;word&quot;</code>
 attribute specifies that in order for that token to be recognized, it must have whitespace immediately before and after it. Without that attribute, if <code>
OR</code>
 was the joiner, then a search for <code>
CORN</code>
 would result in a search for <code>
C OR N</code>
 (<code>
cts:or-query((&quot;C&quot;), (&quot;N&quot;))</code>
). With joiners used in constraints (for example, the colon character <code>
:</code>
), you probably do not want that, so the <code>
tokenize</code>
 attribute is omitted, thus allowing searches like <code>
decade:1990s</code>
 to parse as a constraint. </Body>
<Body>
<A ID="pgfId-1075339"></A>
You can add a joiner string to specify the composable <code>
cts:query</code>
 elements that take a sequence of queries (<code>
cts:or-query</code>
, <code>
cts:and-query</code>
, or <code>
cts:near-query</code>
) by specifying the element in the <code>
element</code>
 attribute on an <code>
apply=&quot;infix&quot;</code>
 joiner. For example, the following <code>
search:joiner</code>
 element specifies a joiner for <code>
cts:near-query</code>
, which would combine the surrounding terms with a <code>
cts:near-query</code>
 (and would use the default distance of 100) using the joiner string <code>
CLOSETO</code>
:</Body>
<Code>
<A ID="pgfId-1075377"></A>
&lt;search:joiner strength=&quot;10&quot; apply=&quot;infix&quot; element=&quot;cts:near-query&quot;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;tokenize=&quot;word&quot;&gt;CLOSETO&lt;/search:joiner&gt;</Code>
<Body>
<A ID="pgfId-1075136"></A>
Using the above joiner specification, the following query text <code>
bicycle CLOSETO shop</code>
 would return matches that have <code>
bicycle</code>
 and <code>
shop</code>
 within 100 words of each other.</Body>
<Body>
<A ID="pgfId-1078659"></A>
By default, the search grammar is very powerful, and implements a grammar similar to the Google grammar. With the customization, you can make it even more powerful and customize it to your specific needs. To add custom parsing, you must implement a function and use the <code>
apply</code>
, <code>
ns</code>
, <code>
at</code>
 design pattern (described in <A href="search-api.xml#id(28383)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Search Customization Via Options and Extensions' on page&#160;19</A>) and construct a <code>
search:grammar</code>
 options node to point to the function(s) you implemented.</Body>
<Heading-2>
<A ID="pgfId-1074935"></A>
<A ID="61050"></A>
More Search API Examples</Heading-2>
<Body>
<A ID="pgfId-1059223"></A>
This section shows the following examples that use the Search API:</Body>
<Body-bullet>
<A ID="pgfId-1063940"></A>
<A href="search-api.xml#id(13330)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Buckets Example</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1069113"></A>
<A href="search-api.xml#id(22725)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Computed Buckets Example</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1063958"></A>
<A href="search-api.xml#id(49503)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Sort Order Example</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1063073"></A>
<A ID="13330"></A>
Buckets Example</Heading-3>
<Body>
<A ID="pgfId-1063087"></A>
The following example from the Oscars sample application shows how to create a search that defines several decades as buckets, and those buckets are used to generate facets and as a constraint in the search grammar. Buckets are a type of range constraint, which are described in <A href="search-api.xml#id(95820)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Constraint Options' on page&#160;22</A>. </Body>
<Body>
<A ID="pgfId-1063996"></A>
This example defines a constraint that uses a range index of type <code>
xs:gYear</code>
 on a Wikipedia <code>
nominee/@year</code>
 attribute.</Body>
<Code>
<A ID="pgfId-1063314"></A>
xquery version &quot;1.0-ml&quot;;

import module namespace search = 
  &quot;http://marklogic.com/appservices/search&quot;
  at &quot;/MarkLogic/appservices/search/search.xqy&quot;;

let $options :=
&lt;search:options&gt;
  &lt;search:constraint name=&quot;decade&quot;&gt;
    &lt;search:range type=&quot;xs:gYear&quot; facet=&quot;true&quot;&gt;
      &lt;search:bucket ge=&quot;2000&quot; name=&quot;2000s&quot;&gt;2000s&lt;/search:bucket&gt;
      &lt;search:bucket lt=&quot;2000&quot; ge=&quot;1990&quot;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;name=&quot;1990s&quot;&gt;1990s&lt;/search:bucket&gt;
      &lt;search:bucket lt=&quot;1990&quot; ge=&quot;1980&quot;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;name=&quot;1980s&quot;&gt;1980s&lt;/search:bucket&gt;
      &lt;search:bucket lt=&quot;1980&quot; ge=&quot;1970&quot;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; name=&quot;1970s&quot;&gt;1970s&lt;/search:bucket&gt;
      &lt;search:bucket lt=&quot;1970&quot; ge=&quot;1960&quot;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; name=&quot;1960s&quot;&gt;1960s&lt;/search:bucket&gt;
      &lt;search:bucket lt=&quot;1960&quot; ge=&quot;1950&quot;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; name=&quot;1950s&quot;&gt;1950s&lt;/search:bucket&gt;
      &lt;search:bucket lt=&quot;1950&quot; ge=&quot;1940&quot;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; name=&quot;1940s&quot;&gt;1940s&lt;/search:bucket&gt;
      &lt;search:bucket lt=&quot;1940&quot; ge=&quot;1930&quot;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; name=&quot;1930s&quot;&gt;1930s&lt;/search:bucket&gt;
      &lt;search:bucket lt=&quot;1930&quot; ge=&quot;1920&quot;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; name=&quot;1920s&quot;&gt;1920s&lt;/search:bucket&gt;
      &lt;search:facet-option&gt;limit=10&lt;/search:facet-option&gt;
      &lt;search:attribute ns=&quot;&quot; name=&quot;year&quot;/&gt;
      &lt;search:element ns=&quot;http://marklogic.com/wikipedia&quot;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; name=&quot;nominee&quot;/&gt;
    &lt;/search:range&gt;
  &lt;/search:constraint&gt;
&lt;/search:options&gt;
return
search:search(&quot;james stewart decade:1940s&quot;, $options)</Code>
<Body>
<A ID="pgfId-1063547"></A>
The following is a partial response from this query:</Body>
<Code>
<A ID="pgfId-1063565"></A>
&lt;search:response total=&quot;2&quot; start=&quot;1&quot; page-length=&quot;10&quot;
&#160;&#160;&#160;xmlns:search=&quot;http://marklogic.com/appservices/search&quot;&gt;
  &lt;search:result index=&quot;1&quot; uri=&quot;/oscars/843224828394260114.xml&quot;
&#160;&#160;&#160;&#160;path=&quot;doc(&amp;quot;/oscars/843224828394260114.xml&amp;quot;)&quot; score=&quot;200&quot;
&#160;&#160;&#160;&#160;confidence=&quot;0.670319&quot; fitness=&quot;1&quot;&gt;
    &lt;search:snippet&gt;
      &lt;search:match path=
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&quot;doc(&amp;quot;/oscars/843224828394260114.xml&amp;quot;)/*:nominee
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;/*:name&quot;&gt;&lt;search:highlight&gt;James&lt;/search:highlight&gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;search:highlight&gt;Stewart&lt;/search:highlight&gt;&lt;/search:match&gt;
.......
    &lt;/search:snippet&gt;
&#160;&#160;&#160;&#160;&lt;search:snippet&gt;.......&lt;/search:snippet&gt;
.......
  &lt;/search:result&gt;
  &lt;search:facet name=&quot;decade&quot;&gt;
    &lt;search:facet-value name=&quot;1940s&quot; count=&quot;2&quot;&gt;1940s&lt;/search:facet-value&gt;
  &lt;/search:facet&gt;
  &lt;search:qtext&gt;james stewart decade:1940s&lt;/search:qtext&gt;
  &lt;search:metrics&gt;
    &lt;search:query-resolution-time&gt;
&#160;&#160;&#160;&#160;&#160;PT0.152S&lt;/search:query-resolution-time&gt;
    &lt;search:facet-resolution-time&gt;
&#160;&#160;&#160;&#160;&#160;PT0.009S&lt;/search:facet-resolution-time&gt;
    &lt;search:snippet-resolution-time&gt;
&#160;&#160;&#160;&#160;&#160;PT0.073S&lt;/search:snippet-resolution-time&gt;
    &lt;search:total-time&gt;PT0.234S&lt;/search:total-time&gt;
  &lt;/search:metrics&gt;
&lt;/search:response&gt;</Code>
<Heading-3>
<A ID="pgfId-1063965"></A>
<A ID="22725"></A>
Computed Buckets Example</Heading-3>
<Body>
<A ID="pgfId-1069131"></A>
The <code>
computed-bucket</code>
 range constraint operates over <code>
xs:date</code>
 and <code>
xs:dateTime</code>
 range indexes. The constraint specifies boundaries for the buckets that are computed at runtime based on computations made at the current time. The <code>
anchor</code>
 attribute on the <code>
computed-bucket</code>
 element has the following values:</Body>
<TableAnchor>
<A ID="pgfId-1069166"></A>
</TableAnchor>
<TABLE>
<ROW>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1069184"></A>
<code>
&lt;computed-bucket anchor=&quot;value&quot;&gt;</code>
</CellHeading>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1069186"></A>
Description</CellHeading>
</TH>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<Code>
<A ID="pgfId-1069188"></A>
anchor=&quot;now&quot;</Code>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1069190"></A>
The current time.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<Code>
<A ID="pgfId-1069192"></A>
anchor=&quot;start-of-day&quot;</Code>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1069194"></A>
The time of the start of the current day.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<Code>
<A ID="pgfId-1069196"></A>
anchor=&quot;start-of-month&quot;</Code>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1069198"></A>
The time of the start of the current month.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<Code>
<A ID="pgfId-1069200"></A>
anchor=&quot;start-of-year&quot;</Code>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1069202"></A>
The time of the start of the current year.</CellBody>
</CELL>
</ROW>
</TABLE>
<Body>
<A ID="pgfId-1069177"></A>
These values can also be used in <code>
ge-anchor</code>
 and <code>
le-anchor</code>
 attributes of the <code>
computed-bucket</code>
 element.</Body>
<Body>
<A ID="pgfId-1069347"></A>
The following search specifies a computed bucket and finds all of the documents that were updated today (this example assumes the maintain last-modified property is set on the database configuration):</Body>
<Code>
<A ID="pgfId-1069376"></A>
xquery version &quot;1.0-ml&quot;;

import module namespace search = 
  &quot;http://marklogic.com/appservices/search&quot;
  at &quot;/MarkLogic/appservices/search/search.xqy&quot;;

search:search('modified:today', 
&lt;options xmlns=&quot;http://marklogic.com/appservices/search&quot;&gt;
  &lt;searchable-expression&gt;xdmp:document-properties()
  &lt;/searchable-expression&gt;
  &lt;constraint name=&quot;modified&quot;&gt;
    &lt;range type=&quot;xs:dateTime&quot;&gt;
      &lt;element ns=&quot;http://marklogic.com/xdmp/property&quot; 
               name=&quot;last-modified&quot;/&gt;
      &lt;computed-bucket name=&quot;today&quot; ge=&quot;P0D&quot; lt=&quot;P1D&quot; 
       anchor=&quot;start-of-day&quot;&gt;Today&lt;/computed-bucket&gt;
      &lt;computed-bucket name=&quot;yesterday&quot; ge=&quot;-P1D&quot; lt=&quot;P0D&quot; 
       anchor=&quot;start-of-day&quot;&gt;yesterday&lt;/computed-bucket&gt;
      &lt;computed-bucket name=&quot;30-days&quot; ge=&quot;-P30D&quot; lt=&quot;P0D&quot; 
       anchor=&quot;start-of-day&quot;&gt;Last 30 days&lt;/computed-bucket&gt;
      &lt;computed-bucket name=&quot;60-days&quot; ge=&quot;-P60D&quot; lt=&quot;P0D&quot; 
       anchor=&quot;start-of-day&quot;&gt;Last 60 Days&lt;/computed-bucket&gt;
      &lt;computed-bucket name=&quot;year&quot; ge=&quot;-P1Y&quot; lt=&quot;P1D&quot; 
       anchor=&quot;now&quot;&gt;Last Year&lt;/computed-bucket&gt;
    &lt;/range&gt;
  &lt;/constraint&gt;
&lt;/options&gt;)</Code>
<Body>
<A ID="pgfId-1069365"></A>
The <code>
anchor</code>
 attributes have a value of <code>
start-of-day</code>
, so the duration values specified in the <code>
ge</code>
 and <code>
lt</code>
 attributes are applied at the start of the current day. Note that this is not the same as the 'previous 24 hours,' as the <code>
start-of-day</code>
 value uses 12 o'clock midnight as the start of the day. The notion of time relative to days, months, and years, as opposed to relative to the exact current time, is the difference between relative buckets (<code>
computed-bucket</code>
) and absolute buckets (<code>
bucket</code>
). For an example that uses absolute buckets, see <A href="search-api.xml#id(13330)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Buckets Example' on page&#160;51</A>.</Body>
<Heading-3>
<A ID="pgfId-1069124"></A>
<A ID="49503"></A>
Sort Order Example</Heading-3>
<Body>
<A ID="pgfId-1064360"></A>
The following search specifies a custom sort order.</Body>
<Code>
<A ID="pgfId-1064378"></A>
xquery version &quot;1.0-ml&quot;;

import module namespace search = 
  &quot;http://marklogic.com/appservices/search&quot;
  at &quot;/MarkLogic/appservices/search/search.xqy&quot;;

let $options :=
&lt;search:options&gt;
&#160;&#160;&lt;search:operator name=&quot;sort&quot;&gt;
&#160;&#160;&#160;&#160;&lt;search:state name=&quot;relevance&quot;&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;search:sort-order&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;search:score/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;/search:sort-order&gt;
&#160;&#160;&#160;&#160;&lt;/search:state&gt;
&#160;&#160;&#160;&#160;&lt;search:state name=&quot;year&quot;&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;search:sort-order direction=&quot;descending&quot; type=&quot;xs:gYear&quot;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;collation=&quot;&quot;&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;search:attribute ns=&quot;&quot; name=&quot;year&quot;/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;search:element ns=&quot;http://marklogic.com/wikipedia&quot;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;name=&quot;nominee&quot;/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;/search:sort-order&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;search:sort-order&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;search:score/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;/search:sort-order&gt;
&#160;&#160;&#160;&#160;&lt;/search:state&gt;
&#160;&#160;&lt;/search:operator&gt;
&lt;/search:options&gt;
return
search:search(&quot;lange sort:year&quot;, $options)</Code>
<Body>
<A ID="pgfId-1064575"></A>
This search specifies to sort by year. The options specification allows you to specify <code>
year</code>
 or <code>
relevance</code>
, and without specifying, sorts by score (which is the same as <code>
relevance</code>
 in this example).</Body>
</XML>
