<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="collections.css" type="text/css" charset="UTF-8"?>
<XML>
<TITLE> </TITLE><Heading-1>
<A ID="pgfId-1043743"></A>
<A ID="19337"></A>
Collections</Heading-1>
<pagenum>
<A ID="pgfId-1044570"></A>
155</pagenum>
<Body>
<A ID="pgfId-1044031"></A>
MarkLogic Server includes <Emphasis>
collections</Emphasis>
, which are groups of documents that enable queries to efficiently target subsets of content within a MarkLogic database.</Body>
<Body>
<A ID="pgfId-1043433"></A>
Collections are described as part of the W3C XQuery specification, but their implementation is undefined. MarkLogic has chosen to emphasize collections as a powerful and high-performance mechanism for selecting sets of documents against which queries can be processed. This chapter introduces the <code>
collection()</code>
 function, explains how collections are defined and accessed, and describes some of the basic performance characteristics with which developers should be familiar. This chapter includes the following sections:</Body>
<Body-bullet>
<A ID="pgfId-1043791"></A>
<A href="collections.xml#id(18038)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
The collection() Function</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1044202"></A>
<A href="collections.xml#id(66550)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Collections Versus Directories</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1043799"></A>
<A href="collections.xml#id(44952)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Defining Collections</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1043804"></A>
<A href="collections.xml#id(19258)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Collection Membership</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1043809"></A>
<A href="collections.xml#id(32054)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Collections and Security</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1043814"></A>
<A href="collections.xml#id(84867)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Performance Characteristics</Hyperlink>
</A></Body-bullet>
<Heading-2>
<A ID="pgfId-1043434"></A>
<A ID="18038"></A>
The collection() Function</Heading-2>
<Body>
<A ID="pgfId-1043435"></A>
The <code>
collection()</code>
 function can be used anywhere in your XQuery that the <code>
doc()</code>
 or <code>
input()</code>
 functions are used. The <code>
collection()</code>
 function has the following signature:</Body>
<Code>
<A ID="pgfId-1043924"></A>
fn:collection($URI as xs:string*) as node*</Code>
<Note>
<A ID="pgfId-1043928"></A>
The MarkLogic Server implementation of the <code>
collection()</code>
 function takes a sequence of URIs, so you can call the <code>
collection()</code>
 function on one or more collections. The signature of the function in the W3C XQuery documentation only takes a single string. Also, the <code>
fn</code>
 namespace is built-in to MarkLogic Server, so it is not necessary to prefix the function with its namespace.</Note>
<Body>
<A ID="pgfId-1043923"></A>
To illustrate what the <code>
collection()</code>
 function is used for, consider the following two XPath expressions:</Body>
<Code>
<A ID="pgfId-1048189"></A>
fn:doc()//sonnet/line[cts:contains(., &quot;flower&quot;)]</Code>
<Code>
<A ID="pgfId-1048190"></A>
collection(&quot;english-lit/shakespeare&quot;)//sonnet/
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;line[cts:contains(., &quot;flower&quot;)]</Code>
<Body>
<A ID="pgfId-1043438"></A>
The first expression returns a sequence of line nodes, each of which must be the child of a sonnet node, and each of which must contain the term <Emphasis>
flower</Emphasis>
, matched on a case-insensitive basis.</Body>
<Body>
<A ID="pgfId-1043439"></A>
The second expression returns the same sequence, except that only line nodes contained within documents that are members of the <code>
english-lit/shakespeare</code>
 collection. MarkLogic Server optimizes this expression. The operation that uses the <code>
collection()</code>
 function, along with the rest of the XPath expression, is executed very efficiently through a series of index lookups. </Body>
<Body>
<A ID="pgfId-1043440"></A>
As mentioned previously, the <code>
collection()</code>
 function accepts either a single collection, as illustrated above, or a sequence of collections, as illustrated below:</Body>
<Code>
<A ID="pgfId-1048202"></A>
collection((&quot;english-lit/shakespeare&quot;, 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&quot;american-lit/poetry&quot;))//sonnet/
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;line[cts:contains(., &quot;flower&quot;)]</Code>
<Body>
<A ID="pgfId-1043442"></A>
The query above returns a sequence of line nodes that match the stated predicates that are members of either the <code>
english-lit/shakespeare</code>
 collection or the <code>
american-lit/poetry</code>
 collection or both. With this modification to the <code>
collection()</code>
 function, its format now closely matches the format of the <code>
doc()</code>
 function, which also takes a sequence of URIs. While there is currently no XPath-level support for more complex boolean membership conditions (for example, requiring membership in multiple collections (and), excluding documents that belong to certain collections (not) or requiring pure either-or membership (exclusive or)), you can achieve these conditions through the <code>
where</code>
 clause in a surrounding FLWOR expression (see <A href="collections.xml#id(19258)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Collection Membership' on page&#160;152</A> for an example).</Body>
<Heading-2>
<A ID="pgfId-1043443"></A>
<A ID="66550"></A>
Collections Versus Directories</Heading-2>
<Body>
<A ID="pgfId-1044193"></A>
Collections are used to organize documents in a database. You can also use directories to organize documents in a database. The key differences in using collections to organize documents versus using directories are:</Body>
<Body-bullet>
<A ID="pgfId-1044194"></A>
Collections do not require member documents to conform to any URI patterns. They are not hierarchical; directories are. Any document can belong to any collection, and any document can also belong to multiple collections. </Body-bullet>
<Body-bullet>
<A ID="pgfId-1048934"></A>
You can delete all documents in a collection with the <code>
xdmp:collection-delete</code>
 function. Similarly, you can delete all documents in a directory (as well as all recursive subdirectories and any documents in those directories) with the <code>
xdmp:directory-delete</code>
 function.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1044220"></A>
You cannot set properties on a collection; you can on a directory.</Body-bullet>
<Body>
<A ID="pgfId-1044213"></A>
Except for the fact that you can use both collections and directories to organize documents, collections are unrelated to directories. For details on directories, see <A href="../dev_guide/properties.xml#id(78944)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Properties Documents and Directories</Hyperlink>
</A> in the <Emphasis>
Application Developer's Guide</Emphasis>
.</Body>
<Heading-2>
<A ID="pgfId-1044192"></A>
<A ID="44952"></A>
Defining Collections</Heading-2>
<Body>
<A ID="pgfId-1043444"></A>
Collection membership for a document is defined implicitly. Rather than describing collections top-down (that is, specifying the list of documents that belong to a given collection), MarkLogic Server determines membership in a bottoms-up fashion, by aggregating the set of documents that describe themselves as being a member of the collection. You can use MarkLogic Server's security scheme to manage policies around collection membership.</Body>
<Body>
<A ID="pgfId-1043445"></A>
Collections are named using URIs. Any URI is a legal name for a collection. The URI must be unique within the set of collections (both protected and unprotected) in your database.</Body>
<Body>
<A ID="pgfId-1043446"></A>
The URIs that are used to name collections serve only as identifiers to the server. In particular, collections are not modeled on filesystem directories. Rather, collections are interpreted as sets, not as hierarchies. A document that belongs to collection <code>
english-lit/poetry/sonnets</code>
 need not belong to collection <code>
english-lit/poetry</code>
. In fact, the existence of a collection with URI <code>
english-lit/poetry/sonnets</code>
 does not imply the existence of collections with URI <code>
english-lit/poetry</code>
 or URI <code>
english-lit</code>
.</Body>
<Body>
<A ID="pgfId-1043447"></A>
There are two types of collections supported by MarkLogic Server: unprotected collections and protected collections. The two types are identical in terms of the syntactic application of the <code>
collection()</code>
 function. However, differences emerge in the way they are defined, in who can access the collections, and in who can modify, add or remove documents from them. The following subsections descripe these two ways of defining collection:</Body>
<Body-bullet>
<A ID="pgfId-1044263"></A>
<A href="collections.xml#id(32687)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Implicitly Defining Unprotected Collections</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1044271"></A>
<A href="collections.xml#id(52094)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Explicitly Defining Protected Collections</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1043448"></A>
<A ID="32687"></A>
Implicitly Defining Unprotected Collections</Heading-3>
<Body>
<A ID="pgfId-1043449"></A>
Unprotected collections are created implicitly.</Body>
<Body>
<A ID="pgfId-1043450"></A>
When a document is first loaded into the system, the load directive (whether through XQuery or XDBC) optionally can specify the collections to which that document belongs. In that list of collections, the specification of a collection URI that has not previously been used is the only action that is needed to create that new unprotected collection.</Body>
<Body>
<A ID="pgfId-1043451"></A>
If collections are left unspecified in the load directive, the document is added to the database with collection membership determined by the default collections that are defined for the current user through the security model and by inheritance from the current user's roles. The invocation of these default settings can also result in the creation of a new unprotected collection. If collections are left unspecified in the load directive and the current user has no default collections defined, the document will be added to the database without belonging to any collections.</Body>
<Body>
<A ID="pgfId-1043452"></A>
In addition, once a document is loaded into the database, you can adjust its membership in collections with any of the following built-in XQuery functions (assuming you possess the appropriate permissions to modify the document in question):</Body>
<Body-bullet>
<A ID="pgfId-1044284"></A>
<code>
xdmp:document-add-collections</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1044290"></A>
<code>
xdmp:document-remove-collections</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1044291"></A>
<code>
xdmp:document-set-collections</code>
</Body-bullet>
<Body>
<A ID="pgfId-1044292"></A>
If a collection URI that is not otherwise used in the database is passed as a parameter to <code>
xdmp:document-add-collections</code>
 or <code>
xdmp:document-set-collections</code>
, a new unprotected collection is created.</Body>
<Body>
<A ID="pgfId-1043453"></A>
Unprotected collections disappear when there are no documents in the database that are members. Consequently, using <code>
xdmp:document-remove-collections</code>
, <code>
xdmp:document-set-collections</code>
 or <code>
xdmp:document-delete</code>
 may result in unprotected collections disappearing.</Body>
<Body>
<A ID="pgfId-1043454"></A>
The <code>
xdmp:collection-delete</code>
 function, which deletes every document in a database that belongs to a particular collection (assuming that the current user has the required permissions on a per-document basis), always results in the specified unprotected collection disappearing. </Body>
<Note>
<A ID="pgfId-1044094"></A>
The <code>
xdmp:collection-delete</code>
 function will delete all documents in a collection, regardless of their membership in other collections.</Note>
<Heading-3>
<A ID="pgfId-1043455"></A>
<A ID="52094"></A>
Explicitly Defining Protected Collections</Heading-3>
<Body>
<A ID="pgfId-1043456"></A>
Protected collections are created <Emphasis>
explicitly</Emphasis>
.</Body>
<Body>
<A ID="pgfId-1043457"></A>
Protected collections afford certain security protections not available with unprotected collections (see <A href="collections.xml#id(32054)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Collections and Security' on page&#160;152</A>). Consequently, rather than the implicit model described above, protected collections must be explicitly defined using the Admin Interface before any documents are assigned to that collection.</Body>
<Body>
<A ID="pgfId-1043458"></A>
Once a protected collection and its security policies have been defined, documents can be added to that collection through the same mechanisms as described above for unprotected collections. However, in addition to the appropriate permissions to modify the document, the user also needs to have the appropriate permissions to modify the protected collection.</Body>
<Body>
<A ID="pgfId-1043459"></A>
Just as protected collections are created explicitly, the collection does not disappear if the state of the database changes and there are no documents currently belonging to that protected collection. To remove a protected collection from the database, the Admin Interface must be used to delete that collection's definition.</Body>
<Heading-2>
<A ID="pgfId-1043460"></A>
<A ID="19258"></A>
Collection Membership</Heading-2>
<Body>
<A ID="pgfId-1043461"></A>
As described above, the collections (unprotected and protected) to which a specific document belongs can be specified at load-time and can be modified once the document has been loaded into the database. Documents can belong to many collections simultaneously.</Body>
<Body>
<A ID="pgfId-1043462"></A>
If specific collections are not defined at load-time, the server will automatically assign collection membership for the document based on both the user's and the user's aggregate roles' default collection membership settings. To load a document that does not belong to any collections, explicitly specify the empty sequence as the collections parameter.</Body>
<Body>
<A ID="pgfId-1043463"></A>
Collection membership can be leveraged in any XPath expression that the <code>
collection()</code>
, <code>
doc()</code>
, or <code>
input()</code>
 functions are used. In addition, collection membership for a particular document or node can be queried using the <code>
xdmp:document-get-collections</code>
 built-in.</Body>
<Body>
<A ID="pgfId-1043464"></A>
For example, the following expression returns a sequence of line nodes, each of which must be the child of a sonnet node, and each of which must contain the term <Emphasis>
flower</Emphasis>
, matched on a case-insensitive basis, that belong to either the <code>
english-lit/shakespeare</code>
 collection or the <code>
american-lit/poetry</code>
 collection or both:</Body>
<Code>
<A ID="pgfId-1048208"></A>
collection((&quot;english-lit/shakespeare&quot;, 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&quot;american-lit/poetry&quot;))//sonnet/
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;line[cts:contains(., &quot;flower&quot;)]</Code>
<Body>
<A ID="pgfId-1043466"></A>
By contrast, the following expression returns a similar sequence of line nodes, except that the resulting nodes must belong to either the <code>
english-lit/poetry</code>
 collection or the <code>
american-lit/poetry</code>
 collection or both, but not to the <code>
english-lit/shakespeare</code>
 collection:</Body>
<Code>
<A ID="pgfId-1048214"></A>
for $line in collection((&quot;english-lit/poetry&quot;, &quot;american-lit/
&#160;&#160;&#160;&#160;&#160;poetry&quot;))//sonnet/line[cts:contains(., &quot;flower&quot;)]
where xdmp:document-get-collections($line) != 
&#160;&#160;&#160;&#160;&#160;&quot;english-lit/shakespeare&quot;
return $line</Code>
<Heading-2>
<A ID="pgfId-1043468"></A>
<A ID="32054"></A>
Collections and Security</Heading-2>
<Body>
<A ID="pgfId-1043469"></A>
Collections interact with the MarkLogic Server security model in three basic ways:</Body>
<Body-bullet>
<A ID="pgfId-1043470"></A>
All users and roles can optionally specify default collections. These are the collections to which newly inserted documents are added if collections are not explicitly specified at load-time.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1043471"></A>
Adding a document to a collection--both at load-time and after the document has been loaded into the database--is contingent on the user possessing permissions to insert or update the document in question.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1043472"></A>
Removing a document from a collection and using xdmp:collection-delete are similarly contingent on the user's having appropriate permissions to update the document(s) in question.</Body-bullet>
<Body>
<A ID="pgfId-1043473"></A>
Protected collections interact with the MarkLogic Server security model in three additional ways:</Body>
<Body-bullet>
<A ID="pgfId-1043474"></A>
Protected collections must be configured using the security module of the Admin Interface.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1043475"></A>
Protected collections specify the roles that have read, insert and/or update permissions for the protected collection.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1043476"></A>
Adding or removing documents from protected collections requires not only the appropriate permissions for the documents, but also the appropriate permissions for the collections involved.</Body-bullet>
<Heading-3>
<A ID="pgfId-1043477"></A>
Unprotected Collections</Heading-3>
<Body>
<A ID="pgfId-1043478"></A>
To add to the database a new document that belongs to one or more unprotected collections, the user must have (directly or indirectly) the permissions required to add the document. This means that the user must either possess the admin role or have both of the following:</Body>
<Body-bullet>
<A ID="pgfId-1043479"></A>
The privilege to execute the xdmp:document-load function, if that is the document insertion directive being used.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1043480"></A>
Either the <code>
unprotected-uri</code>
 privilege, the <code>
any-uri</code>
 privilege, or an appropriate URI privilege on the specific path of the document to be inserted. For example, if the document being inserted has the URI <code>
/docs/poetry/love.xml</code>
, the appropriate URI privileges are <code>
/</code>
, <code>
/docs</code>
, <code>
/docs/poetry</code>
.</Body-bullet>
<Body>
<A ID="pgfId-1043481"></A>
To modify the set of collections to which a document belongs, the user must either possess the admin role or have update permissions on the document.</Body>
<Body>
<A ID="pgfId-1043483"></A>
To access an unprotected collection in an XPath expression, no special permissions are used. Access to each of the individual documents that belong to the specified collection is governed by that individual document's read permissions.</Body>
<Heading-3>
<A ID="pgfId-1043484"></A>
Protected Collections</Heading-3>
<Body>
<A ID="pgfId-1043485"></A>
To add to the database a new document that belongs to one or more protected collections, the user must have (directly or indirectly) the permissions required to add the document as well as the permissions required to add to the protected collection(s). This means that the user must either possess the admin role or have all of the following:</Body>
<Body-bullet>
<A ID="pgfId-1043486"></A>
The insert permission on the protected collection.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1043487"></A>
The privilege to execute the xdmp:document-load function, if that is the document insertion directive being used.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1043488"></A>
Either the <code>
unprotected-uri</code>
 privilege, the <code>
any-uri</code>
 privilege, or an appropriate URI privilege on the specific path of the document to be inserted. For example, if the document being inserted has the URI <code>
/docs/poetry/love.xml</code>
, the appropriate URI privileges are <code>
/</code>
, <code>
/docs</code>
, <code>
/docs/poetry</code>
.</Body-bullet>
<Body>
<A ID="pgfId-1043489"></A>
To modify the set of protected collections to which a document belongs, the user must either possess the admin role or have:</Body>
<Body-bullet>
<A ID="pgfId-1043490"></A>
Update permissions on the collection</Body-bullet>
<Body-bullet>
<A ID="pgfId-1043491"></A>
Update permissions on the document</Body-bullet>
<Body>
<A ID="pgfId-1043492"></A>
To access a protected collection in an XPath expression, the user must have read permissions on the collection. In addition, access to each of the individual documents that belong to the specified collection is governed by that individual document's read permissions. Note that access to the documents themselves (as opposed to membership in the collection) is governed by the current user's roles and the permissions associated with each document.</Body>
<Body>
<A ID="pgfId-1043493"></A>
The user can convert an unprotected collection into a protected collection using the Security Function Library module <code>
sec:protect-collection</code>
. Access to this library module is dependent on the user's having the <code>
protect-collection</code>
 privilege.</Body>
<Body>
<A ID="pgfId-1043494"></A>
The user can convert a protected collection into an unprotected collection using the Security Function Library module <code>
sec:unprotect-collection</code>
. Access to this library module is dependent on the user's having the <code>
unprotect-collection</code>
 privilege and update permissions on the protected collection. </Body>
<Heading-2>
<A ID="pgfId-1043495"></A>
<A ID="84867"></A>
Performance Characteristics</Heading-2>
<Body>
<A ID="pgfId-1043496"></A>
MarkLogic's implementation of collections is designed to optimize query performance against large volumes of documents. As with all designs, the implementation involves some trade-offs. This section provides a brief overview of the performance characteristics of collections and includes the following subsections:</Body>
<Body-bullet>
<A ID="pgfId-1044345"></A>
<A href="collections.xml#id(60039)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Number of Collections to Which a Document Belongs</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1044353"></A>
<A href="collections.xml#id(67407)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Adding/Removing Existing Documents To/From Collections</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1043497"></A>
<A ID="60039"></A>
Number of Collections to Which a Document Belongs</Heading-3>
<Body>
<A ID="pgfId-1044339"></A>
At document load time, collection information is embedded into the document and stored in the database.</Body>
<Body>
<A ID="pgfId-1043498"></A>
This design enables a MarkLogic database to handle millions of collections without difficulty. It also enables the <code>
collection()</code>
 function itself to be extremely efficient, able to subset large datasets by collection with a single index operation. If the <code>
collection()</code>
 function specifies more than one collection, an additional index operation is required for each collection specified. Assuming queries target similar collections, these index operations should be resolved within cache at extremely high performance.</Body>
<Body>
<A ID="pgfId-1043499"></A>
One trade-off with this design is a practical constraint on the number of collections to which a single document should belong. While there is no architectural limit, the size of the database will grow as the average number of collections per document increases. This database growth is driven by an increase in the size of individual document fragments. The fragment size increases because each collection to which the document belongs embeds a small amount of information in the fragment. As fragments grow, the corresponding storage I/O time increases, resulting in performance degradation. It is important to note that the average number of collections per document does not impact <Emphasis>
index resolution</Emphasis>
 time, merely the time to retrieve the content (fragments) from storage.</Body>
<Body>
<A ID="pgfId-1043500"></A>
A practical guideline is that a document with fragments averaging 50K in size should not belong to more than 100 collections. This should keep the average fragment size increase to less than 10%.</Body>
<Heading-3>
<A ID="pgfId-1043501"></A>
<A ID="67407"></A>
Adding/Removing Existing Documents To/From Collections</Heading-3>
<Body>
<A ID="pgfId-1044335"></A>
A second trade-off with MarkLogic's implementation of collections is that adding or removing documents from collections once those documents are already in the database can be relatively resource-intensive. Changing the collections to which a document belongs requires rewriting every fragment of the document. For large documents, this can be demanding on both CPU and I/O resources. If collection membership is highly dynamic in your application, a better approach may be to use elements within the document itself to characterize membership. </Body>
<Body>
<A ID="pgfId-1035177"></A>
</Body>
</XML>
