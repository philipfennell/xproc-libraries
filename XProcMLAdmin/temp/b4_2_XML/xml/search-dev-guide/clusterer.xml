<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="clusterer.css" type="text/css" charset="UTF-8"?>
<XML>
<TITLE> </TITLE><Heading-1>
<A ID="pgfId-1053802"></A>
<A ID="16886"></A>
Results Clustering Using cts:cluster</Heading-1>
<pagenum>
<A ID="pgfId-1053806"></A>
198</pagenum>
<Body>
<A ID="pgfId-1049471"></A>
MarkLogic Server includes <code>
cts:cluster</code>
, which uses statistical algorithms to find and label clusters of search results. This chapter describes <code>
cts:cluster</code>
 and includes the following sections:</Body>
<Body-bullet>
<A ID="pgfId-1053734"></A>
<A href="clusterer.xml#id(44889)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Understanding cts:cluster</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054824"></A>
<A href="clusterer.xml#id(98371)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Options to cts:cluster</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1061151"></A>
<A href="clusterer.xml#id(24368)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Understanding the cts:cluster Output</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054825"></A>
<A href="clusterer.xml#id(82771)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Example that Creates an HTML Report of the Cluster</Hyperlink>
</A></Body-bullet>
<Body>
<A ID="pgfId-1062203"></A>
For details about the signature, the parameter syntax, and more examples, see <code>
cts:cluster</code>
 in the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
.</Body>
<Heading-2>
<A ID="pgfId-1053740"></A>
<A ID="44889"></A>
Understanding cts:cluster</Heading-2>
<Body>
<A ID="pgfId-1059835"></A>
The <code>
cts:cluster</code>
 function takes a set of nodes, typically from a search result set (although it can be any set of nodes), and provides a report that categorizes the result nodes in <Emphasis>
clusters</Emphasis>
. A <Emphasis>
cluster</Emphasis>
 is a subset of the results that are statistically similar. For each cluster, it generates a label from the most distinctive terms in that cluster. </Body>
<Body>
<A ID="pgfId-1062400"></A>
The output is an XML node, and you can use the output to generate a user interface that displays the results. For sample output, see <A href="clusterer.xml#id(24368)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Understanding the cts:cluster Output' on page&#160;193</A>.</Body>
<Body>
<A ID="pgfId-1062522"></A>
The clusterer creates clusters by taking the nodes you pass into <code>
cts:cluster</code>
 and running it through the MarkLogic Server indexer. This is very similar to the process when you load a document into the database, but the indexing for results clustering is all done in memory, whereas in the database the indexes are stored to disk. The product of indexing is terms, with each term having a frequency (the number of times it occurs in the document and in the result set). Depending on which index settings you use, you will get a different set of terms. The clusterer takes into account each of the terms, as well as information about the terms (for example, weights and term frequency), to calculate the clusters.</Body>
<Body>
<A ID="pgfId-1062541"></A>
You pass options into <code>
cts:cluster</code>
 that determine the behavior of the cluster as well as specify the index settings to use when creating the clusters. For more information about the options, see <A href="clusterer.xml#id(98371)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Options to cts:cluster' on page&#160;192</A>, as well as the API documentation for <code>
cts:cluster</code>
 in the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
.</Body>
<Body>
<A ID="pgfId-1062566"></A>
When deciding how to use the clusterer, think about what your requirements are. Many settings you choose in the clusterer are trade-offs between performance and the quality of the results clusters. You might need to experiment to find what works well for your application.</Body>
<Body>
<A ID="pgfId-1062573"></A>
Note the following about the clusterer:</Body>
<Body-bullet>
<A ID="pgfId-1061995"></A>
Every time you cluster, the indexer is run on the supplied nodes to generate the data.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1062386"></A>
The more nodes you send to <code>
cts:cluster</code>
, the longer it will take. For real time analysis, more than a few thousand might get too slow for a user to wait. Ideally, between 100 and 1000 nodes is a good balance between performance and good results.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1062012"></A>
You can set <code>
&lt;hierararchical-levels&gt;</code>
 to a value of greater than 1 to generate clusters of clusters. The parent <code>
attribute</code>
 tells you which cluster is its parent. You can then iterate through the result set to create a user interface that shows the tree-like hierarchy.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1062032"></A>
The labels might change from run-to-run. Specifying a higher value of <code>
&lt;num-tries&gt;</code>
 tends to make the labels more consistent from run-to-run, but will increase the time it takes to produce the clusters.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1062043"></A>
The labels come from the most distinctive terms. Some terms (such element terms) are turned into strings. If you want to see the terms used to create the labels, set the <code>
&lt;details&gt;true&lt;/details&gt;</code>
 option.</Body-bullet>
<Heading-2>
<A ID="pgfId-1054459"></A>
<A ID="98371"></A>
Options to cts:cluster</Heading-2>
<Body>
<A ID="pgfId-1062119"></A>
You can set options to <code>
cts:cluster</code>
 in an options node. You can set the following types of options:</Body>
<Body-bullet>
<A ID="pgfId-1062143"></A>
<A href="clusterer.xml#id(58974)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Clustering (cts:cluster) Options</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1062160"></A>
<A href="clusterer.xml#id(94345)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Indexing (db:) Options</Hyperlink>
</A></Body-bullet>
<Body>
<A ID="pgfId-1062353"></A>
Each of these types of options is in its own namespace.</Body>
<Heading-3>
<A ID="pgfId-1062091"></A>
<A ID="58974"></A>
Clustering (cts:cluster) Options</Heading-3>
<Body>
<A ID="pgfId-1062112"></A>
The clustering options are in the <code>
cts:cluster</code>
 namespace. These options determine the output and the behavior of the clusterer. Note the following about the clusterer options:</Body>
<Body-bullet>
<A ID="pgfId-1062177"></A>
When tuning the options, try to balance performance, accuracy, and quality of the results. </Body-bullet>
<Body-bullet>
<A ID="pgfId-1062191"></A>
The <code>
&lt;details&gt;</code>
 option returns the distinctive terms (these are <code>
cts</code>
 terms) used for each cluster. You can use these to try and construct your own labels by generating <code>
cts:query</code>
 constructors from each term. You can then use those queries against some of your data to generate some labels, if that makes sense for your application.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1062245"></A>
The <code>
&lt;algorithm&gt;</code>
 option sets the algorithm MarkLogic Server uses to calculate the clusters: <code>
k-means</code>
 or <code>
lsi</code>
. Both are statistical algorithms and have well-known and published papers describing them (to learn more, you can start here: <Hyperlink>
<A href="http://en.wikipedia.org/wiki/K-means_clustering" xml:link="simple" show="replace" actuate="user" CLASS="URL">http://en.wikipedia.org/wiki/K-means_clustering</A></Hyperlink>
 and <Hyperlink>
<A href="http://en.wikipedia.org/wiki/Latent_semantic_indexing" xml:link="simple" show="replace" actuate="user" CLASS="URL">http://en.wikipedia.org/wiki/Latent_semantic_indexing</A></Hyperlink>
). The default is <code>
k-means</code>
, which tends to be slightly faster, but gives slightly less stable results than <code>
lsi</code>
.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1062306"></A>
You can control the number of clusters using <code>
&lt;min-clusters&gt;</code>
 and <code>
&lt;max-clusters&gt;</code>
 settings. It is possible for <code>
cts:cluster</code>
 to return less than the number of clusters in <code>
&lt;min-clusters&gt;</code>
 if the most it can calculate based on your data is less than that value.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1063713"></A>
The <code>
&lt;num-tries&gt;</code>
 option specifies the number of times to run the clusterer against the specified data. The default is 1. Because of the way the algorithms work, running the cluster multiple times will increase the number of terms, and tends to improve the accuracy of the clusters. It does so at the cost of performance, as each time it runs, it has to do more work. </Body-bullet>
<Heading-3>
<A ID="pgfId-1062105"></A>
<A ID="94345"></A>
Indexing (db:) Options</Heading-3>
<Body>
<A ID="pgfId-1062002"></A>
The indexing options control which terms are created. MarkLogic Server uses these terms to calculate the clusters, based on term frequency, distinctive terms, and other factors relating to relevancy. Note the following about the <code>
db</code>
 options:</Body>
<Body-bullet>
<A ID="pgfId-1059939"></A>
They are set in the options node, and are in the <code>
http://marklogic.com/xdmp/database</code>
 namespace.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1062133"></A>
The <code>
cts:cluster</code>
 database options are the same as the database options for <code>
cts:distinctive-terms</code>
. </Body-bullet>
<Body-bullet>
<A ID="pgfId-1062339"></A>
You can construct the options by hand or use the Admin API to construct the options.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1062022"></A>
Fields are a good way of indexing only the words you are interested in, and allows you to set weights for certain elements. For details on how fields work, see <A href="../admin/fields.xml#id(61682)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Fields Database Settings</Hyperlink>
</A> in the <Emphasis>
Administrator's Guide</Emphasis>
.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1062637"></A>
The <code>
&lt;use-db-options&gt;</code>
 <code>
cts:cluster</code>
 option (in the <code>
cts:cluster</code>
 namespace) takes the combination of the database options set in the context database, the specified database options, and any default values for options. This can be a convenient way for setting complicated options.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1062075"></A>
Iterate with different options to get the right mix of performance and term choices. </Body-bullet>
<Heading-2>
<A ID="pgfId-1061062"></A>
<A ID="24368"></A>
Understanding the cts:cluster Output</Heading-2>
<Body>
<A ID="pgfId-1061063"></A>
The following shows sample <code>
cts:cluster</code>
 output:</Body>
<Code>
<A ID="pgfId-1061752"></A>
&lt;clustering xmlns=&quot;http://marklogic.com/cts&quot;&gt;
  &lt;cluster id=&quot;15899142696064772767&quot; label=&quot;law, his, hath&quot; count=&quot;8&quot; nodes=&quot;2 11 22 24 27 30 40 78&quot;/&gt;
  &lt;cluster id=&quot;161987570467386344&quot; label=&quot;earth, lose, hast&quot; count=&quot;1&quot; nodes=&quot;28&quot;/&gt;
  &lt;cluster id=&quot;14947979602052601851&quot; label=&quot;mark, most, talbot&quot; count=&quot;91&quot; nodes=&quot;1 3 4 5 6 7 8 9 10 12 13 14 15 16 17 18 19 20 21 23 25 26 29 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100&quot;/&gt;
  &lt;cluster id=&quot;143845517505877166&quot; parent-id=&quot;15899142696064772767&quot; label=&quot;note, captain, antony&quot; count=&quot;4&quot; nodes=&quot;2 22 30 40&quot;/&gt;
  &lt;cluster id=&quot;12625796822979427066&quot; parent-id=&quot;15899142696064772767&quot; label=&quot;king, from, so&quot; count=&quot;4&quot; nodes=&quot;11 24 27 78&quot;/&gt;
  &lt;cluster id=&quot;9134217245415181471&quot; parent-id=&quot;14947979602052601851&quot; label=&quot;talbot, somerset, who&quot; count=&quot;4&quot; nodes=&quot;62 72 73 74&quot;/&gt;
  &lt;cluster id=&quot;1248501351668626361&quot; parent-id=&quot;14947979602052601851&quot; label=&quot;pompey, wall, cleopatra&quot; count=&quot;44&quot; nodes=&quot;1 4 5 6 12 13 14 19 33 34 37 39 41 42 45 46 47 48 49 50 51 53 54 55 56 58 60 61 64 65 68 71 75 77 84 87 88 89 92 95 96 97 98 99&quot;/&gt;
  &lt;cluster id=&quot;6447791006134911106&quot; parent-id=&quot;14947979602052601851&quot; label=&quot;our, voice, these&quot; count=&quot;10&quot; nodes=&quot;17 29 59 69 79 80 91 93 94 100&quot;/&gt;
  &lt;cluster id=&quot;7874080124275500326&quot; parent-id=&quot;14947979602052601851&quot; label=&quot;which, peace, blood&quot; count=&quot;33&quot; nodes=&quot;3 7 8 9 10 15 16 18 20 21 23 25 26 31 32 35 36 38 43 44 52 57 63 66 67 70 76 81 82 83 85 86 90&quot;/&gt;
  &lt;options xmlns=&quot;cts:cluster&quot; xmlns:db=&quot;http://marklogic.com/xdmp/database&quot;&gt;
    &lt;algorithm&gt;k-means&lt;/algorithm&gt;
    &lt;db:word-searches&gt;true&lt;/db:word-searches&gt;
    &lt;db:fast-phrase-searches&gt;false&lt;/db:fast-phrase-searches&gt;
    &lt;db:fast-element-word-searches&gt;true&lt;/db:fast-element-word-searches&gt;
    &lt;db:language&gt;en&lt;/db:language&gt;
    &lt;max-clusters&gt;10&lt;/max-clusters&gt;
    &lt;min-clusters&gt;3&lt;/min-clusters&gt;
    &lt;hierarchical-levels&gt;2&lt;/hierarchical-levels&gt;
    &lt;initialization&gt;smart&lt;/initialization&gt;
    &lt;max-terms&gt;200&lt;/max-terms&gt;
    &lt;label-max-terms&gt;3&lt;/label-max-terms&gt;
    &lt;label-ignore-words&gt;a as of s the when&lt;/label-ignore-words&gt;
    &lt;num-tries&gt;1&lt;/num-tries&gt;
    &lt;score&gt;logtfidf&lt;/score&gt;
    &lt;use-db-config&gt;false&lt;/use-db-config&gt;
    &lt;details&gt;false&lt;/details&gt;
    &lt;overlapping&gt;false&lt;/overlapping&gt;
  &lt;/options&gt;
&lt;/clustering&gt;</Code>
<Body>
<A ID="pgfId-1061069"></A>
The output is a <code>
cts:clustering</code>
 element. The output includes each cluster, as well as the options node used to create it. You can use XQuery or XSLT to iterate through the output, creating a report (for example, in HTML) of the results. </Body>
<Body>
<A ID="pgfId-1062413"></A>
The attributes on the <code>
&lt;cluster&gt;</code>
 element describe the cluster. The following table describes the attributes on the <code>
&lt;cluster&gt;</code>
 element:</Body>
<TABLE>
<ROW>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1062431"></A>
<code>
cluster</code>
 Attribute</CellHeading>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1062433"></A>
Description</CellHeading>
</TH>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CodeLeft>
<A ID="pgfId-1062435"></A>
id</CodeLeft>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1062437"></A>
A random number used to identify the cluster. </CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CodeLeft>
<A ID="pgfId-1062439"></A>
parent-id</CodeLeft>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1062441"></A>
The ID of the parent cluster, when <code>
&lt;hierarchical-levels&gt;</code>
 is set to a value greater than 1.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CodeLeft>
<A ID="pgfId-1062443"></A>
label</CodeLeft>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1062445"></A>
The terms that comprise the label, comma separated. To make your own label, return the <code>
&lt;details&gt;</code>
 and use the terms to generate a label.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CodeLeft>
<A ID="pgfId-1062473"></A>
count</CodeLeft>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1062475"></A>
The number of nodes in the cluster.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CodeLeft>
<A ID="pgfId-1062447"></A>
nodes</CodeLeft>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1062449"></A>
A set of NMTOKEN values, where each value lists the position of the node. The position is ordered by relevance, the first being the most relevant to the cluster and the last being the least relevant. The number refers to the position in the nodes input to <code>
cts:cluster</code>
. For example, a value of 10 indicates that it is the tenth node in the sequence passed into the first parameter of <code>
cts:cluster</code>
.</CellBody>
</CELL>
</ROW>
</TABLE>
<Heading-2>
<A ID="pgfId-1060205"></A>
<A ID="82771"></A>
Example that Creates an HTML Report of the Cluster</Heading-2>
<Body>
<A ID="pgfId-1062678"></A>
The following example creates an HTML report of the cluster. It uses the Shakespeare plays database. To see the results, cut and paste the example and run it against a database that contains the Shakespeare plays (modify the URI of the directory used in the <code>
cts:search</code>
 to the URI of the database directory in which you have loaded the Shakespeare plays).</Body>
<Code>
<A ID="pgfId-1062700"></A>
xquery version &quot;1.0-ml&quot; ;

(: cluster the Shakespeare speeches, disregarding the speaker, 
   and show the results in an html table :)

declare namespace db=&quot;http://marklogic.com/xdmp/database&quot; ;
declare namespace cl=&quot;cts:cluster&quot; ;
declare namespace dt=&quot;cts:distinctive-terms&quot; ;

(: generally we want to cluster the top N results, where N is 
   around 100 to 1,000 (smaller numbers for best performance).
   all speeches = 31,029; 
   speeches that contain &quot;love&quot; = 1,864; 
   &quot;war&quot; = 359; &quot;joy&quot; = 201; 
   &quot;beast&quot; = 94; 
   &quot;aunt&quot;=24
:)
let $search-term := xdmp:get-request-field(&quot;search-term&quot;, &quot;aunt&quot;)
let $max-terms := xdmp:get-request-field(&quot;max-terms&quot;, &quot;100&quot;)   
let $use-db-config := 
  xdmp:get-request-field(&quot;use-db-config&quot;, &quot;false&quot;)   
let $algorithm := xdmp:get-request-field(&quot;algorithm&quot;, &quot;k-means&quot;) 
let $options-node :=
   &lt;options xmlns=&quot;cts:cluster&quot; &gt;
      &lt;hierarchical-levels&gt;5&lt;/hierarchical-levels&gt;
      &lt;overlapping&gt;false&lt;/overlapping&gt;
      &lt;label-max-terms&gt;1&lt;/label-max-terms&gt;
      &lt;label-ignore-words&gt;a of the when s as&lt;/label-ignore-words&gt;
      &lt;max-clusters&gt;10&lt;/max-clusters&gt;
      &lt;algorithm&gt;{ $algorithm }&lt;/algorithm&gt;
      &lt;!-- turn all database-level indexing options OFF - only use field terms --&gt;
      &lt;db:word-searches&gt;false&lt;/db:word-searches&gt;
      &lt;db:stemmed-searches&gt;false&lt;/db:stemmed-searches&gt;
      &lt;db:fast-case-sensitive-searches&gt;false&lt;/db:fast-case-sensitive-searches&gt;
      &lt;db:fast-diacritic-sensitive-searches&gt;false&lt;/db:fast-diacritic-sensitive-searches&gt;
      &lt;db:fast-phrase-searches&gt;false&lt;/db:fast-phrase-searches&gt;
      &lt;db:phrase-throughs/&gt;
      &lt;db:phrase-arounds/&gt;
      &lt;db:fast-element-word-searches&gt;false&lt;/db:fast-element-word-searches&gt;
      &lt;db:fast-element-phrase-searches&gt;false&lt;/db:fast-element-phrase-searches&gt;
      &lt;db:element-word-query-throughs/&gt;
      &lt;db:fast-element-character-searches&gt;false&lt;/db:fast-element-character-searches&gt;
      &lt;db:range-element-indexes/&gt;
      &lt;db:range-element-attribute-indexes/&gt;
      &lt;db:one-character-searches&gt;false&lt;/db:one-character-searches&gt;
      &lt;db:two-character-searches&gt;false&lt;/db:two-character-searches&gt;
      &lt;db:three-character-searches&gt;false&lt;/db:three-character-searches&gt;
      &lt;db:trailing-wildcard-searches&gt;false&lt;/db:trailing-wildcard-searches&gt;
      &lt;db:fast-element-trailing-wildcard-searches&gt;false&lt;/db:fast-element-trailing-wildcard-searches&gt;
      &lt;db:fields&gt;
        &lt;field xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://marklogic.com/xdmp/database&quot;&gt;
          &lt;field-name&gt;speeches&lt;/field-name&gt;
          &lt;include-root&gt;false&lt;/include-root&gt;
          &lt;word-lexicons/&gt;
          &lt;!-- create stem and phrase terms for this field --&gt;
          &lt;!-- if the XML were richer, we would have used 
               fast-element-word-searches and 
               fast-element-phrase-searches too --&gt;
           &lt;stemmed-searches&gt;advanced&lt;/stemmed-searches&gt;      
           &lt;db:fast-phrase-searches&gt;true&lt;/db:fast-phrase-searches&gt;
           &lt;included-elements&gt;
            &lt;included-element&gt;
              &lt;namespace-uri/&gt;
              &lt;localname&gt;LINE&lt;/localname&gt;
              &lt;weight&gt;1.0&lt;/weight&gt;
              &lt;attribute-namespace-uri/&gt;
              &lt;attribute-localname/&gt;
              &lt;attribute-value/&gt;
            &lt;/included-element&gt;
            &lt;included-element&gt;
              &lt;namespace-uri/&gt;
              &lt;localname&gt;SPEECH&lt;/localname&gt;
              &lt;weight&gt;1.0&lt;/weight&gt;
              &lt;attribute-namespace-uri/&gt;
              &lt;attribute-localname/&gt;
              &lt;attribute-value/&gt;
            &lt;/included-element&gt;
          &lt;/included-elements&gt;
        &lt;excluded-elements&gt;
          &lt;excluded-element&gt;
            &lt;namespace-uri/&gt;
            &lt;localname&gt;SPEAKER&lt;/localname&gt;
          &lt;/excluded-element&gt;
         &lt;/excluded-elements&gt;
        &lt;/field&gt;
     &lt;/db:fields&gt;
  &lt;/options&gt;

(: build the page :)
let $page :=
&lt;html&gt;
&lt;head&gt;&lt;title&gt;Example - clustering - speeches&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;table border=&quot;1&quot; cellpadding=&quot;1&quot; cellspacing=&quot;1&quot;&gt;
	&lt;tr&gt;
		&lt;th&gt;Label&lt;/th&gt;
		&lt;th&gt;Count&lt;/th&gt;
		&lt;th&gt;Speakers&lt;/th&gt;
	&lt;/tr&gt;
	{
let $things-to-cluster := 
  cts:search(
&#160;&#160;&#160;&#160;&#160;(: specify the directory in which you have loaded the plays :)
     xdmp:directory( &quot;/shakespeare/plays/&quot; )//SPEECH, 
        $search-term 
        )
(: iterate through the cts:cluster results node :)
for $cluster in 
    cts:cluster( $things-to-cluster, $options-node )/cts:cluster
return 
    &lt;tr&gt;
     &lt;td&gt;{ fn:data( $cluster/@label ) }&lt;/td&gt;
     &lt;td&gt;{ fn:data( $cluster/@count ) }&lt;/td&gt;
     &lt;td&gt;
       &lt;table&gt;{
 for $clustered-node-ref in fn:data( $cluster/@nodes )
 return
     &lt;tr&gt;&lt;td&gt;{ fn:string( 
       $things-to-cluster[$clustered-node-ref]//SPEAKER ) 
     }&lt;/td&gt;&lt;/tr&gt;
       }&lt;/table&gt;
      &lt;/td&gt;
     &lt;/tr&gt;}
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;

return ( xdmp:set-response-content-type(&quot;text/html&quot;), 
 $page, xdmp:elapsed-time() )</Code>
</XML>
