<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="cts_query.css" type="text/css" charset="UTF-8"?>
<XML>
<TITLE> </TITLE><Heading-1>
<A ID="pgfId-1053802"></A>
<A ID="51991"></A>
Composing cts:query Expressions</Heading-1>
<pagenum>
<A ID="pgfId-1053806"></A>
69</pagenum>
<Body>
<A ID="pgfId-1049471"></A>
Searches in MarkLogic Server use expressions that have a <code>
cts:query</code>
 type. This chapter describes how to create various types of <code>
cts:query</code>
 expressions and how you can register some complex expressions to improve performance of future queries that use the registered <code>
cts:query</code>
 expressions. </Body>
<Body>
<A ID="pgfId-1053959"></A>
MarkLogic Server includes many Built-In XQuery functions to compose <code>
cts:query</code>
 expressions. The signatures and descriptions of the various APIs are described in the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
.</Body>
<Body>
<A ID="pgfId-1053933"></A>
This chapter includes the following sections:</Body>
<Body-bullet>
<A ID="pgfId-1053734"></A>
<A href="cts_query.xml#id(78927)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Understanding cts:query</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1053738"></A>
<A href="cts_query.xml#id(23243)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Combining multiple cts:query Expressions</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1060602"></A>
<A href="cts_query.xml#id(88078)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Joining Documents and Properties with cts:properties-query or cts:document-fragment-query</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1053739"></A>
<A href="cts_query.xml#id(94745)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Registering cts:query Expressions to Speed Search Performance</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055770"></A>
<A href="cts_query.xml#id(17375)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Adding Relevance Information to cts:query Expressions:</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1060109"></A>
<A href="cts_query.xml#id(11229)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
XML Serializations of cts:query Constructors</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055019"></A>
<A href="cts_query.xml#id(70088)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Example: Creating a cts:query Parser</Hyperlink>
</A></Body-bullet>
<Heading-2>
<A ID="pgfId-1053740"></A>
<A ID="78927"></A>
Understanding cts:query</Heading-2>
<Body>
<A ID="pgfId-1056123"></A>
The second parameter for <code>
cts:search</code>
 takes a parameter of <code>
cts:query</code>
 type. The contents of the <code>
cts:query</code>
 expression determines the conditions in which a search will return a document or node. This section describes <code>
cts:query</code>
 and includes the following parts:</Body>
<Body-bullet>
<A ID="pgfId-1053891"></A>
<A href="cts_query.xml#id(81461)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
cts:query Hierarchy</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1053895"></A>
<A href="cts_query.xml#id(32071)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Use to Narrow the Search</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054997"></A>
<A href="cts_query.xml#id(26158)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Understanding cts:element-query</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1056139"></A>
<A href="cts_query.xml#id(84195)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Understanding cts:element-word-query</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1056553"></A>
<A href="cts_query.xml#id(92171)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Understanding the Range Query Constructors</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1059977"></A>
<A href="cts_query.xml#id(18619)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Understanding the Reverse Query Constructor</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1060072"></A>
<A href="cts_query.xml#id(75774)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Understanding the Geospatial Query Constructors</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1056598"></A>
<A href="cts_query.xml#id(67470)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Specifying the Language in a cts:query</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1056141"></A>
<A ID="81461"></A>
cts:query Hierarchy</Heading-3>
<Body>
<A ID="pgfId-1056142"></A>
The <code>
cts:query</code>
 type forms a hierarchy, allowing you to construct complex <code>
cts:query</code>
 expressions by combining multiple expressions together. The hierarchy includes composable and non-composable <code>
cts:query</code>
 constructors. A <Emphasis>
composable</Emphasis>
 constructor is one that is used to combine multiple <code>
cts:query</code>
 constructors together. A <Emphasis>
leaf-level</Emphasis>
 constructor is one that cannot be used to combine with other <code>
cts:query</code>
 constructors (although it can be combined using a composable constructor). The following diagram shows the leaf-level <code>
cts:query</code>
 constructors, which are not composable, and the composable <code>
cts:query</code>
 constructors, which you can use to combine both leaf-level and other composable <code>
cts:query</code>
 constructors. For more details on combining <code>
cts:query</code>
 constructors, see the remainder of this chapter.</Body>
<Body>
<A ID="pgfId-1054643"></A>
<IMAGE xml:link="simple" href="cts_query-1.gif" show="embed" actuate="auto"/>
</Body>
<Heading-3>
<A ID="pgfId-1053905"></A>
<A ID="32071"></A>
Use to Narrow the Search</Heading-3>
<Body>
<A ID="pgfId-1053927"></A>
The core search <code>
cts:query</code>
 API is <code>
cts:word-query</code>
. The <code>
cts:word-query</code>
 function returns true for words or phrases that matches its <code>
$text</code>
 parameter, thus narrowing the search to fragments containing terms that match the query. If needed, you can use other <code>
cts:query</code>
 APIs to combine a <code>
cts:word-query</code>
 expression into a more complex expression. Similarly, you can use the other leaf-level cts:query constructors to narrow the results of a search.</Body>
<Heading-3>
<A ID="pgfId-1053928"></A>
<A ID="26158"></A>
Understanding cts:element-query</Heading-3>
<Body>
<A ID="pgfId-1053932"></A>
The <code>
cts:element-query</code>
 function searches through a specified element and all of its children. It is used to narrow the field of search to the specified element hierarchy, exploiting the XML structure in the data. Also, it is composable with other <code>
cts:element-query</code>
 functions, allowing you to specify complex hierarchical conditions in the <code>
cts:query</code>
 expressions. </Body>
<Body>
<A ID="pgfId-1054540"></A>
For example, the following search against a Shakespeare database returns the title of any play that has SCENE elements that have SPEECH elements containing both the words 'room' and 'castle':</Body>
<Code>
<A ID="pgfId-1054551"></A>
for $x in cts:search(fn:doc(), 
   cts:element-query(xs:QName(&quot;SCENE&quot;), 
       cts:element-query(xs:QName(&quot;SPEECH&quot;), 
           cts:and-query((&quot;room&quot;, &quot;castle&quot;)) ) ) ) 
return
($x//TITLE)[1]</Code>
<Body>
<A ID="pgfId-1054569"></A>
This query returns the first <code>
TITLE</code>
 element of the play. The <code>
TITLE</code>
 element is used for both play and scene titles, and the first one in a play is the title of the play.</Body>
<Body>
<A ID="pgfId-1056041"></A>
When you use <code>
cts:element-query</code>
 and you have both the <code>
word positions</code>
 and <code>
element word positions</code>
 indexes enabled in the Admin Interface, it will speed the performance of many queries that have multiple term queries (for example, <code>
&quot;the long sly fox&quot;</code>
) by eliminating some false positive results.</Body>
<Heading-3>
<A ID="pgfId-1053896"></A>
<A ID="84195"></A>
Understanding cts:element-word-query</Heading-3>
<Body>
<A ID="pgfId-1054568"></A>
While <code>
cts:element-query</code>
 searches through an element and all of its children, <code>
cts:element-word-query</code>
 searches only the immediate text node children of the specified element. For example, consider the following XML structure:</Body>
<Code>
<A ID="pgfId-1054597"></A>
&lt;root&gt;
&#160;&#160;&lt;a&gt;hello
&#160;&#160;&#160;&#160;&lt;b&gt;goodbye&lt;/b&gt;
&#160;&#160;&lt;a&gt;
&lt;/root&gt;</Code>
<Body>
<A ID="pgfId-1054615"></A>
The following query returns <code>
false</code>
, because <code>
&quot;goodbye&quot;</code>
 is not an immediate text node of the element named <code>
a</code>
:</Body>
<Code>
<A ID="pgfId-1054619"></A>
cts:element-word-query(xs:QName(&quot;a&quot;), &quot;goodbye&quot;)</Code>
<Heading-3>
<A ID="pgfId-1056557"></A>
<A ID="92171"></A>
Understanding the Range Query Constructors</Heading-3>
<Body>
<A ID="pgfId-1056561"></A>
The <code>
cts:element-range-query</code>
 and <code>
cts:element-atribute-range-query</code>
 constructors allow you to specify constraints on a value in a <code>
cts:query</code>
 expression. The range query constructors require a range index on the specified element or attribute. For details on range queries, see <A href="rangequery.xml#id(19990)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Using Range Queries in cts:query Expressions' on page&#160;92</A>.</Body>
<Heading-3>
<A ID="pgfId-1056247"></A>
<A ID="18619"></A>
Understanding the Reverse Query Constructor</Heading-3>
<Body>
<A ID="pgfId-1059976"></A>
The <code>
cts:reverse-query</code>
 constructor allows you to match queries stored in a database to nodes that would match those queries. Reverse queries are used as the basis for alert applications. For details, see <A href="alerts.xml#id(86523)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Creating Alerting Applications' on page&#160;119</A>.</Body>
<Heading-3>
<A ID="pgfId-1060068"></A>
<A ID="75774"></A>
Understanding the Geospatial Query Constructors</Heading-3>
<Body>
<A ID="pgfId-1060077"></A>
The geospatial query constructors are used to constrain <code>
cts:query</code>
 expressions on geospatial data. Geospatial searches are used with documents that have been marked up with latitude and longitude data, and can be used to answer queries like 'show me all of the documents that mention places within 100 miles of New York City.' For details on gesospatial searches, see <A href="geospatial.xml#id(86523)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Geospatial Search Applications' on page&#160;104</A>.</Body>
<Heading-3>
<A ID="pgfId-1059975"></A>
<A ID="67470"></A>
Specifying the Language in a cts:query</Heading-3>
<Body>
<A ID="pgfId-1056603"></A>
All leaf-level <code>
cts:query</code>
 constructors are language-aware; you can either explicitly specify a language value as an option, or it will default to the database default language. The language option specifies the language in which the query is tokenized and, for stemmed searches, the language of the content to be searched. </Body>
<Body>
<A ID="pgfId-1056620"></A>
To specify the language option in a <code>
cts:query</code>
, use the <code>
lang=</code>
<Emphasis>
language_code</Emphasis>
, where <Emphasis>
language_code</Emphasis>
 is the two or three character ISO 639-1 or ISO 639-2 language code (<Hyperlink>
<A href="http://www.loc.gov/standards/iso639-2/php/code_list.php" xml:link="simple" show="replace" actuate="user" CLASS="URL">http://www.loc.gov/standards/iso639-2/php/code_list.php</A></Hyperlink>
). For example, the following query:</Body>
<Code>
<A ID="pgfId-1056626"></A>
let $x := 
&lt;root&gt;
 &lt;el xml:lang=&quot;en&quot;&gt;hello&lt;/el&gt;
 &lt;el xml:lang=&quot;fr&quot;&gt;hello&lt;/el&gt;
&lt;/root&gt;
return
$x//el[cts:contains(., 
         cts:word-query(&quot;hello&quot;, (&quot;stemmed&quot;, &quot;lang=fr&quot;)))]</Code>
<Body>
<A ID="pgfId-1056664"></A>
returns only the French-language node:</Body>
<Code>
<A ID="pgfId-1056665"></A>
&lt;el xml:lang=&quot;fr&quot;&gt;hello&lt;/el&gt;</Code>
<Body>
<A ID="pgfId-1056615"></A>
Depending on the language of the <code>
cts:query</code>
 and on the language of the content, a string will tokenize differently, which will affect the search results. For details on how languages and the <code>
xml:lang</code>
 attribute affect tokenization and searches, see <A href="languages.xml#id(40505)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Language Support in MarkLogic Server' on page&#160;198</A>. </Body>
<Heading-2>
<A ID="pgfId-1056599"></A>
<A ID="23243"></A>
Combining multiple cts:query Expressions</Heading-2>
<Body>
<A ID="pgfId-1054386"></A>
Because <code>
cts:query</code>
 expressions are composable, you can combine multiple expressions to form a single expression. There is no limit to how complex you can make a <code>
cts:query</code>
 expressions. Any API that has a return type of <code>
cts:*</code>
 (for example, <code>
cts:query</code>
, <code>
cts:and-query</code>
, and so on) can be composed with another <code>
cts:query</code>
 expression to form another expression. This section has the following parts:</Body>
<Body-bullet>
<A ID="pgfId-1056311"></A>
<A href="cts_query.xml#id(80981)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Using cts:and-query and cts:or-query</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1056319"></A>
<A href="cts_query.xml#id(16574)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Proximity Queries using cts:near-query</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1056324"></A>
<A href="cts_query.xml#id(14002)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Using Bounded cts:query Expressions</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1056353"></A>
<A href="cts_query.xml#id(71643)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Matching Nothing and Matching Everything</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1054387"></A>
<A ID="80981"></A>
Using cts:and-query and cts:or-query</Heading-3>
<Body>
<A ID="pgfId-1053865"></A>
You can construct arbitrarily complex boolean logic by combining <code>
cts:and-query</code>
 and <code>
cts:or-query</code>
 constructors in a single <code>
cts:query</code>
 expression. </Body>
<Body>
<A ID="pgfId-1054347"></A>
For example, the following search with a relatively simple nested <code>
cts:query</code>
 expression will return all fragments that contain either the word <code>
alfa</code>
 or the word <code>
maserati</code>
, and also contain either the word <code>
saab</code>
 or the word <code>
volvo</code>
.</Body>
<Code>
<A ID="pgfId-1054325"></A>
cts:search(fn:doc(),
&#160;&#160;cts:and-query(&#160;( cts:or-query((&quot;alfa&quot;, &quot;maserati&quot;)), 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cts:or-query((&quot;saab&quot;, &quot;volvo&quot;)&#160;)
&#160;&#160;)&#160;)
)</Code>
<Body>
<A ID="pgfId-1054651"></A>
Additionally, you can use <code>
cts:and-not-query</code>
 and <code>
cts:not-query</code>
 to add negation to your boolean logic.</Body>
<Heading-3>
<A ID="pgfId-1054309"></A>
<A ID="16574"></A>
Proximity Queries using cts:near-query</Heading-3>
<Body>
<A ID="pgfId-1054672"></A>
You can add tests for proximity to a <code>
cts:query</code>
 expression using <code>
cts:near-query</code>
. Proximity queries use the <code>
word positions</code>
 index in the database and, if you are using <code>
cts:element-query</code>
, the <code>
element word positions</code>
 index. Proximity queries will still work without these indexes, but the indexes will speed performance of queries that use <code>
cts:near-query</code>
.</Body>
<Body>
<A ID="pgfId-1054688"></A>
Proximity queries return <code>
true</code>
 if the query matches occur within the specified distance from each other. For more details, see the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
 for <code>
cts:near-query</code>
.</Body>
<Heading-3>
<A ID="pgfId-1054671"></A>
<A ID="14002"></A>
Using Bounded cts:query Expressions</Heading-3>
<Body>
<A ID="pgfId-1054310"></A>
The following <code>
cts:query</code>
 constructors allow you to bound a <code>
cts:query</code>
 expression to one or more documents, a directory, or one or more collections.</Body>
<Body-bullet>
<A ID="pgfId-1053880"></A>
<code>
cts:document-query</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1053884"></A>
<code>
cts:directory-query</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1053872"></A>
<code>
cts:collection-query</code>
</Body-bullet>
<Body>
<A ID="pgfId-1054415"></A>
These bounding constructors allow you to narrow a set of search results as part of the second parameter to <code>
cts:search</code>
. Bounding the query in the <code>
cts:query</code>
 expression is much more efficient than filtering results in a <code>
where</code>
 clause, and is often more convenient than modifying the XPath in the first <code>
cts:search</code>
 parameter. To combine a bounded <code>
cts:query</code>
 constructor with another constructor, use a <code>
cts:and-query</code>
 or a <code>
cts:or-query</code>
 constructor.</Body>
<Body>
<A ID="pgfId-1054436"></A>
For example, the following constrains a search to a particular directory, returning the URI of the document(s) that match the <code>
cts:query</code>
.</Body>
<Code>
<A ID="pgfId-1054458"></A>
for $x in cts:search(fn:doc(), 
   cts:and-query((
     cts:directory-query(&quot;/shakespeare/plays/&quot;, &quot;infinity&quot;), 
         &quot;all's well that&quot;))
)
return xdmp:node-uri($x)</Code>
<Body>
<A ID="pgfId-1056063"></A>
This query returns the URI of all documents under the specified directory that satisfy the query <code>
&quot;all's well that&quot;</code>
.</Body>
<Note>
<A ID="pgfId-1054472"></A>
In this query, the query <code>
&quot;all's well that&quot;</code>
 is equivalent to a <code>
cts:word-query(&quot;all's&#160;well&#160;that&quot;)</code>
.</Note>
<Heading-3>
<A ID="pgfId-1056334"></A>
<A ID="71643"></A>
Matching Nothing and Matching Everything</Heading-3>
<Body>
<A ID="pgfId-1056335"></A>
An empty <code>
cts:word-query</code>
 will always match no fragments, and an empty <code>
cts:and-query</code>
 will always match all fragments. Therefore the following are true:</Body>
<Code>
<A ID="pgfId-1056336"></A>
cts:search(fn:doc(), cts:word-query(&quot;&quot;) )
=&gt; returns the empty sequence</Code>
<Code>
<A ID="pgfId-1056337"></A>
cts:search(fn:doc(), &quot;&quot; )
=&gt; returns the empty sequence</Code>
<Code>
<A ID="pgfId-1056338"></A>
cts:search(fn:doc(), cts:and-query( () ) )
=&gt; returns every fragment in the database</Code>
<Body>
<A ID="pgfId-1056339"></A>
One use for an empty <code>
cts:word-query</code>
 is when you have a search box that an end user enters terms to search for. If the user enters nothing and hits the submit button, then the corresponding cts:search will return no hits.</Body>
<Body>
<A ID="pgfId-1056340"></A>
An empty <code>
cts:and-query</code>
 that matches everything is sometimes useful when you need a <code>
cts:query</code>
 to match everything.</Body>
<Heading-2>
<A ID="pgfId-1053977"></A>
<A ID="88078"></A>
Joining Documents and Properties with cts:properties-query or cts:document-fragment-query</Heading-2>
<Body>
<A ID="pgfId-1060620"></A>
You can use a <code>
cts:properties-query</code>
 to match content in properties document. If you are searching over a document, then a <code>
cts:properties-query</code>
 will search in the properties document at the URI of the document. The <code>
cts:properties-query</code>
 joins the properties document with its corresponding document. The <code>
cts:properties-query</code>
 takes a <code>
cts:query</code>
 as a parameter, and that query is used to match against the properties document. A <code>
cts:properties-query</code>
 is composable, so you can combine it with other <code>
cts:query</code>
 constructors to create arbitrarily complex queries.</Body>
<Body>
<A ID="pgfId-1060754"></A>
Using a <code>
cts:properties-query</code>
 in a <code>
cts:search</code>
, you can easily create a query that returns results that join content in a document with content in the corresponding properties document. For example, consider a document that represents a chapter in a book, and the document has properties containing the publisher of the book. you can then write a search that returns documents that match a cts:query where the document has a specific publisher, as in the following example:</Body>
<Code>
<A ID="pgfId-1060793"></A>
cts:search(collection(), cts:and-query((
&#160;&#160;cts:properties-query(
&#160;&#160;&#160;&#160;cts:element-value-query(xs:QName(&quot;publisher&quot;), &quot;My Press&quot;) ),
&#160;&#160;cts:word-query(&quot;a small good thing&quot;) )) )</Code>
<Body>
<A ID="pgfId-1060825"></A>
This query returns all documents with the phrase <code>
a small good thing</code>
 and that have a value of <code>
My&#160;Press</code>
 in the <code>
publisher</code>
 element in their corresponding properties document.</Body>
<Body>
<A ID="pgfId-1061080"></A>
Similarly, you can use <code>
cts:document-fragment-query</code>
 to join documents against properties when searching over properties.</Body>
<Heading-2>
<A ID="pgfId-1060613"></A>
<A ID="94745"></A>
Registering cts:query Expressions to Speed Search Performance</Heading-2>
<Body>
<A ID="pgfId-1053749"></A>
If you use the same complex <code>
cts:query</code>
 expressions repeatedly, and if you are using them as an <Emphasis>
unfiltered</Emphasis>
 <code>
cts:query</code>
 constructor, you can register the <code>
cts:query</code>
 expressions for later use. Registering a <code>
cts:query</code>
 expression stores a pre-evaluated version of the expression, making it faster for subsequent queries to use the same expression. Unfiltered constructors return results directly from the indexes and return all candidate fragments for a search, but do not perform post-filtering to validate that each fragment perfectly meets the search criteria. For details on unfiltered searches, see 'Using Unfiltered Searches for Fast Pagination' in the <Emphasis>
Query Performance and Tuning Guide</Emphasis>
.</Body>
<Body>
<A ID="pgfId-1055801"></A>
This section describes registered queries and provides some examples of how to use them. It includes the following topics:</Body>
<Body-bullet>
<A ID="pgfId-1055802"></A>
<A href="cts_query.xml#id(11441)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Registered Query APIs</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055806"></A>
<A href="cts_query.xml#id(64447)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Must Be Used Unfiltered</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055839"></A>
<A href="cts_query.xml#id(59941)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Registration Does Not Survive System Restart</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055807"></A>
<A href="cts_query.xml#id(28990)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Storing Registered Query IDs</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1060935"></A>
<A href="cts_query.xml#id(17828)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Registered Queries and Relevance Calculations</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1056012"></A>
<A href="cts_query.xml#id(12894)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Example: Registering and Using a cts:query Expression</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1055808"></A>
<A ID="11441"></A>
Registered Query APIs</Heading-3>
<Body>
<A ID="pgfId-1054278"></A>
To register and reuse unfiltered searches for <code>
cts:query</code>
 expressions, use the following XQuery APIs:</Body>
<Body-bullet>
<A ID="pgfId-1054293"></A>
<code>
cts:register</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054301"></A>
<code>
cts:registered-query</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054282"></A>
<code>
cts:deregister</code>
</Body-bullet>
<Body>
<A ID="pgfId-1055825"></A>
For the syntax of these functions, see the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
.</Body>
<Heading-3>
<A ID="pgfId-1055812"></A>
<A ID="64447"></A>
Must Be Used Unfiltered</Heading-3>
<Body>
<A ID="pgfId-1055816"></A>
You can only use registered queries on unfiltered constructors; using a registered query as a filtered constructor throws the <code>
XDMP-REGFLT</code>
 exception. To specify an unfiltered constructor, use the <code>
&quot;unfiltered&quot;</code>
 option to <code>
cts:registered-query</code>
. For details about unfiltered searches, see see 'Using Unfiltered Searches for Fast Pagination' in the <Emphasis>
Query Performance and Tuning Guide</Emphasis>
. </Body>
<Heading-3>
<A ID="pgfId-1055817"></A>
<A ID="59941"></A>
Registration Does Not Survive System Restart</Heading-3>
<Body>
<A ID="pgfId-1055833"></A>
Registered queries are only stored in the memory cache, and if the cache grows too big, some registered queries might be aged out of the cache. Also, if MarkLogic Server stops or restarts, any queries that were registered are lost and must be re-registered. </Body>
<Body>
<A ID="pgfId-1055840"></A>
If you attempt to call <code>
cts:registered-query</code>
 in a <code>
cts:search</code>
 and the query is not currently registered, it throws an <code>
XDMP-UNREGISTERED</code>
 exception. Because registered queries are not guaranteed to be registered every time they are used, it is good practice to use a <code>
try/catch</code>
 around calls to <code>
cts:registered-query</code>
, and re-register the query in the <code>
catch</code>
 if the it throws an <code>
XDMP-UNREGISTERED</code>
 exception. </Body>
<Body>
<A ID="pgfId-1055874"></A>
For example, the following sample code shows a <code>
cts:registered-query</code>
 call used with a try/catch expression in XQuery:</Body>
<Code>
<A ID="pgfId-1055888"></A>
(: wrap the registered query in a try/catch :)
try{
xdmp:estimate(cts:search(fn:doc(), 
  cts:registered-query(995175721241192518, &quot;unfiltered&quot;)))
}
catch ($e) 
{
let $registered := 'cts:register(
		cts:word-query(&quot;hello*world&quot;, &quot;wildcarded&quot;))'
return
if ( fn:contains($e/*:code/text(), &quot;XDMP-UNREGISTERED&quot;) )
then ( &quot;retry this query with the following registered query ID: &quot;,
       xdmp:eval($registered) )
else ( $e ) 
}</Code>
<Body>
<A ID="pgfId-1055914"></A>
This code is somewhat simplified: it catches the <code>
XDMP-UNREGISTERED</code>
 exception and simply reports what the new registered query ID is. In an application that uses registered queries, you probably would want to re-run the query with the new registered ID. Also, this example performs the <code>
try/catch</code>
 in XQuery. If you are using XCC to issue queries against MarkLogic Server, you can instead perform the <code>
try/catch</code>
 in the middleware Java or .NET layer.</Body>
<Heading-3>
<A ID="pgfId-1055832"></A>
<A ID="28990"></A>
Storing Registered Query IDs</Heading-3>
<Body>
<A ID="pgfId-1060882"></A>
When you register a <code>
cts:query</code>
 expression, the <code>
cts:register</code>
 function returns an integer, which is the ID for the registered query. After the <code>
cts:register</code>
 call returns, there is no way to query the system to find the registered query IDs. Therefore, you might need to store the IDs somewhere. You can either store them in the middleware layer (if you are using XCC to issue queries against MarkLogic Server) or you can store them in a document in MarkLogic Server.</Body>
<Body>
<A ID="pgfId-1060889"></A>
The registered query ID is generated based on a hash of the actual query, so registering the same query multiple times results in the same ID. The registered query ID is valid for all queries against the database across the entire cluster. </Body>
<Heading-3>
<A ID="pgfId-1060891"></A>
<A ID="17828"></A>
Registered Queries and Relevance Calculations</Heading-3>
<Body>
<A ID="pgfId-1060916"></A>
Searches that use registered queries will generate results having different scores from the equivalent searches using a non-registered queries. This is because registered queries are treated as a single term in the relevance calculation. For details on relevance calculations, see <A href="relevance.xml#id(86523)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Relevance Scores: Understanding and Customizing' on page&#160;70</A>.</Body>
<Heading-3>
<A ID="pgfId-1060905"></A>
<A ID="12894"></A>
Example: Registering and Using a cts:query Expression</Heading-3>
<Body>
<A ID="pgfId-1060892"></A>
To run a registered query, you first register the query and then run the registered query, specifying it by ID. This section describes some example steps for registering a query and then running the registered query.</Body>
<Number1>
<A ID="pgfId-1055968"></A>
First register the <code>
cts:query</code>
 expression you want to run, as in the following example:</Number1>
<Code>
<A ID="pgfId-1055981"></A>
cts:register(cts:word-query(&quot;hello*world&quot;, &quot;wildcarded&quot;))</Code>
<NumberList>
<Number>
<A ID="pgfId-1055976"></A>
The first step returns an integer. Keep track of the integer value (for example, store it in a document).</Number>
<Number>
<A ID="pgfId-1055991"></A>
Use the integer value to run a search with the registered query (with the <code>
&quot;unfiltered&quot;</code>
 option) as follows:</Number>
</NumberList>
<Code>
<A ID="pgfId-1055992"></A>
cts:search(fn:doc(), 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cts:registered-query(987654321012345678, &quot;unfiltered&quot;) ) </Code>
<Heading-2>
<A ID="pgfId-1053919"></A>
<A ID="17375"></A>
Adding Relevance Information to cts:query Expressions:</Heading-2>
<Body>
<A ID="pgfId-1055772"></A>
The leaf-level <code>
cts:query</code>
 APIs (<code>
cts:word-query</code>
, <code>
cts:element-word-query</code>
, and so on) have a weight parameter, which allows you to add a multiplication factor to the scores produced by matches from a query. You can use this to increase or decrease the weight factor for a particular query. For details about score, weight, and relevance calculations, see <A href="relevance.xml#id(86523)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Relevance Scores: Understanding and Customizing' on page&#160;70</A>.</Body>
<Heading-2>
<A ID="pgfId-1060104"></A>
<A ID="11229"></A>
XML Serializations of cts:query Constructors</Heading-2>
<Body>
<A ID="pgfId-1060108"></A>
You can create an XML serialization of a <code>
cts:query</code>
. The XML serialization is used by alerting applications that use a <code>
cts:reverse-query</code>
 constructor and is also useful to perform various programmatic tasks to a <code>
cts:query</code>
. Alerting applications (see <A href="alerts.xml#id(86523)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Creating Alerting Applications' on page&#160;119</A>) find queries that would match nodes, and then perform some action for the query matches. This section describes the serialized XML and includes the following parts:</Body>
<Body-bullet>
<A ID="pgfId-1060177"></A>
<A href="cts_query.xml#id(92772)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Serializing a cts:query to XML</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1060185"></A>
<A href="cts_query.xml#id(49238)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Function to Construct a cts:query From XML</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1060154"></A>
<A ID="92772"></A>
Serializing a cts:query to XML</Heading-3>
<Body>
<A ID="pgfId-1060168"></A>
A serialized <code>
cts:query</code>
 has XML that conforms to the <code>
&lt;</code>
<Emphasis>
marklogic-dir</Emphasis>
<code>
&gt;/Config/cts.xsd</code>
 schema, which is in the <code>
http://marklogic.com/cts</code>
 namespace, which is bound to the <code>
cts</code>
 prefix. You can either construct the XML directly or, if you use any <code>
cts:query</code>
 expression within the context of an element, MarkLogic Server will automatically serialize that <code>
cts:query</code>
 to XML. Consider the following example:</Body>
<Code>
<A ID="pgfId-1060428"></A>
&lt;some-element&gt;{cts:word-query(&quot;hello world&quot;)}&lt;/some-element&gt;</Code>
<Body>
<A ID="pgfId-1060429"></A>
When you run the above expression, it serializes to the following XML:</Body>
<Code>
<A ID="pgfId-1060438"></A>
&lt;some-element&gt;
&#160;&#160;&lt;cts:word-query xmlns:cts=&quot;http://marklogic.com/cts&quot;&gt;
&#160;&#160;&#160;&#160;&lt;cts:text xml:lang=&quot;en&quot;&gt;hello world&lt;/cts:text&gt;
&#160;&#160;&lt;/cts:word-query&gt;
&lt;/some-element&gt;</Code>
<Body>
<A ID="pgfId-1060453"></A>
If you are using an alerting application, you might choose to store this XML in the database so you can match searches that include <code>
cts:reverse-query</code>
 constructors. For details on alerts, see <A href="alerts.xml#id(86523)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Creating Alerting Applications' on page&#160;119</A>.</Body>
<Heading-3>
<A ID="pgfId-1060176"></A>
Add Arbitrary Annotations With cts:annotate</Heading-3>
<Body>
<A ID="pgfId-1060279"></A>
You can annotate your <code>
cts:query</code>
 XML with <code>
cts:annotate</code>
 elements. A <code>
cts:annotate</code>
 element can be a child of any element in the <code>
cts:query</code>
 XML, and it can consist of any valid XML content (for example, a single text node, a single element, multiple elements, complex elements, and so on). MarkLogic Server ignores these annotations when processing the query XML, but such annotations are often useful to the application. For example, you can store information about where the query came from, information about parts of the query to use or not in certain parts of the application, and so on. The following is some sample XML with <code>
cts:annotation</code>
 elements:</Body>
<Code>
<A ID="pgfId-1060348"></A>
&lt;cts:and-query xmlns:cts=&quot;http://marklogic.com/cts&quot;&gt;
&#160;&#160;&lt;cts:directory-query&gt;
    &lt;cts:annotation&gt;private&lt;/cts:annotation&gt;
    &lt;cts:uri&gt;/myprivate-dir/&lt;/cts:uri&gt;
  &lt;/cts:directory-query&gt;
  &lt;cts:and-query&gt;
    &lt;cts:word-query&gt;&lt;cts:text&gt;hello&lt;/cts:text&gt;&lt;/cts:word-query&gt;
    &lt;cts:word-query&gt;&lt;cts:text&gt;world&lt;/cts:text&gt;&lt;/cts:word-query&gt;
  &lt;/cts:and-query&gt;
  &lt;cts:annotation&gt;
&#160;&#160;&#160;&#160;&lt;useful&gt;something useful to the application here&lt;/useful&gt;
&#160;&#160;&lt;/cts:annotation&gt;
&lt;/cts:and-query&gt;</Code>
<Body>
<A ID="pgfId-1060295"></A>
For another example that uses <code>
cts:annotate</code>
 to store the original query string in a function that generates a <code>
cts:query</code>
 from a string, see the last part of the example in <A href="cts_query.xml#id(11229)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'XML Serializations of cts:query Constructors' on page&#160;65</A>.</Body>
<Heading-3>
<A ID="pgfId-1060161"></A>
<A ID="49238"></A>
Function to Construct a cts:query From XML</Heading-3>
<Body>
<A ID="pgfId-1060126"></A>
You can turn an XML serialization of a cts:query back into an un-serialized cts:query with the <code>
cts:query</code>
 function. For example, you can turn a serialized <code>
cts:query</code>
 back into a <code>
cts:query</code>
 as follows:</Body>
<Code>
<A ID="pgfId-1060135"></A>
cts:query(
  &lt;cts:word-query xmlns:cts=&quot;http://marklogic.com/cts&quot;&gt;
    &lt;cts:text&gt;word&lt;/cts:text&gt;
  &lt;/cts:word-query&gt;
)
(: returns: cts:word-query(&quot;word&quot;, (&quot;lang=en&quot;), 1) :)</Code>
<Heading-2>
<A ID="pgfId-1055771"></A>
<A ID="70088"></A>
Example: Creating a cts:query Parser</Heading-2>
<Body>
<A ID="pgfId-1053923"></A>
The following sample code shows a simple query string parser that parses double-quote marks to be a phrase, and considers anything else that is separated by one or more spaces to be a single term. If needed, you can use the same design pattern to add other logic to do more complex parsing (for example, OR processing or NOT processing).</Body>
<Code>
<A ID="pgfId-1055462"></A>
xquery version &quot;1.0-ml&quot;;
declare function local:get-query-tokens($input as xs:string?) 
&#160;&#160;as element() {
(: This parses double-quotes to be exact matches. :)
&lt;tokens&gt;{
let $newInput := fn:string-join(
(: check if there is more than one double-quotation mark.  If there is, 
   tokenize on the double-quotation mark (&quot;), then change the spaces
   in the even tokens to the string &quot;!+!&quot;.  This will then allow later
   tokenization on spaces, so you can preserve quoted phrases as phrase
   searches (after re-replacing the &quot;!+!&quot; strings with spaces).  :)
    if ( fn:count(fn:tokenize($input, '&quot;')) &gt; 2 )
    then ( for $i at $count in fn:tokenize($input, '&quot;')
           return
             if ($count mod 2 = 0)
             then fn:replace($i, &quot;\s+&quot;, &quot;!+!&quot;)
             else $i )
    else ( $input ) , &quot; &quot;)
let $tokenInput := fn:tokenize($newInput, &quot;\s+&quot;)

return (
for $x in $tokenInput
where $x ne &quot;&quot;
return
&lt;token&gt;{fn:replace($x, &quot;!\+!&quot;, &quot; &quot;)}&lt;/token&gt;)
}&lt;/tokens&gt;
} ;

let $input := 'this is a &quot;really big&quot; test'
return
local:get-query-tokens($input)</Code>
<Body>
<A ID="pgfId-1055457"></A>
This returns the following:</Body>
<Code>
<A ID="pgfId-1055514"></A>
&lt;tokens&gt;
&#160;&#160;&lt;token&gt;this&lt;/token&gt;
&#160;&#160;&lt;token&gt;is&lt;/token&gt;
&#160;&#160;&lt;token&gt;a&lt;/token&gt;
&#160;&#160;&lt;token&gt;really big&lt;/token&gt;
&#160;&#160;&lt;token&gt;test&lt;/token&gt;
&lt;/tokens&gt;</Code>
<Body>
<A ID="pgfId-1055509"></A>
Now you can derive a <code>
cts:query</code>
 expression from the tokenized XML produced above, which composes all of the terms with a <code>
cts:and-query</code>
, as follows (assuming the <code>
local:get-query-tokens</code>
 function above is available to this function):</Body>
<Code>
<A ID="pgfId-1055554"></A>
xquery version &quot;1.0-ml&quot;;
declare function local:get-query($input as xs:string) 
{
let $tokens := local:get-query-tokens($input)
return
 cts:and-query( (cts:and-query(
        for $token in $tokens//token
        return 
        cts:word-query($token/text()) ) ))
} ;

let $input := 'this is a &quot;really big&quot; test'
return
local:get-query($input)</Code>
<Body>
<A ID="pgfId-1055549"></A>
This returns the following (spacing and line breaks added for readability):</Body>
<Code>
<A ID="pgfId-1055578"></A>
cts:and-query(
&#160;&#160;cts:and-query((
&#160;&#160;&#160;&#160;cts:word-query(&quot;this&quot;, (), 1), 
&#160;&#160;&#160;&#160;cts:word-query(&quot;is&quot;, (), 1), 
&#160;&#160;&#160;&#160;cts:word-query(&quot;a&quot;, (), 1), 
&#160;&#160;&#160;&#160;cts:word-query(&quot;really big&quot;, (), 1), 
&#160;&#160;&#160;&#160;cts:word-query(&quot;test&quot;, (), 1)
&#160;&#160;&#160;&#160;), ()) ,
&#160;&#160;() )</Code>
<Body>
<A ID="pgfId-1055599"></A>
You can now take the generated <code>
cts:query</code>
 expression and add it to a <code>
cts:search</code>
. </Body>
<Body>
<A ID="pgfId-1060476"></A>
Similarly, you can generate a serialized <code>
cts:query</code>
 as follows (assuming the <code>
local:get-query-tokens</code>
 function is available):</Body>
<Code>
<A ID="pgfId-1060214"></A>
xquery version &quot;1.0-ml&quot;;
declare function local:get-query-xml($input as xs:string) 
{
let $tokens := local:get-query-tokens($input)
return
 element cts:and-query { 
       element cts:and-query { 
           for $token in $tokens//token
           return 
           element cts:word-query { $token/text() } },
           element cts:annotation {$input} }
} ;

let $input := 'this is a &quot;really big&quot; test'
return
local:get-query-xml($input)</Code>
<Body>
<A ID="pgfId-1060246"></A>
This returns the folllowing XML serialization:</Body>
<Code>
<A ID="pgfId-1060252"></A>
&lt;cts:and-query xmlns:cts=&quot;http://marklogic.com/cts&quot;&gt;
  &lt;cts:and-query&gt;
    &lt;cts:word-query&gt;this&lt;/cts:word-query&gt;
    &lt;cts:word-query&gt;is&lt;/cts:word-query&gt;
    &lt;cts:word-query&gt;a&lt;/cts:word-query&gt;
    &lt;cts:word-query&gt;really big&lt;/cts:word-query&gt;
    &lt;cts:word-query&gt;test&lt;/cts:word-query&gt;
  &lt;/cts:and-query&gt;
  &lt;cts:annotation&gt;this is a &quot;really big&quot; test&lt;/cts:annotation&gt;
&lt;/cts:and-query&gt;</Code>
</XML>
