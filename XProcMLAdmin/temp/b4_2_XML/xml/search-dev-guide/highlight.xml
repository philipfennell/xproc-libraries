<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="highlight.css" type="text/css" charset="UTF-8"?>
<XML>
<TITLE> </TITLE><Heading-1>
<A ID="pgfId-1049467"></A>
<A ID="12896"></A>
Highlighting Search Term Matches</Heading-1>
<pagenum>
<A ID="pgfId-1049601"></A>
103</pagenum>
<Body>
<A ID="pgfId-1049471"></A>
This chapter describes ways you can use <code>
cts:highlight</code>
 to wrap terms that match a search query with any markup. It includes the following sections:</Body>
<Body-bullet>
<A ID="pgfId-1053197"></A>
<A href="highlight.xml#id(56383)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Overview of cts:highlight</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1053205"></A>
<A href="highlight.xml#id(31728)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
General Search and Replace Function</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1053872"></A>
<A href="highlight.xml#id(58093)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Built-In Variables For cts:highlight</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1058560"></A>
<A href="highlight.xml#id(79734)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Using cts:highlight to Create Snippets</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1058934"></A>
<A href="highlight.xml#id(96701)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
cts:walk Versus cts:highlight</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1053225"></A>
<A href="highlight.xml#id(89838)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Common Usage Notes</Hyperlink>
</A></Body-bullet>
<Body>
<A ID="pgfId-1053295"></A>
For the syntax of <code>
cts:highlight</code>
, see the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
.</Body>
<Heading-2>
<A ID="pgfId-1053149"></A>
<A ID="56383"></A>
Overview of cts:highlight</Heading-2>
<Body>
<A ID="pgfId-1053235"></A>
When you execute a search in MarkLogic Server, it returns a set of nodes, where each node contains text that matches the search query. A common application requirement is to display the results with the matching terms highlighted, perhaps in bold or in a different color. You can satisfy these highlighting requirements with the <code>
cts:highlight</code>
 function, which is designed with the following main goals:</Body>
<Body-bullet>
<A ID="pgfId-1053253"></A>
Make the task of highlighting search hits easy.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1053260"></A>
Make queries that do text highlighting perform well.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1053265"></A>
Make it possible to do more complex actions than simple text highlighting.</Body-bullet>
<Body>
<A ID="pgfId-1053511"></A>
Even though it is designed to make it easy to highlight search term hits, the <code>
cts:highlight</code>
 function is implemented as a general purpose function. The function substitutes search hits with an XQuery expression specified in the third argument. Because you can substitute the search term hits with any XQuery expression, you can perform all kinds of search and replace actions on terms that match a query. These search and replace operations will perform well, too, because <code>
cts:highlight</code>
 is built-in to MarkLogic Server. </Body>
<Heading-3>
<A ID="pgfId-1053266"></A>
All Matching Terms, Including Stemmed, and Capitalized</Heading-3>
<Body>
<A ID="pgfId-1053291"></A>
When you use the standard XQuery string functions such as <code>
fn:replace</code>
 and <code>
fn:contains</code>
 to find matches, you must specify the exact string you want to match. If you are trying to highlight matches from a <code>
cts:search</code>
 query, exact string matches will not find all of the hits that match the query. A <code>
cts:highlight</code>
 query match, however, is anything that matches the <code>
cts:query</code>
 specified as the second argument of <code>
cts:highlight</code>
. </Body>
<Body>
<A ID="pgfId-1053594"></A>
If you have stemmed searches enabled, matches can be more than exact text matches. For example, <code>
run</code>
, <code>
running</code>
, and <code>
ran</code>
 all match a query for <code>
run</code>
. For details on stemming, see <A href="stemming.xml#id(90878)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Understanding and Using Stemmed Searches' on page&#160;135</A>.</Body>
<Body>
<A ID="pgfId-1053569"></A>
Similarly, query matches can have different capitalization than the exact word for which you actually searched. Additionally, wildcard matches (if wildcard indexes are enabled) will match a whole range of queries. Queries that use <code>
cts:highlight</code>
 will find all of these matches and replace them with whatever the specified expression evaluates to.</Body>
<Heading-2>
<A ID="pgfId-1053159"></A>
<A ID="31728"></A>
General Search and Replace Function</Heading-2>
<Body>
<A ID="pgfId-1053660"></A>
Although it is designed to make highlighting easy, <code>
cts:highlight</code>
 can be used for much more general search and replace operations. For example, if you wanted to replace every instance of the term <code>
content database</code>
 with <code>
contentbase</code>
, you could issue a query similar to the following:</Body>
<Code>
<A ID="pgfId-1053661"></A>
for $x in cts:search(//mynode, &quot;content database&quot;)
return 
cts:highlight($x, &quot;content database&quot;, &quot;contentbase&quot;)</Code>
<Body>
<A ID="pgfId-1053662"></A>
This query happens to use the same search query in the <code>
cts:search</code>
 as it does in the <code>
cts:highlight</code>
, but that is not required (although it is typical of text highlighting requirements). For example, the following query finds all of the nodes that contain the word <code>
foo</code>
, and then replaces the word <code>
bar</code>
 in those nodes with the word <code>
baz</code>
:</Body>
<Code>
<A ID="pgfId-1053666"></A>
for $x in cts:search(fn:doc(), &quot;foo&quot;)
return 
cts:highlight($x, &quot;bar&quot;, &quot;baz&quot;)</Code>
<Body>
<A ID="pgfId-1053156"></A>
Because you can use any XQuery expression as the replace expression, you can perform some very complex search and replace operations with a relatively small amount of code.</Body>
<Heading-2>
<A ID="pgfId-1053142"></A>
<A ID="58093"></A>
Built-In Variables For cts:highlight</Heading-2>
<Body>
<A ID="pgfId-1053683"></A>
The <code>
cts:highlight</code>
 function has three built-in variables which you can use in the replace expression. The expression is evaluated once for each query match, so each variable is bound to a sequence of query matches, and the value of the variables is the value of the query match for each iteration. This section describes the three variables and explains how to use them in the following subsections:</Body>
<Body-bullet>
<A ID="pgfId-1053690"></A>
<A href="highlight.xml#id(17874)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Using the $cts:text Variable to Access the Matched Text</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1053707"></A>
<A href="highlight.xml#id(38079)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Using the $cts:node Variable to Access the Context of the Match</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1053711"></A>
<A href="highlight.xml#id(26128)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Using the $cts:queries Variable to Feed Logic Based on the Query</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1058807"></A>
<A href="highlight.xml#id(67949)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Using $cts:start to Capture the String-Length Position</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1058818"></A>
<A href="highlight.xml#id(24099)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Using $cts:action to Stop Highlighting</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1053682"></A>
<A ID="17874"></A>
Using the $cts:text Variable to Access the Matched Text</Heading-3>
<Body>
<A ID="pgfId-1053715"></A>
The <code>
$cts:text</code>
 variable holds the strings representing of the query match. For example, assume you have the following document with the URI <code>
test.xml</code>
 in a database in which stemming is enabled:</Body>
<Code>
<A ID="pgfId-1053730"></A>
&lt;root&gt;
&#160;&#160;&lt;p&gt;I like to run to the market.&lt;/p&gt;
&#160;&#160;&lt;p&gt;She is running to catch the train.&lt;/p&gt;
&#160;&#160;&lt;p&gt;He runs all the time.&lt;/p&gt;
&lt;/root&gt;</Code>
<Body>
<A ID="pgfId-1053732"></A>
You can highlight text from a query matching the word <code>
run</code>
 as follows:</Body>
<Code>
<A ID="pgfId-1053763"></A>
for $x in cts:search(doc(&quot;test.xml&quot;)/root/p, &quot;run&quot;)
return 
cts:highlight($x, &quot;run&quot;, &lt;b&gt;{$cts:text}&lt;/b&gt;)</Code>
<Body>
<A ID="pgfId-1053755"></A>
The expression <code>
&lt;b&gt;{$cts:text}&lt;/b&gt;</code>
 is evaluated once for each query match, and it replaces the query match with whatever it evaluates to. Because <code>
run</code>
, <code>
running</code>
, and <code>
ran</code>
 all match the <code>
cts:query</code>
 for <code>
run</code>
, the results highlight each of those words and are as follows:</Body>
<Code>
<A ID="pgfId-1053788"></A>
&lt;p&gt;I like to &lt;b&gt;run&lt;/b&gt; to the market.&lt;/p&gt;
&lt;p&gt;She is &lt;b&gt;running&lt;/b&gt; to catch the train.&lt;/p&gt;
&lt;p&gt;He &lt;b&gt;runs&lt;/b&gt; all the time.&lt;/p&gt;</Code>
<Heading-3>
<A ID="pgfId-1053121"></A>
<A ID="38079"></A>
Using the $cts:node Variable to Access the Context of the Match</Heading-3>
<Body>
<A ID="pgfId-1053125"></A>
The <code>
$cts:node</code>
 variable provides access to the text node in which the match occurs. By having access to the node, you can create expressions that do things in the context of that node. For example, if you know your XML has a structure with a hierarchy of <code>
book</code>
, <code>
chapter</code>
, <code>
section</code>
, and <code>
paragraph</code>
 elements, you can write code in the highlight expression to display the section in which each hit occurs. The following code snippet shows an XPath statement that returns the first element named <code>
chapter</code>
 above the text node in which the highlighted term occurs:</Body>
<Code>
<A ID="pgfId-1053822"></A>
$cts:node/ancestor::chapter[1]</Code>
<Body>
<A ID="pgfId-1053840"></A>
You can then use this information to do things like add a link to display that chapter, search for some other terms within that chapter, or whatever you might need to do with the information. Once again, because <code>
cts:highlight</code>
 evaluates an arbitrary XQuery expression for each search query hit, the variations of what you can do with it are virtually unlimited.</Body>
<Body>
<A ID="pgfId-1054155"></A>
The following example shows how to use the <code>
$cts:node</code>
 variable in a test to print the highlighted term in blue if its immediate parent is a <code>
p</code>
 element, otherwise to print the highlightled term in red:</Body>
<Code>
<A ID="pgfId-1054161"></A>
let $doc := &lt;root&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;p&gt;This is blue.&lt;/p&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;p&gt;&lt;i&gt;This is red italic.&lt;/i&gt;&lt;/p&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;/root&gt;
return 
cts:highlight($doc, cts:or-query((&quot;blue&quot;, &quot;red&quot;)),
 (if ( $cts:node/parent::p )
  then ( &lt;font color=&quot;blue&quot;&gt;{$cts:text}&lt;/font&gt; )
  else ( &lt;font color=&quot;red&quot;&gt;{$cts:text}&lt;/font&gt; ) ) 
             )</Code>
<Body>
<A ID="pgfId-1054190"></A>
This query returns the following results:</Body>
<Code>
<A ID="pgfId-1054185"></A>
&lt;root&gt;
&#160;&lt;p&gt;This is &lt;font color=&quot;blue&quot;&gt;blue&lt;/font&gt;.&lt;/p&gt;
&#160;&lt;p&gt;&lt;i&gt;This is &lt;font color=&quot;red&quot;&gt;red&lt;/font&gt;italic.&lt;/i&gt;&lt;/p&gt;
&lt;/root&gt;</Code>
<Heading-3>
<A ID="pgfId-1053129"></A>
<A ID="26128"></A>
Using the $cts:queries Variable to Feed Logic Based on the Query</Heading-3>
<Body>
<A ID="pgfId-1053850"></A>
The <code>
$cts:queries</code>
 variable provides access to the <code>
cts:query</code>
 that satisfies the query match. You can use that information to drive some logic about how you might highlight different queries in different ways. </Body>
<Body>
<A ID="pgfId-1053862"></A>
For example, assume you have the following document with the URI <code>
hellogoodbye.xml</code>
 in your database:</Body>
<Code>
<A ID="pgfId-1053108"></A>
&lt;root&gt;
&#160;&#160;&lt;a&gt;It starts with hello and ends with goodbye.&lt;/a&gt;
&lt;/root&gt;</Code>
<Body>
<A ID="pgfId-1054001"></A>
You can then run the following query to use some simple logic which displays queries for <code>
hello</code>
 in blue and queries for <code>
goodbye</code>
 in red:</Body>
<Code>
<A ID="pgfId-1053094"></A>
cts:highlight(doc(&quot;hellogoodbye.xml&quot;), 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cts:and-query((cts:word-query(&quot;hello&quot;),
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cts:word-query(&quot;goodbye&quot;))),
if ( cts:word-query-text($cts:queries) eq &quot;hello&quot; )
then ( &lt;font color=&quot;blue&quot;&gt;{$cts:text}&lt;/font&gt; )
else ( &lt;font color=&quot;red&quot;&gt;{$cts:text}&lt;/font&gt; ) )</Code>
<Code>
<A ID="pgfId-1053095"></A>
returns:</Code>
<Code>
<A ID="pgfId-1058830"></A>
&lt;root&gt;
&#160;&#160;&lt;a&gt;It starts with &lt;font color=&quot;blue&quot;&gt;hello&lt;/font&gt; 
&#160;&#160;and ends with &lt;font color=&quot;red&quot;&gt;goodbye&lt;/font&gt;.&lt;/a&gt;
&lt;/root&gt;</Code>
<Heading-3>
<A ID="pgfId-1058832"></A>
<A ID="67949"></A>
Using $cts:start to Capture the String-Length Position</Heading-3>
<Body>
<A ID="pgfId-1058848"></A>
The <code>
$cts:start</code>
 variable returns the starting position of the matching text (<code>
$cts:text</code>
), based on the string-length of the text node being processed (<code>
$cts:node</code>
).</Body>
<Heading-3>
<A ID="pgfId-1058855"></A>
<A ID="24099"></A>
Using $cts:action to Stop Highlighting</Heading-3>
<Body>
<A ID="pgfId-1058894"></A>
Use <code>
xdmp:set</code>
 to change the value of <code>
$cts:action</code>
 and specify what action should occur after processing a match. You can use this variable to control highlighting, typically based on some condition (such as how many matches have already occurred) that you have coded into your application). ou can specify for highlighting to <code>
continue</code>
 (the default), to <code>
skip</code>
 highlighting the remainder of the matches in the current text node, or to <code>
break</code>
, stopping highlighting for the rest of the input.</Body>
<Heading-2>
<A ID="pgfId-1058896"></A>
<A ID="79734"></A>
Using cts:highlight to Create Snippets</Heading-2>
<Body>
<A ID="pgfId-1058833"></A>
When you are performing searches, you often want to highlight the result of the search, showing only the part of the document in which the search match occurs. These portions of the document where the search matches are often called snippets. This section shows a simple example that describes the basic design pattern for using <code>
cts:highlight</code>
 to create snippets. The example shown here is trivial in that it only prints out the parent element for the search hit, but it shows the pattern you can use to create useful snippets. A typical snippet might show the matched results in bold and show a few words before and after the results.</Body>
<Body>
<A ID="pgfId-1058506"></A>
The basic design pattern to create snippets is to first run a <code>
cts:search</code>
 to find your results, then, for search each match, run <code>
cts:highlight</code>
 on the match to mark it up. Finally, you run the highlighted match through a recursive transformation or through some other processing to write out the portion of the document you are interested in. For details about recursive transformations, see <A href="../dev_guide/typeswitch.xml#id(37159)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Transforming XML Structures With a Recursive typeswitch Expression</Hyperlink>
</A> in the <Emphasis>
Application Developer's Guide</Emphasis>
.</Body>
<Body>
<A ID="pgfId-1058516"></A>
The following example creates a very simple snippet for a search in the Shakespeare database. It simply returns the parent element for the text node in which the search matches. It uses <code>
cts:highlight</code>
 to create a temporary element (named <code>
HIGHLIGHTME</code>
) around the element containing the search match, and then uses that temporary element name to find the matching element in the transformation.</Body>
<Code>
<A ID="pgfId-1058523"></A>
xquery version &quot;1.0-ml&quot;;
declare function local:truncate($x as item()) as item()*
{ 
  typeswitch ($x)
  case element(HIGHLIGHTME) return $x/node()
&#160;&#160;case element(TITLE) return if ($x/../../PLAY) then $x else ()
  default return for $z in $x/node() return local:truncate($z) 
};

let $query := &quot;to be or not to be&quot;
for $x in cts:search(doc(), $query)
return
local:truncate(cts:highlight($x, $query, 
  &lt;HIGHLIGHTME&gt;{$cts:node/parent::element()}&lt;/HIGHLIGHTME&gt;))
(: 
&#160;&#160;&#160;returns:
&#160;&#160;&#160;&lt;TITLE&gt;The Tragedy of Hamlet, Prince of Denmark&lt;/TITLE&gt;
&#160;&#160;&#160;&lt;LINE&gt;To be, or not to be: that is the question:&lt;/LINE&gt;
:)</Code>
<Body>
<A ID="pgfId-1058518"></A>
This example simply returns the elements in which the match occurs (in this case, only one element matches the query) and the <code>
TITLE</code>
 element that contains the title of the play. You can add any logic you want to create a snippet that is right for your application. For example, you might want to also print out the name of the the act and the scene title for each search result, or you might want to calculate the line number for each result. Because you have the whole document available to you in the transformation, it is easy to do many interesting things with the content.</Body>
<Note>
<A ID="pgfId-1058590"></A>
The use of a recursive typeswitch makes sense assuming you are doing something interesting with various parts of the node returned from the search (for example, printing out the play title, act number, and scene name). If you only want to return the element in which the search match occurs, you can do something simpler. For example, you can use XPath on the highlighted expression to simplify this design pattern as follows:</Note>
<Code>
<A ID="pgfId-1058594"></A>
let $query := &quot;to be or not to be&quot;
for $x in cts:search(doc(), $query)
return
cts:highlight($x, $query, &lt;HIGHLIGHTME&gt;{
&#160;&#160;&#160;&#160;$cts:node/parent::element()}&lt;/HIGHLIGHTME&gt;)//HIGHLIGHTME/node()</Code>
<Heading-2>
<A ID="pgfId-1058490"></A>
<A ID="96701"></A>
cts:walk Versus cts:highlight</Heading-2>
<Body>
<A ID="pgfId-1058952"></A>
The function <code>
cts:walk</code>
 is similar to <code>
cts:highlight</code>
, but instead of returning a copy of the node passed in with the specified changes, it returns only the expression evaluations for the text node matches specified in the <code>
cts:walk</code>
 call. Because <code>
cts:walk</code>
 does not construct a copy of the node, it is faster than <code>
cts:highlight</code>
. In cases where you only need to return the expression evaluations, <code>
cts:walk</code>
 will be more efficient than <code>
cts:highlight</code>
.</Body>
<Heading-2>
<A ID="pgfId-1058945"></A>
<A ID="89838"></A>
Common Usage Notes</Heading-2>
<Body>
<A ID="pgfId-1053307"></A>
This section shows some common usage patterns to be aware with when using <code>
cts:highlight</code>
. The following topics are included:</Body>
<Body-bullet>
<A ID="pgfId-1053438"></A>
<A href="highlight.xml#id(53951)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Input Must Be a Single Node</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1053446"></A>
<A href="highlight.xml#id(26240)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Using xdmp:set Side Effects With cts:highlight</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054431"></A>
<A href="highlight.xml#id(91835)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
No Highlighting with cts:similar-query or cts:element-attribute-*-query</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1053308"></A>
<A ID="53951"></A>
Input Must Be a Single Node</Heading-3>
<Body>
<A ID="pgfId-1053451"></A>
The input to <code>
cts:highlight</code>
 must be a single node. That means that if you want to highlight query hits from a <code>
cts:search</code>
 operation that returns multiple nodes, you must bind the results of the <code>
cts:search</code>
 to a variable (in a <code>
for</code>
 loop, for example), as in the following example:</Body>
<Code>
<A ID="pgfId-1053167"></A>
for $x in cts:search(fn:doc(), &quot;MarkLogic&quot;)
return
cts:highlight($x, &quot;MarkLogic&quot;, &lt;b&gt;{$cts:text}&lt;/b&gt;)</Code>
<Body>
<A ID="pgfId-1054635"></A>
This query returns all of the documents in the database that contain <code>
MarkLogic</code>
, with <code>
b</code>
 tags surrounding each query match.</Body>
<Note>
<A ID="pgfId-1054636"></A>
The input node to <code>
cts:highlight</code>
 must be a document node or an element node; it cannot be a text node. </Note>
<Heading-3>
<A ID="pgfId-1054638"></A>
<A ID="26240"></A>
Using xdmp:set Side Effects With cts:highlight</Heading-3>
<Body>
<A ID="pgfId-1054639"></A>
If you want to keep the state of the highlighted terms so you can handle some instances differently than others, you can define a variable and then use the <code>
xdmp:set</code>
 function to change the value of the variable as the highlighted terms are processed. Some common uses for this functionality are: </Body>
<Body-bullet>
<A ID="pgfId-1053316"></A>
Highlight only the first instance of a term.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1053327"></A>
Highlight the first term in a different color then the rest of the terms.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1053329"></A>
Keep a count on the number of terms matching the query.</Body-bullet>
<Body>
<A ID="pgfId-1053334"></A>
The ability to change the state (also known as side effects) opens the door for infinite possibilities of what to do with matching terms.</Body>
<Body>
<A ID="pgfId-1053344"></A>
The following example shows a query that highlights the first query match with a bold tag and returns only the matching text for the rest of the matches.</Body>
<Body>
<A ID="pgfId-1053408"></A>
Assume you have following document with the URI <code>
/docs/test.xml</code>
 in your database:</Body>
<Code>
<A ID="pgfId-1054050"></A>
&lt;html&gt;
&#160;&#160;&lt;p&gt;hello hello hello hello&lt;/p&gt;
&lt;/html&gt;</Code>
<Body>
<A ID="pgfId-1054065"></A>
You can then run the following query to highlight just the first match:</Body>
<Code>
<A ID="pgfId-1054060"></A>
let $count := 0
return
&#160;&#160;cts:highlight(doc(&quot;/docs/test.xml&quot;), &quot;hello&quot;, 
&#160;&#160;&#160;(: Increment the count for each query match :)
&#160;&#160;&#160;&#160;(xdmp:set($count, $count + 1 ),
&#160;&#160;&#160;&#160;&#160;if ( $count = 1 )
&#160;&#160;&#160;&#160;&#160;then ( &lt;b&gt;{$cts:text}&lt;/b&gt; )
&#160;&#160;&#160;&#160;&#160;else ( $cts:text ) )
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;) 

Returns:

&lt;html&gt;
&#160;&#160;&lt;p&gt;&lt;b&gt;hello&lt;/b&gt; hello hello hello&lt;/p&gt;
&lt;/html&gt;</Code>
<Body>
<A ID="pgfId-1053346"></A>
Because the expression is evaluated once for each query match, the <code>
xdmp:set</code>
 call changes the state for each query match, having the side effect of the conditions being evaluated differently for each query match.</Body>
<Heading-3>
<A ID="pgfId-1054432"></A>
<A ID="91835"></A>
No Highlighting with cts:similar-query or cts:element-attribute-*-query</Heading-3>
<Body>
<A ID="pgfId-1054438"></A>
You cannot use <code>
cts:highlight</code>
 to highlight results from queries containing <code>
cts:similar-query</code>
 or any of the <code>
cts:element-attribute-*-query </code>
functions.  Using <code>
cts:highlight</code>
 with these queries will return the nodes without any highlighting. </Body>
</XML>
