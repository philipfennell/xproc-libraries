<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="lexicon.css" type="text/css" charset="UTF-8"?>
<XML>
<TITLE> </TITLE><Heading-1>
<A ID="pgfId-1053802"></A>
<A ID="29002"></A>
 Browsing With Lexicons</Heading-1>
<pagenum>
<A ID="pgfId-1053806"></A>
91</pagenum>
<Body>
<A ID="pgfId-1049471"></A>
MarkLogic Server allows you to create <Emphasis>
lexicons</Emphasis>
, which are lists of unique words or values, either throughout an entire database (words only) or within named elements or attributes (words or values). Also, you can define lexicons that allow quick access to the document and collection URIs in the database, and you can create word lexicons on named fields. This chapter describes the lexicons you can create in MarkLogic Server and describes how to use the API to browse through them. This chapter includes the following sections:</Body>
<Body-bullet>
<A ID="pgfId-1053734"></A>
<A href="lexicon.xml#id(82762)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
About Lexicons</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054824"></A>
<A href="lexicon.xml#id(37251)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Creating Lexicons</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054825"></A>
<A href="lexicon.xml#id(53009)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Word Lexicons</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1053738"></A>
<A href="lexicon.xml#id(50270)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Element/Element-Attribute Value Lexicons</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1058925"></A>
<A href="lexicon.xml#id(45107)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Value Co-Occurrences Lexicons</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1058926"></A>
<A href="lexicon.xml#id(90832)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Geospatial Lexicons</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1058945"></A>
<A href="lexicon.xml#id(89927)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Range Lexicons</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055318"></A>
<A href="lexicon.xml#id(50782)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
URI and Collection Lexicons</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1053739"></A>
<A href="lexicon.xml#id(68391)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Performing Lexicon-Based Queries</Hyperlink>
</A></Body-bullet>
<Heading-2>
<A ID="pgfId-1053740"></A>
<A ID="82762"></A>
About Lexicons</Heading-2>
<Body>
<A ID="pgfId-1054464"></A>
A <Emphasis>
word lexicon</Emphasis>
 stores all of the unique, case-sensitive, diacritic-sensitive words, either in a database, in an element defined by a QName, or in an attribute defined by a QName. A <Emphasis>
value lexicon</Emphasis>
 stores all of the unique values for an element or an attribute defined by a QName (that is, the entire and exact contents of the specified element or attribute). A <Emphasis>
value co-occurrences lexicon</Emphasis>
 stores all of the pairs of values that appear in the same fragment. A <Emphasis>
geospatial lexicon</Emphasis>
 returns geospatial values from the geospatial index. A <Emphasis>
range lexicon</Emphasis>
 stores buckets of values that occur within a specified range of values. A <Emphasis>
URI lexicon</Emphasis>
 stores the URIs of the documents in a database, and a <Emphasis>
collection lexicon</Emphasis>
 stores the URIs of all collections in a database.</Body>
<Body>
<A ID="pgfId-1059064"></A>
All lexicons determine their order and uniqueness based on the collation specified (for <code>
xs:string</code>
 types), and you can create multiple lexicons on the same object with different collations. For information on collations, see <A href="encodings_collations.xml#id(24886)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Collations' on page&#160;210</A>. You can also create value lexicons on non-string values.</Body>
<Body>
<A ID="pgfId-1059068"></A>
All of these types of lexicons have the following charicteristics:</Body>
<Body-bullet>
<A ID="pgfId-1059069"></A>
Lexicon terms and values are case-sensitive.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054466"></A>
Lexicon terms and values are unstemmed.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054934"></A>
Lexicon terms and values are diacritic-sensitive.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054467"></A>
Lexicon terms and values do not have any relevance information associated with them.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055473"></A>
Uniquness in lexicons is based on the specified collation of the lexicon.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054807"></A>
Lexicon terms in word lexicons do not include any punctuation. For example, the term <code>
case-sensitive</code>
 in a database will be two terms in the lexicon: <code>
case</code>
 and <code>
sensitive</code>
.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054994"></A>
Lexicon values in value lexicons do include punctuation.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054468"></A>
Words are not deleted from the lexicon until a merge occurs, so if you do a lexicon query that is not constrained by a <code>
cts:query</code>
 expression, then deleted terms will still appear until a merge occurs.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054488"></A>
In order to perform lexicon-based queries, the appropriate lexicon must be created. If the lexicon has not been created, the lexicon query will throw an exception.</Body-bullet>
<Body>
<A ID="pgfId-1054950"></A>
Even though the lexicons store terms case-sensitive, unstemmed, and diacritic-sensitive, you can still do case-insensitive and diacritic-insensitve lexicon-based queries by specifying the approriate option(s). For details on the syntax, see the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
.</Body>
<Heading-2>
<A ID="pgfId-1054459"></A>
<A ID="37251"></A>
Creating Lexicons</Heading-2>
<Body>
<A ID="pgfId-1054823"></A>
You must create the appropriate lexicon before you can run lexicon-based queries. You create lexicons in the Admin Interface. For detailed information on creating lexicons, see the 'Text Indexing' and 'Element/Attribute Range Indexes and Lexicons' chapters of the <Emphasis>
Administrator's Guide</Emphasis>
. For all of the lexicons, you must complete at least one of the following before you can successfully run lexicon-based queries:</Body>
<Body-bullet>
<A ID="pgfId-1054959"></A>
Create/enable the lexicon before you load data into the database, or</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054966"></A>
Reindex the database after creating/enabling the lexicon, or</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054967"></A>
Reload the data after creating/enabling the lexicon. </Body-bullet>
<Body>
<A ID="pgfId-1054856"></A>
The following is a brief summary of how to create each of the various types of lexicons:</Body>
<Body-bullet>
<A ID="pgfId-1054839"></A>
To create a word lexicon for the entire database, enable the <code>
word&#160;lexicon</code>
 setting on the Admin Interface Database Configuration page (Databases &gt; <Emphasis>
db_name</Emphasis>
) and specify a collation for the lexicon (for example, <code>
http://marklogic.com/collation/</code>
 for the UCA Root Collation). </Body-bullet>
<Body-bullet>
<A ID="pgfId-1054859"></A>
To create an element word lexicon, specify the element namespace URI, localname, and collation on the Admin Interface Element Word Lexicon Configuration page (Databases &gt; <Emphasis>
db_name</Emphasis>
 &gt; Element Word Lexicons).</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054870"></A>
To create an element attribute word lexicon, specify the element and attribute namespace URIs, localnames, and collation on the Admin Interface Element Attribute Word Lexicon Configuration page (Databases &gt; <Emphasis>
db_name</Emphasis>
 &gt; Attribute Word Lexicons).</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054896"></A>
To create an element value lexicon, specify the element namespace URI and localname, the collation (for <code>
xs:string</code>
), and the type (for example, <code>
xs:string</code>
) on the Admin Interface Range Element Index Configuration page (Databases &gt; <Emphasis>
db_name</Emphasis>
 &gt; Element Indexes).</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054878"></A>
To create an element attribute value lexicon, specify the element and attribute namespace URIs and localnames, the collation (for <code>
xs:string</code>
), and the type (for example, <code>
xs:string</code>
) on the Admin Interface Range Element-Attribute Index Configuration page (Databases&#160;&gt;&#160;<Emphasis>
db_name</Emphasis>
 &gt; Attribute Indexes).</Body-bullet>
<Note>
<A ID="pgfId-1054913"></A>
If your system is set to reindex/refragment, newly created lexicons will not be available until reindexing is completed.</Note>
<Heading-2>
<A ID="pgfId-1054822"></A>
<A ID="53009"></A>
Word Lexicons</Heading-2>
<Body>
<A ID="pgfId-1054471"></A>
There are several types of word lexicons:</Body>
<Body-bullet>
<A ID="pgfId-1054496"></A>
<A href="lexicon.xml#id(95092)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Word Lexicon for the Entire Database</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054504"></A>
<A href="lexicon.xml#id(65280)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Element/Element-Attribute Word Lexicons</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055425"></A>
<A href="lexicon.xml#id(58905)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Field Word Lexicons</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1054473"></A>
<A ID="95092"></A>
Word Lexicon for the Entire Database</Heading-3>
<Body>
<A ID="pgfId-1054477"></A>
A word lexicon covers the entire database, and holds all of the unique terms in the database, with uniqueness determined by the specified collation. You enable the word lexicon in the database page of the Admin Interface by enabling the <code>
word lexicon</code>
 database setting. If the database already has content loaded, you must reindex the database before you can perform any lexicon queries. The following are the APIs for the word lexicon:</Body>
<Body-bullet>
<A ID="pgfId-1054526"></A>
<code>
cts:words</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054527"></A>
<code>
cts:word-match</code>
</Body-bullet>
<Heading-3>
<A ID="pgfId-1054478"></A>
<A ID="65280"></A>
Element/Element-Attribute Word Lexicons</Heading-3>
<Body>
<A ID="pgfId-1054483"></A>
An element word lexicon or an element-attribute word lexicon contains all of the unique terms in the specified element or attribute, with uniqueness determined by the specified collation. The element word lexicons only contain words that exist in immediate text node children of the specified element as well as any text node children of elements defined in the Admin Interface as element-word-query-throughs or phrase-throughs; it does not include words from any other children of the specified element. You create element and element-attribute word lexicons in the Admin Interface with the <code>
Element Range Indexes</code>
 and <code>
Attribute Range Indexes</code>
 links under the database in which you want to create the lexicons. The following are the APIs for the element and element-attribute word lexicons:</Body>
<Body-bullet>
<A ID="pgfId-1054538"></A>
<code>
cts:element-words</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054539"></A>
<code>
cts:element-word-match</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054540"></A>
<code>
cts:element-attribute-words</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054541"></A>
<code>
cts:element-attribute-word-match</code>
</Body-bullet>
<Heading-3>
<A ID="pgfId-1054174"></A>
<A ID="58905"></A>
Field Word Lexicons</Heading-3>
<Body>
<A ID="pgfId-1055432"></A>
A field is a named object that you create at the database level, and it defines a set of elements which can be accessed together through the field. You can create word lexicons on fields, which list all of the unique words that are included in the field. You can create field word lexicons in the configuration page for each field. Like all other lexicons, field word lexicons are unique to a collation, and you can, if you need to, create multiple lexicons in different collations. For details on fields, see <A href="../admin/fields.xml#id(61682)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Fields Database Settings</Hyperlink>
</A> in the <Emphasis>
Administrator's Guide</Emphasis>
. The following are the APIs for the field word lexicons:</Body>
<Body-bullet>
<A ID="pgfId-1055433"></A>
<code>
cts:field-words</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055434"></A>
<code>
cts:field-word-match</code>
</Body-bullet>
<Heading-2>
<A ID="pgfId-1055426"></A>
<A ID="50270"></A>
Element/Element-Attribute Value Lexicons</Heading-2>
<Body>
<A ID="pgfId-1055180"></A>
An element value lexicon or an element-attribute value lexicon contains all of the unique values in the specified element or attribute. The values are the entire and exact contents of the specified element or attribute. You create element and element-attribute value lexicons in the Admin Interface by creating a range index of of a particular type (for example, <code>
xs:string</code>
) for the element or attribute to which you want the value lexicon. The following are the APIs for the element and element-attribute value lexicons:</Body>
<Body-bullet>
<A ID="pgfId-1054545"></A>
<code>
cts:element-values</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054546"></A>
<code>
cts:element-value-match</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054547"></A>
<code>
cts:element-attribute-values</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054548"></A>
<code>
cts:element-attribute-value-match</code>
</Body-bullet>
<Note>
<A ID="pgfId-1055001"></A>
You can only create element value lexicons on simple elements (that is, the elements cannot have any element children).</Note>
<Body>
<A ID="pgfId-1055474"></A>
When you have a value lexicon on an element or an attribute, you can also use the <code>
cts:frequency</code>
 API to get fast and accurate counts of how many times the value occurs. You can either get counts of the number of fragments that have at least one instance of the value (using the default <code>
fragment-frequency</code>
 option to the value lexicon APIs) or you can get total counts of values in each item (using the <code>
item-frequency</code>
 option). For details and examples, see the documentation for <code>
cts:frequency</code>
 and for the value lexicon APIs in the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
.</Body>
<Heading-2>
<A ID="pgfId-1055348"></A>
<A ID="45107"></A>
Value Co-Occurrences Lexicons</Heading-2>
<Body>
<A ID="pgfId-1058913"></A>
Value co-occurrence lexicons find pairs of element or attribute values that occur in the same fragment. If you have positions enabled in your range indexes, you can also specify a maximum word distance (<code>
proximity=</code>
<Emphasis>
N</Emphasis>
 option) that the values must be from each other in order to match as a co-occurring pair. The following APIs support these lexicons:</Body>
<Body-bullet>
<A ID="pgfId-1058996"></A>
<code>
cts:element-value-co-occurrences</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1059004"></A>
<code>
cts:element-attribute-value-co-occurrences</code>
</Body-bullet>
<Body>
<A ID="pgfId-1059227"></A>
These APIs return XML structures containing the pairs of co-occurring values. You can use <code>
cts:frequency</code>
 on the output of these functions to find the frequency (the counts) of each co-occurence. Additionally, there are co-occurrences lexicon functions for geospatial values.</Body>
<Body>
<A ID="pgfId-1059297"></A>
Consider the following example (note that this example uses entity enrichment, which is a separately licensed option and you need an entity enrichment license to run this example):</Body>
<Code>
<A ID="pgfId-1059303"></A>
xquery version &quot;1.0-ml&quot;;
(: 
   Before running this, create two string
   element range indexes: one for the e:person element 
   and one for the e:location element, where e is bound 
   to the namespace http://marklogic.com/entity.
:)
import module namespace entity=&quot;http://marklogic.com/entity&quot; at 
       &quot;/MarkLogic/entity.xqy&quot;;
let $x := &lt;text&gt;George Washington was the first President 
                of the United States. Martha Washington was 
                his wife.  They lived at Mount Vernon.&lt;/text&gt;
return 
xdmp:document-insert(&quot;/george.xml&quot;, entity:enrich($x))</Code>
<Body>
<A ID="pgfId-1059337"></A>
The <code>
/george.xml</code>
 document created looks like the following:</Body>
<Code>
<A ID="pgfId-1059344"></A>
&lt;text&gt;
&#160;&#160;&lt;e:person xmlns:e=&quot;http://marklogic.com/entity&quot;&gt;George &#160;&#160;Washington&lt;/e:person&gt; was the first President of the 
&#160;&#160;&lt;e:gpe xmlns:e=&quot;http://marklogic.com/entity&quot;&gt;United States&lt;/e:gpe&gt;.
&#160;&#160;&lt;e:person xmlns:e=&quot;http://marklogic.com/entity&quot;&gt;Martha
&#160;&#160;Washington&lt;/e:person&gt; was his wife.  They lived at 
&#160;&#160;&lt;e:location xmlns:e=&quot;http://marklogic.com/entity&quot;&gt;Mount &#160;&#160;Vernon&lt;/e:location&gt;.
&lt;/text&gt;</Code>
<Body>
<A ID="pgfId-1059338"></A>
Now you can run the following co-occurrence query to find all co-occuring people and locations:</Body>
<Code>
<A ID="pgfId-1059401"></A>
xquery version &quot;1.0-ml&quot;;

declare namespace e=&quot;http://marklogic.com/entity&quot;;
cts:element-value-co-occurrences(xs:QName(&quot;e:person&quot;),
&#160;&#160;&#160;&#160;&#160;xs:QName(&quot;e:location&quot;))</Code>
<Body>
<A ID="pgfId-1059398"></A>
This produces the following output:</Body>
<Code>
<A ID="pgfId-1059411"></A>
&lt;cts:co-occurrence xmlns:cts=&quot;http://marklogic.com/cts&quot;
&#160;&#160;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
&#160;&#160;xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
  &lt;cts:value xsi:type=&quot;xs:string&quot;&gt;George Washington&lt;/cts:value&gt;
  &lt;cts:value xsi:type=&quot;xs:string&quot;&gt;Mount Vernon&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;
&lt;cts:co-occurrence xmlns:cts=&quot;http://marklogic.com/cts&quot;
&#160;&#160;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
&#160;&#160;xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
  &lt;cts:value xsi:type=&quot;xs:string&quot;&gt;Martha Washington&lt;/cts:value&gt;
  &lt;cts:value xsi:type=&quot;xs:string&quot;&gt;Mount Vernon&lt;/cts:value&gt;
&lt;/cts:co-occurrence&gt;</Code>
<Body>
<A ID="pgfId-1059427"></A>
If you wanted to get the frequency of how many of each co-occurring pair exist, either in each item or in each fragment (depending on whether you use the <code>
item-frequency</code>
 or the default <code>
fragment-frequency</code>
 option), use <code>
cts:frequency</code>
 on the lexicon lookup as follows:</Body>
<Code>
<A ID="pgfId-1059443"></A>
xquery version &quot;1.0-ml&quot;;
declare namespace e=&quot;http://marklogic.com/entity&quot;;
for $x in cts:element-value-co-occurrences(xs:QName(&quot;e:person&quot;), 
               xs:QName(&quot;e:location&quot;))
return cts:frequency($x)
(: 
&#160;&#160;&#160;returns a frequency of 1 for each pair if /george.xml 
&#160;&#160;&#160;is the only document in the database 
:)</Code>
<Heading-2>
<A ID="pgfId-1058915"></A>
<A ID="90832"></A>
Geospatial Lexicons</Heading-2>
<Body>
<A ID="pgfId-1058916"></A>
The following APIs support the geospatial lexicons:</Body>
<Body-bullet>
<A ID="pgfId-1059131"></A>
<code>
cts:element-attribute-pair-geospatial-boxes</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1059135"></A>
<code>
cts:element-attribute-geospatial-value-match</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1059139"></A>
<code>
cts:element-attribute-geospatial-values</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1059212"></A>
<code>
cts:element-attribute-value-geospatial-co-occurrences</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1058979"></A>
<code>
cts:element-child-geospatial-boxes</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1059115"></A>
<code>
cts:element-child-geospatial-value-match</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1059125"></A>
<code>
cts:element-child-geospatial-values</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1058990"></A>
<code>
cts:element-geospatial-boxes</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1059155"></A>
<code>
cts:element-geospatial-value-match</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1059165"></A>
<code>
cts:element-geospatial-values</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1059171"></A>
<code>
cts:element-pair-geospatial-boxes</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1059175"></A>
<code>
cts:element-pair-geospatial-value-match</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1058980"></A>
<code>
cts:element-pair-geospatial-values</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1059222"></A>
<code>
cts:element-value-geospatial-co-occurrences</code>
</Body-bullet>
<Body>
<A ID="pgfId-1059182"></A>
You must create the appropriate geospatial index to use its corresponding geospatial lexicon. For example, to use <code>
cts:element-geospatial-values</code>
, you must first create a geospatial element index. Use the Admin Interface (Databases &gt; <Emphasis>
database_name</Emphasis>
 &gt; Geospatial Indexes) or the Admin&#160;API to create geospatial indexes for a database.</Body>
<Body>
<A ID="pgfId-1059196"></A>
The <code>
*-boxes</code>
 APIs return XML elements that show buckets of ranges, each bucket containing one or more <code>
cts:box</code>
 values.</Body>
<Heading-2>
<A ID="pgfId-1058947"></A>
<A ID="89927"></A>
Range Lexicons</Heading-2>
<Body>
<A ID="pgfId-1058948"></A>
The range lexicons return values divided into buckets. The ranges are ranges of values of the type of the lexicon. A range index is required on the element(s) or attribute(s) specified in the range lexicon. The following APIs support these lexicons:</Body>
<Body-bullet>
<A ID="pgfId-1058965"></A>
<code>
cts:element-attribute-value-ranges</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1058957"></A>
<code>
cts:element-value-ranges</code>
</Body-bullet>
<Body>
<A ID="pgfId-1059250"></A>
Additionally, there are the following geospatial box lexicons to find ranges of geospatial values divided into buckets:</Body>
<Body-bullet>
<A ID="pgfId-1059257"></A>
<code>
cts:element-attribute-pair-geospatial-boxes</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1059258"></A>
<code>
cts:element-child-geospatial-boxes</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1059269"></A>
<code>
cts:element-geospatial-boxes</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1059275"></A>
<code>
cts:element-pair-geospatial-boxes</code>
</Body-bullet>
<Body>
<A ID="pgfId-1059278"></A>
The range lexicons return a sequence of XML nodes, one node for each bucket. You can use <code>
cts:frequency</code>
 on the result set to determine the number of items (or fragments) in the buckets. The <code>
&quot;empties&quot;</code>
 option specifies that an XML node is returned for buckets that have no values (that is, for buckets with a frequency of zero). By default, empty buckets are not included in the result set. For details about all of the options to the range lexicons, see the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
.</Body>
<Heading-2>
<A ID="pgfId-1058912"></A>
<A ID="50782"></A>
URI and Collection Lexicons</Heading-2>
<Body>
<A ID="pgfId-1055349"></A>
The URI and Collection lexicons respectively list all of the document URIs and all of the collection URIs in a database. To enable or disable these lexicons, use the Database Configuration page in the Admin Interface. Use these lexicons to quickly search through all of the URIs in a database. The following APIs support these lexicons:</Body>
<Body-bullet>
<A ID="pgfId-1055330"></A>
<code>
cts:collection-match</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055331"></A>
<code>
cts:collections</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055332"></A>
<code>
cts:uri-match</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055333"></A>
<code>
cts:uris</code>
</Body-bullet>
<Heading-2>
<A ID="pgfId-1055319"></A>
<A ID="68391"></A>
Performing Lexicon-Based Queries</Heading-2>
<Body>
<A ID="pgfId-1054692"></A>
Lexicon queries return a sequence of words (or values in the case of value lexicons) from the appropriate lexicon. For string values, the words or values are returned in collation order, and the terms are case- and diacritic-sensitive. For other data types, the values are returned in order, where values that are 'greater than' return before values that are 'less than'. This section lists the lexicon APIs and provides some examples and explanation of how to perform lexicon-based queries. It includes the following parts:</Body>
<Body-bullet>
<A ID="pgfId-1054701"></A>
<A href="lexicon.xml#id(74549)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Lexicon APIs</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054709"></A>
<A href="lexicon.xml#id(23693)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Constraining Lexicon Searches to a cts:query Expression</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054714"></A>
<A href="lexicon.xml#id(84412)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Using the Match Lexicon APIs</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054719"></A>
<A href="lexicon.xml#id(95439)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Determining the Number of Fragments Containing a Lexicon Term</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1053978"></A>
<A ID="74549"></A>
Lexicon APIs</Heading-3>
<Body>
<A ID="pgfId-1054688"></A>
Use the following Search Built-in XQuery APIs to perform lexicon-based queries:</Body>
<Body-bullet>
<A ID="pgfId-1053985"></A>
<code>
cts:words</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1053986"></A>
<code>
cts:word-match</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1053998"></A>
<code>
cts:element-words</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054007"></A>
<code>
cts:element-word-match</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054003"></A>
<code>
cts:element-attribute-words</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1053999"></A>
<code>
cts:element-attribute-word-match</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054207"></A>
<code>
cts:element-values</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054208"></A>
<code>
cts:element-value-match</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054201"></A>
<code>
cts:element-attribute-values</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054191"></A>
<code>
cts:element-attribute-value-match</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055369"></A>
<code>
cts:collection-match</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055370"></A>
<code>
cts:collections</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055371"></A>
<code>
cts:uri-match</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055372"></A>
<code>
cts:uris</code>
</Body-bullet>
<Body>
<A ID="pgfId-1054436"></A>
In order to perform lexicon-based queries, the appropriate lexicon must be created. If the lexicon has not been created, the lexicon query will throw an exception.</Body>
<Body>
<A ID="pgfId-1055051"></A>
The <code>
cts:*-words</code>
 APIs return all of the words in the lexicon (or all of the words from a starting point if the optional <code>
$start</code>
 parameter is used). The <code>
cts:*-match</code>
 APIs return only words in the lexicon that match the wildcard pattern.</Body>
<Body>
<A ID="pgfId-1055049"></A>
For details about the individual functions, see the Search APIs in the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
.</Body>
<Heading-3>
<A ID="pgfId-1054040"></A>
<A ID="23693"></A>
Constraining Lexicon Searches to a cts:query Expression</Heading-3>
<Body>
<A ID="pgfId-1054587"></A>
You can use the <code>
$query</code>
 option of the lexicon APIs to constrain your lexicon lookups to fragments matching a particular <code>
cts:query</code>
 expression. When you specify the <code>
$query</code>
 option, the lexicon search returns all of the terms (or values for lexicon value queries) in the fragments that match the specified <code>
cts:query</code>
 expression. </Body>
<Body>
<A ID="pgfId-1054602"></A>
For example, the following is a query against a database of all of Shakespeare's plays fragmented at the SCENE level:</Body>
<Code>
<A ID="pgfId-1054603"></A>
cts:words(&quot;et&quot;, (), &quot;et tu&quot;)[1 to 10]

=&gt; et ete even ever every eyes fais faith fall familiar</Code>
<Body>
<A ID="pgfId-1054604"></A>
This query returns the first 10 words from the lexicon of words, starting with the word <code>
et</code>
, for all of the fragments that match the following query:</Body>
<Code>
<A ID="pgfId-1054619"></A>
cts:word-query(&quot;et tu&quot;)</Code>
<Body>
<A ID="pgfId-1054620"></A>
In the case of the Shakespeare database, there are 2 scenes that match this query, one from <Emphasis>
The Tragedy of Julius Caesar</Emphasis>
 and one from <Emphasis>
The Life of Henry the Fifth</Emphasis>
. Note that this is a different set of words than if you omitted the <code>
$query</code>
 parameter from the search. The following shows the query without the <code>
$query</code>
 parameter. The results represent the 10 words in the entire word lexicon for all of the Shakespeare plays, starting with the word <code>
et</code>
:</Body>
<Code>
<A ID="pgfId-1054644"></A>
cts:words(&quot;et&quot;)

=&gt; et etc etceteras ete eternal eternally eterne eternity 
&#160;&#160;&#160;eternized etes</Code>
<Body>
<A ID="pgfId-1055576"></A>
Note that when you constrain a lexicon lookup to a <code>
cts:query</code>
 expression, it returns the lexicon items for any fragment in which the <code>
cts:query</code>
 expression returns <code>
true</code>
. No filtering is done to the <code>
cts:query</code>
 expression to validate that the match actually occurs in the fragment. In some cases, depending on the index options you have set, it can return <code>
true</code>
 in cases where there is no actual match. For example, if you do not have <code>
fast element word searches</code>
 enabled in the database configuration, it is possible for a <code>
cts:element-word-query</code>
 to match a fragment because both the word and the element exist in the fragment, but not in the same element. The filtering stage of <code>
cts:search</code>
 resolves these descrepancies, but they are not resolved in leicon APIs that use the <code>
$query</code>
 option. For details about how this works, see <A href="../performance/unfiltered.xml#id(13165)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Understanding the Search Process</Hyperlink>
</A> and <A href="../performance/unfiltered.xml#id(89797)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Understanding Unfiltered Searches</Hyperlink>
</A> sections in the <Emphasis>
Query Performance and Tuning Guide</Emphasis>
.</Body>
<Heading-3>
<A ID="pgfId-1054584"></A>
<A ID="84412"></A>
Using the Match Lexicon APIs</Heading-3>
<Body>
<A ID="pgfId-1054694"></A>
Each type of lexicon (word, element word, element-attribute word, element value, and element-attribute value) has a function (<code>
cts:*-match</code>
) which allows you to use a wildcard pattern to constrain the lexicon entries returned; the <code>
cts:*-match</code>
 APIs return only words or values in the lexicon that match the wildcard pattern. The following query finds all of the words in the lexicon that start with <code>
zou</code>
:</Body>
<Code>
<A ID="pgfId-1054763"></A>
cts:word-match(&quot;zou*&quot;)

=&gt; Zounds zounds</Code>
<Body>
<A ID="pgfId-1054764"></A>
It returns both the uppercase and lowercase words that match because search defaults to case-insensitive when all of the letters in the base of the wildcard pattern are lowercase. If you want to match the pattern case-sensitive, diacritic-sensitive, or with some other option, add the appropriate option to the query. For example:</Body>
<Code>
<A ID="pgfId-1054791"></A>
cts:word-match(&quot;zou*&quot;, &quot;case-sensitive&quot;)

=&gt; zounds</Code>
<Body>
<A ID="pgfId-1054792"></A>
For details on the query options, see the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
. For details on wildcard searches, see <A href="wildcard.xml#id(66341)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Understanding and Using Wildcard Searches' on page&#160;139</A>.</Body>
<Heading-3>
<A ID="pgfId-1054693"></A>
<A ID="95439"></A>
Determining the Number of Fragments Containing a Lexicon Term</Heading-3>
<Body>
<A ID="pgfId-1054358"></A>
The lexicon contains the unique terms in a database. To minimize redundant disk I/Os when you are performing estimates following a query-constrained word lexicon lookup, and therefore for this type of query to be resolved as efficiently as possible, the <code>
cts:word-query</code>
 should have the following characteristics:</Body>
<Body-bullet>
<A ID="pgfId-1054410"></A>
Specify the <code>
unstemmed</code>
, <code>
case-sensitive</code>
, and <code>
diacritic-sensitive</code>
 options.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054414"></A>
Specify a <code>
weight</code>
 of 0.</Body-bullet>
<Body>
<A ID="pgfId-1054418"></A>
These characteristics ensure that the word being estimated is exactly the same as the word returned from the lexicon. </Body>
<Body>
<A ID="pgfId-1055104"></A>
For example, if you want to figure out how many fragments contain a lexicon term, you can perform a query like the following:</Body>
<Code>
<A ID="pgfId-1055105"></A>
&lt;words&gt;{
for $word in cts:words(&quot;aardvark&quot;, (), 
&#160;&#160;&#160;&#160;&#160;cts:directory-query(&quot;/&quot;, &quot;infinity&quot;))[1 to 1000]
&#160;&#160;let $count := xdmp:estimate(cts:search(fn:doc(),
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cts:word-query($word,(&quot;unstemmed&quot;,&quot;case-sensitive&quot;,
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&quot;diacritic-sensitive&quot;),0)))
return &lt;word text=&quot;{$word}&quot; count=&quot;{$count}&quot;/&gt; }
&lt;/words&gt;</Code>
<Body>
<A ID="pgfId-1055102"></A>
This query returns one <code>
word</code>
 element per lexicon term, along with the matching term and counts of the number of fragments that have the term, under the specified directory (<code>
/</code>
), starting with the term <code>
aardvark</code>
. Sample output from this query follows:</Body>
<Code>
<A ID="pgfId-1055130"></A>
&lt;words&gt;
&#160;&#160;&lt;word text=&quot;aardvark&quot; count=&quot;10&quot;/&gt;
&#160;&#160;&lt;word text=&quot;aardvarks&quot; count=&quot;10&quot;/&gt;
&#160;&#160;&lt;word text=&quot;aardwolf&quot; count=&quot;5&quot;/&gt;
...
&lt;/words&gt;</Code>
</XML>
