<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="classifier.css" type="text/css" charset="UTF-8"?>
<XML>
<TITLE> </TITLE><Heading-1>
<A ID="pgfId-1053802"></A>
 Training the Classifier</Heading-1>
<pagenum>
<A ID="pgfId-1053806"></A>
190</pagenum>
<Body>
<A ID="pgfId-1049471"></A>
MarkLogic Server includes an XML support vector machine (SVM) classifier. This chapter describes the classifier and how to use it on your content, and includes the following sections:</Body>
<Body-bullet>
<A ID="pgfId-1053734"></A>
<A href="classifier.xml#id(98210)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Understanding How Training and Classification Works</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1053738"></A>
<A href="classifier.xml#id(14821)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Classifier API</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054047"></A>
<A href="classifier.xml#id(43728)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Leveraging XML With the Classifier</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055431"></A>
<A href="classifier.xml#id(25981)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Creating a Training Set</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055435"></A>
<A href="classifier.xml#id(84045)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Methodology For Determining Thresholds For Each Class</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055439"></A>
<A href="classifier.xml#id(93018)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Example: Training and Running the Classifier</Hyperlink>
</A></Body-bullet>
<Heading-2>
<A ID="pgfId-1054048"></A>
<A ID="98210"></A>
Understanding How Training and Classification Works</Heading-2>
<Body>
<A ID="pgfId-1054049"></A>
The <Emphasis>
classifier</Emphasis>
 is a set of APIs that allow you to define <Emphasis>
classes</Emphasis>
, or categories of nodes. By running samples of classes through the classifier to train it on what constitutes a given class, you can then run that trained classifier on unknown documents or nodes to determine to which classes each belongs. The process of classification uses the full-text indexing capabilities of MarkLogic Server, as well as its XML-awareness, to perform statistical analysis of terms in the training content to determine class membership. This section describes the concepts behind the classifier and includes the following parts:</Body>
<Body-bullet>
<A ID="pgfId-1054873"></A>
<A href="classifier.xml#id(12928)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Training and Classification</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1056473"></A>
<A href="classifier.xml#id(84623)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
XML SVM Classifier</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054877"></A>
<A href="classifier.xml#id(74229)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Hyper-Planes and Thresholds for Classes</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055451"></A>
<A href="classifier.xml#id(39167)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Training Content for the Classifier</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1054377"></A>
<A ID="12928"></A>
Training and Classification</Heading-3>
<Body>
<A ID="pgfId-1056461"></A>
There are two basic steps to using the classifier: training and classification. <Emphasis>
Training</Emphasis>
 is the process of taking content that is known to belong to specified classes and creating a classifier on the basis of that known content. <Emphasis>
Classification</Emphasis>
 is the process of taking a classifier built with such a training content set and running it on unknown content to determine class membership for the unknown content. Training is an iterative process whereby you build the best classifier possible, and classification is a one-time process designed to run on unknown content.</Body>
<Heading-3>
<A ID="pgfId-1056460"></A>
<A ID="84623"></A>
XML SVM Classifier</Heading-3>
<Body>
<A ID="pgfId-1054381"></A>
The MarkLogic Server classifier implements a support vector machine (SVM). An SVM classifier uses a well-known algorithm to determine membership in a given class, based on training data. For background on the mathematics behind support vector machine (SVM) classifiers, try doing a web search for <code>
svm classifier</code>
, or start by looking at the information on <Hyperlink>
<A href="http://en.wikipedia.org/wiki/Support_vector_machines" xml:link="simple" show="replace" actuate="user" CLASS="URL">Wikipedia</A></Hyperlink>
.</Body>
<Body>
<A ID="pgfId-1054904"></A>
The basic idea is that the classifier takes a set of training content representing known examples of classes and, by performing statistical analysis of the training content, uses the knowledge gleaned from the training content to decide to which classes other unknown content belongs. You can use the classifier to gain knowledge about your content based on the statistical analysis performed during training.</Body>
<Body>
<A ID="pgfId-1054958"></A>
Traditional SVM classifiers perform the statistical analysis using term frequency as input to the support vector machine calculations. The MarkLogic XML SVM classifier takes advantage of MarkLogic Server's XML-aware full-text indexing capabilities, so the terms that act as input to the classifier can include content (for example, words), structure information (for example, elements), or a combination of content and structure (for example, element-word relationships). All of the MarkLogic Server index options that affect terms are available as options in the classifier API, so you can use a wide variety of indexing techniques to tune the classifier to work the best for your sample content.</Body>
<Body>
<A ID="pgfId-1054962"></A>
First you define your classes on a set of training content, and then the classifier uses those classes to analyze other content and determine its classification. When the classifier analyzes the content, there are two sometimes conflicting measurements it uses to help determine if the information in the new content belongs in or out of a class:</Body>
<Body-bullet>
<A ID="pgfId-1054441"></A>
<Emphasis>
Precision</Emphasis>
: The probability that what is classified as being in a class is actually in that class. High precision might come at the expense of missing some results whose terms resemble those of other results in other classes. </Body-bullet>
<Body-bullet>
<A ID="pgfId-1054442"></A>
<Emphasis>
Recall</Emphasis>
: The probability that an item actually in a class is classified as being in that class. High recall might come at the expense of including results from other classes whose terms resemble those of results in the target class.</Body-bullet>
<Body>
<A ID="pgfId-1055115"></A>
When you are tuning your classifier, you need to find a balance between high precision and high recall. That balance depends on what your application goals and requirements are. For example, if you are trying to find trends in your content, then high precision is probably more important; you want to ensure that your analysis does not include irrelevant nodes. If you need to identify every instance of some classification, however, you probably need a high recall, as missing any members would go against your application goals. For most applications, you probably need somewhere in between. The process of training your classifier is where you determine the optimal values (based on your training content set) to make the trade-offs that make sense to your application.</Body>
<Heading-3>
<A ID="pgfId-1055116"></A>
<A ID="74229"></A>
Hyper-Planes and Thresholds for Classes</Heading-3>
<Body>
<A ID="pgfId-1055117"></A>
There are two main things that the computations behind the XML SVM classifier do:</Body>
<Body-bullet>
<A ID="pgfId-1054991"></A>
Determine the boundaries between each class. This is done during training.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055000"></A>
Determine the threshold for which the boundaries return the most distinctive results when determining class membership.</Body-bullet>
<Body>
<A ID="pgfId-1056520"></A>
There can be any number of classes. A <Emphasis>
term vector</Emphasis>
 is a representation of all of the terms (as defined by the index options) in a node. Therefore, classes consist of sets of term vectors which have been deemed similar enough to belong to the same class. </Body>
<Body>
<A ID="pgfId-1056538"></A>
Imagine for a moment that each term forms a dimension. It is easy to visualize what a 2-dimensional picture of a class looks like (imagine an x-y graph) or even a 3-dimensional picture (imagine a room with height, width, and length). It becomes difficult, however, to visualize what the picture of these dimensions looks like when there are more than three dimensions. That is where <Emphasis>
hyper-planes</Emphasis>
 become a useful concept.</Body>
<Body>
<A ID="pgfId-1055011"></A>
Before going deeper into the concept of hyper-planes, consider a content set with two classes, one that are squares and one that are triangles. In the following figures, each square or triangle represents a term vector that is a member of either the square or triangle class, respectively. </Body>
<Body>
<A ID="pgfId-1056588"></A>
<IMAGE xml:link="simple" href="classifier-1.gif" show="embed" actuate="auto"/>
</Body>
<Body>
<A ID="pgfId-1056589"></A>
Now try to draw a line to separate the triangles from the squares. In this case, you can draw such a line that nicely divides the two classes as follows:</Body>
<Body>
<A ID="pgfId-1055100"></A>
<IMAGE xml:link="simple" href="classifier-2.gif" show="embed" actuate="auto"/>
</Body>
<Body>
<A ID="pgfId-1055107"></A>
If this were three dimensions, instead of a line between the classes it would be a <Emphasis>
plane</Emphasis>
 between the classes. When the number of dimensions grows beyond three, the extension of the plane is called a <Emphasis>
hyper-plane</Emphasis>
; it is the generalized representation of a boundary of a class (sometimes called the edge of a class). </Body>
<Body>
<A ID="pgfId-1055126"></A>
The previous examples are somewhat simplified; they are set up such that the hyper-planes can be drawn such that one class is completely on one side and the other is completely on the other. For most real-world content, there are members of each class on the other side of the boundaries as follows:</Body>
<Body>
<A ID="pgfId-1055165"></A>
<IMAGE xml:link="simple" href="classifier-3.gif" show="embed" actuate="auto"/>
</Body>
<Body>
<A ID="pgfId-1055135"></A>
In these cases, you can draw other lines parallel to the boundaries (or in the <Emphasis>
n</Emphasis>
-dimensional cases, other hyper-planes). These other lines represent the <Emphasis>
thresholds</Emphasis>
 for the classes. The distance between the boundary line and the threshold line represents the threshold value, which is a negative number indicating how far the outlier members of the class are from the class boundary. The following figure represents these thresholds.</Body>
<Body>
<A ID="pgfId-1055230"></A>
<IMAGE xml:link="simple" href="classifier-4.gif" show="embed" actuate="auto"/>
</Body>
<Body>
<A ID="pgfId-1055193"></A>
The dotted lines represent some possible thresholds. The lines closer to the boundary represent thresholds with higher precision (but not complete precision), while the lines farther from the boundaries represent higher recall. For members of the triangle class that are on the other side of the square class boundaries, those members are not in the class, but if they are within the threshold you choose, then they are considered part of the class.</Body>
<Body>
<A ID="pgfId-1055274"></A>
One of the classifier APIs (<code>
cts:thresholds</code>
) helps you find the right thresholds for your training content set so you can get the right balance between precision and recall when you run unknown content against the classifier to determin class membership.</Body>
<Body>
<A ID="pgfId-1056980"></A>
The following figure shows the triangle class boundary, including the precision and recall calculations based on a threshold (the triangle class is below the threshold line):</Body>
<Body>
<A ID="pgfId-1057027"></A>
<IMAGE xml:link="simple" href="classifier-5.gif" show="embed" actuate="auto"/>
</Body>
<Heading-3>
<A ID="pgfId-1054386"></A>
<A ID="39167"></A>
Training Content for the Classifier </Heading-3>
<Body>
<A ID="pgfId-1054391"></A>
To find the best thresholds for your content, you need to <Emphasis>
train</Emphasis>
 the classifier with sample content that represents members of all of the classes. It is very important to find good training samples, as the quality of the training will directly impact the quality of your classification.</Body>
<Body>
<A ID="pgfId-1055282"></A>
The samples for each class should be statistically relevant, and should have samples that include both solid examples of the class (that is, samples that fall well into the positive side of the threshold from the class boundary) and samples that are close to the boundary for the class. The samples close to the boundary are very important, because they help determine the best thresholds for your content. For more details about training sets and setting the threshold, see <A href="classifier.xml#id(25981)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Creating a Training Set' on page&#160;182</A> and <A href="classifier.xml#id(84045)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Methodology For Determining Thresholds For Each Class' on page&#160;184</A>.</Body>
<Heading-2>
<A ID="pgfId-1054373"></A>
<A ID="14821"></A>
Classifier API</Heading-2>
<Body>
<A ID="pgfId-1054412"></A>
The classifier has three XQuery built-in functions. This section gives an overview and explains some of the features of the API, and includes the following parts:</Body>
<Body-bullet>
<A ID="pgfId-1055308"></A>
<A href="classifier.xml#id(99253)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
XQuery Built-In Functions</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055316"></A>
<A href="classifier.xml#id(62140)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Data Can Reside Anywhere or Be Constructed</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055317"></A>
<A href="classifier.xml#id(54703)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
API is Extremely Tunable</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055468"></A>
<A href="classifier.xml#id(29290)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Supports Versus Weights Classifiers</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1056628"></A>
<A href="classifier.xml#id(69293)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Kernels (Mapping Functions)</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055473"></A>
<A href="classifier.xml#id(82294)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Find Thresholds That Balance Precision and Recall</Hyperlink>
</A></Body-bullet>
<Body>
<A ID="pgfId-1055309"></A>
For details about the syntax and usage of the classifier API, see the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
.</Body>
<Heading-3>
<A ID="pgfId-1054413"></A>
<A ID="99253"></A>
XQuery Built-In Functions</Heading-3>
<Body>
<A ID="pgfId-1055318"></A>
The classifier API includes three XQuery functions:</Body>
<Body-bullet>
<A ID="pgfId-1054129"></A>
<code>
cts:classify</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054130"></A>
<code>
cts:thresholds</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054131"></A>
<code>
cts:train</code>
</Body-bullet>
<Body>
<A ID="pgfId-1055338"></A>
You use these functions to take training nodes use them to compute classifiers. Creating a classifier specification is an iterative process whereby you create training content, train the classifier (using <code>
cts:train</code>
) with the training content, test your classifier on some other training content (using <code>
cts:classify</code>
), compute the thresholds on the training content (using <code>
cts:threshold</code>
), and repeat this process until you are satisfied with the results. For details about the syntax and usage of the classifier API, see the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
.</Body>
<Heading-3>
<A ID="pgfId-1054421"></A>
<A ID="62140"></A>
Data Can Reside Anywhere or Be Constructed</Heading-3>
<Body>
<A ID="pgfId-1054425"></A>
The classifier APIs take nodes and elements, so you can either use XQuery to construct the data for the nodes you are classifying or training, or you can store them in the database (or somewhere else), whichever is more convenient. Because the APIs take nodes as parameters, there is a lot of flexibility in how you store your training and classification data.</Body>
<Note>
<A ID="pgfId-1056612"></A>
There is an exception to this: if you are using the <code>
supports</code>
 form of the classifier, then the training data must reside in the database, and you must pass in the training nodes when you perform classification (that is, when you run <code>
cts:classify</code>
) on unknown content. </Note>
<Heading-3>
<A ID="pgfId-1054426"></A>
<A ID="54703"></A>
API is Extremely Tunable</Heading-3>
<Body>
<A ID="pgfId-1054430"></A>
The classifier API has many options, and is therefore extremely tunable. You can choose the different index options and kernel types for <code>
cts:train</code>
, as well as specify limits and thresholds. When you change the kernel type for <code>
cts:train</code>
, it will effect the results you get from classification, as well as effect the performance. Because classification is an iterative process, experimentation with your own content set tends to help get better results from the classifier. You might change some parameters during different iterations and see which gives the better classification for your content. </Body>
<Body>
<A ID="pgfId-1055376"></A>
The following section describes the differences between the supports and weights forms of the classifier. For details on what each option of the classifier does, see the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
.</Body>
<Heading-3>
<A ID="pgfId-1054431"></A>
<A ID="29290"></A>
Supports Versus Weights Classifiers</Heading-3>
<Body>
<A ID="pgfId-1054444"></A>
There are two forms of the classifier:</Body>
<Body-bullet>
<A ID="pgfId-1054447"></A>
<code>
supports</code>
: allows the use of some of the more sophisticated kernels. It encodes the classifier by reference to specific documents in the training set, and is therefore more accurate because the whole training document can be used for classification; however, that means that the whole training set must be available during classification, and it must be stored in the database. Furthermore, since constructing a term vector is exactly equivalent to indexing, each time the classifier is invoked it regenerates the index terms for the whole training set. On the other hand, the actual representation of the classifier (the XML returned from <code>
cts:train</code>
) may be a lot more compact. The other advantage of the <code>
supports</code>
 form of the classifier is that it can give you error estimates for specific training documents, which may be a sign that those are misclassified or that other parameters are not set to optimal values.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054451"></A>
<code>
weights</code>
: encodes weights for each of the terms. For mathematical reasons, it cannot be used with the Gaussian or Geodesic kernels, although for many problems, those kernels give the best results. Since there will not be a weight for every term in training set (because of term compression), this form of the classifier is intrinsically less precise. If there are a lot of classes and a lot of terms, the classifier representation itself can get quite large. However, there is no need to have the training set on hand during classification, nor to construct term vectors from it (in essence to regenerate the index terms), so <code>
cts:classify</code>
 runs much faster with the <code>
weights</code>
 form of the classifier. </Body-bullet>
<Body>
<A ID="pgfId-1054510"></A>
Which one you choose depends on your answers to several questions and criteria, such as performance (does the <code>
supports</code>
 form take too much time and resources for your data?), accuracy (are you happy with the results you get with the <code>
weights</code>
 form with your data?), and other factors you might encounter while experimenting with the different forms. In general, the classifier is extremely tunable, and getting the best results for your data will be an iterative process, both on what you use for training data and what options you use in your classification.</Body>
<Heading-3>
<A ID="pgfId-1054443"></A>
<A ID="69293"></A>
Kernels (Mapping Functions)</Heading-3>
<Body>
<A ID="pgfId-1056627"></A>
You can choose different kernels during the training phase. The kernels are mapping functions, and they are used to determine the distance of a term vector from the edge of the class. For a description of each of the kernel mapping functions, see the documentation for <code>
cts:train</code>
 in the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
.</Body>
<Heading-3>
<A ID="pgfId-1056626"></A>
<A ID="82294"></A>
Find Thresholds That Balance Precision and Recall</Heading-3>
<Body>
<A ID="pgfId-1054437"></A>
As part of the iterative nature of training to create a classifier specification, one of the overriding goals is to find the best threshold values for your classes and your content set. Ideally, you want to find thresholds that strike a balance between good precision and good recall (for details on precision and recall, see <A href="classifier.xml#id(84623)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'XML SVM Classifier' on page&#160;175</A>). You use the <code>
cts:thresholds</code>
 function to calculate the thresholds based on a training set. For an overview of the iterative process of finding the right thresholds, see <A href="classifier.xml#id(84045)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Methodology For Determining Thresholds For Each Class' on page&#160;184</A>.</Body>
<Heading-2>
<A ID="pgfId-1053745"></A>
<A ID="43728"></A>
Leveraging XML With the Classifier</Heading-2>
<Body>
<A ID="pgfId-1054139"></A>
Because the classifier operates from an XQuery context, and because it is built into MarkLogic Server, it is intrinsically XML-aware. This has many advantages. You can choose to classify based on a particular element or element hierarchy (or even a more complicated XML construct), and then use that classifier against either other like elements or element hierarchies, or even against a totally different set of element or element hierarchies. You can perform XML-based searches to find the best training data. If you have built XML structure into your content, you can leverage that structure with the classifier.</Body>
<Body>
<A ID="pgfId-1056867"></A>
For example, if you have a set of articles that you want to classify, you can classify against only the <code>
&lt;executive-summary&gt;</code>
 section of the articles, which can help to exclude references to other content sections, and which might have a more universal style and language than the more detailed sections of the articles. This approach might result in using terms that are highly relevant to the topic of each article for determining class membership.</Body>
<Heading-2>
<A ID="pgfId-1054138"></A>
<A ID="25981"></A>
Creating a Training Set</Heading-2>
<Body>
<A ID="pgfId-1055756"></A>
This section describes the training content set you use to create a classifier, and includes the following parts:</Body>
<Body-bullet>
<A ID="pgfId-1055757"></A>
<A href="classifier.xml#id(71954)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Importance of the Training Set</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055765"></A>
<A href="classifier.xml#id(37617)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Defining Labels for the Training Set</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1055735"></A>
<A ID="71954"></A>
Importance of the Training Set</Heading-3>
<Body>
<A ID="pgfId-1055753"></A>
The quality of your classification can only be as good as the training set you use to run the classifier. It is extremely important to choose sample training nodes that not only represent obvious examples of a class, but also samples which represent edge cases that belong in or out of a class.</Body>
<Body>
<A ID="pgfId-1054863"></A>
Because the process of classification is about determining the edges of the classes, having good samples that are close to this edge is important. You cannot always determine what constitutes an edge sample, though, by examining the training sample. It it therefore good practice to get as many different kinds of samples in the training set as possible.</Body>
<Body>
<A ID="pgfId-1054864"></A>
As part of the process of training the classifier, you might need to add more samples, verify that the samples are actually good samples, or even take some samples away (if they turn out to be poor samples) from some classes. Also, you can specify negative samples for a class. It is an iterative process of finding the right training data and setting the various training options until you end up with a classifier that works well for your data.</Body>
<Heading-3>
<A ID="pgfId-1055740"></A>
<A ID="37617"></A>
Defining Labels for the Training Set</Heading-3>
<Body>
<A ID="pgfId-1055749"></A>
The second parameter to <code>
cts:train</code>
 is a label specification, which is a sequence of <code>
cts:label</code>
 elements, each one having a one <code>
cts:class</code>
 child. Each <code>
cts:label</code>
 element represents a node in the training set. The <code>
cts:label</code>
 elements must be in the order corresponding to the specified training nodes, and they each specify to which class the corresponding training node belongs. For example, the following <code>
cts:label</code>
 nodes specifies that the first training node is in the class <code>
comedy</code>
, the second in the class <code>
tragedy</code>
, and the third in the class <code>
history</code>
:</Body>
<Code>
<A ID="pgfId-1055785"></A>
&lt;cts:label&gt;
&#160;&#160;&lt;cts:class name=&quot;comedy&quot;/&gt;
&lt;/cts:label&gt;
&lt;cts:label&gt;
&#160;&#160;&lt;cts:class name=&quot;tragedy&quot;/&gt;
&lt;/cts:label&gt;
&lt;cts:label&gt;
&#160;&#160;&lt;cts:class name=&quot;history&quot;/&gt;
&lt;/cts:label&gt;</Code>
<Body>
<A ID="pgfId-1055786"></A>
Because the labels must be in the order corresponding to the training nodes, you might find it convenient to generate the labels from the training nodes. For example, the following code extracts the class name for the labels from a property names <code>
playtype</code>
 stored in the property corresponding to the training nodes:</Body>
<Code>
<A ID="pgfId-1055815"></A>
for $play in xdmp:directory(&quot;/plays/&quot;, &quot;1&quot;)
return
&#160;&#160;&lt;cts:labels&gt;
&#160;&#160;&#160;&#160;&lt;cts:class name={
&#160;&#160;&#160;&#160;&#160;&#160;xdmp:document-property(xdmp:node-uri($play))//playtype/text()}/&gt;
&#160;&#160;&lt;/cts:labels&gt;</Code>
<Body>
<A ID="pgfId-1056650"></A>
If you have training samples that represent negative samples for a class (that is, they are examples of what does <Emphasis>
not</Emphasis>
 belong in the class), you can label them such by specifying the <code>
val=&quot;-1&quot;</code>
 attribute on the <code>
cts:class</code>
 element as follows:</Body>
<Code>
<A ID="pgfId-1056657"></A>
&lt;cts:class name=&quot;comedy&quot; val=&quot;-1&quot;/&gt;</Code>
<Body>
<A ID="pgfId-1056875"></A>
Additionally, you can include multiple classes in a label (because membership in one class is independent of membership in another). For example:</Body>
<Code>
<A ID="pgfId-1056876"></A>
&lt;cts:label&gt;
&#160;&#160;&lt;cts:class name=&quot;comedy&quot; val=&quot;-1&quot;/&gt;
&#160;&#160;&lt;cts:class name=&quot;tragedy&quot;/&gt;
&#160;&#160;&lt;cts:class name=&quot;history&quot;/&gt;
&lt;/cts:label&gt;</Code>
<Heading-2>
<A ID="pgfId-1053759"></A>
<A ID="84045"></A>
Methodology For Determining Thresholds For Each Class</Heading-2>
<Body>
<A ID="pgfId-1053923"></A>
Use the following methodology to determine appropriate per-class thresholds for classification: </Body>
<Number1>
<A ID="pgfId-1054533"></A>
Partition the training set into two parts. Ideally, the partitions should be statistically equal. One way to achieve this is to randomize which nodes go into one partition and which go into the other. </Number1>
<NumberList>
<Number>
<A ID="pgfId-1054569"></A>
Run <code>
cts:train</code>
 on the first half of the training set. </Number>
<Number>
<A ID="pgfId-1054583"></A>
Run <code>
cts:classify</code>
 on the second half of the training set with the output of <code>
cts:train</code>
 from the first half in the previous step. This is to validate that the training data you used produced good classification. Use the default value for the <code>
thresholds</code>
 option for this run. The default value is a very large negative number, so this run will measure the distance from the actual class boundary for each node in the training set. </Number>
<Number>
<A ID="pgfId-1054590"></A>
Run <code>
cts:thresholds</code>
 to compute thresholds for the second half of the training set. This will further validate your training data and the parameters you set when running <code>
cts:train</code>
 on your training data. </Number>
<Number>
<A ID="pgfId-1054669"></A>
Iterate through the previous steps until you are satisfied with the results from your training content (that is, you until you are satisfied with the classifier you create). You might need to experiment with the various option settings for <code>
cts:train</code>
 (for example, different kernels, different index settings, and so on) until you get the classification you desire.</Number>
<Number>
<A ID="pgfId-1054596"></A>
After you are satisfied that you are getting good results, run <code>
cts:classify</code>
 on the unknown documents, using the computed thresholds (the values from <code>
cts:thresholds</code>
) as the boundaries for deciding on class membership.</Number>
</NumberList>
<Note>
<A ID="pgfId-1056708"></A>
Any time you pass thresholds to <code>
cts:train</code>
, the thresholds apply to <code>
cts:classify</code>
. You can pass them either with <code>
cts:train</code>
 or <code>
cts:classify</code>
, though, and the effect is the same.</Note>
<EndList-root>
<A ID="pgfId-1054683"></A>
The following diagram illustrates this iterative process:</EndList-root>
<Body>
<A ID="pgfId-1054687"></A>
<IMAGE xml:link="simple" href="classifier-6.gif" show="embed" actuate="auto"/>
</Body>
<Heading-2>
<A ID="pgfId-1055332"></A>
<A ID="93018"></A>
Example: Training and Running the Classifier</Heading-2>
<Body>
<A ID="pgfId-1054614"></A>
This section describes the steps needed to train the classifier against a content set of the plays of William Shakespeare. This is meant is a simple example for illustrating how to use the classifier, not necessarily as an example of the best results you can get out of the classifier. The steps are divided into the following parts:</Body>
<Body-bullet>
<A ID="pgfId-1055667"></A>
<A href="classifier.xml#id(57079)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Shakespeare's Plays: The Training Set</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055884"></A>
<A href="classifier.xml#id(43922)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Comedy, Tragedy, History: The Classes</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055671"></A>
<A href="classifier.xml#id(43122)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Partition the Training Content Set</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1056303"></A>
<A href="classifier.xml#id(29046)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Create Labels on the First Half of the Training Content</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055672"></A>
<A href="classifier.xml#id(13574)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Run cts:train on the First Half of the Training Content</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055673"></A>
<A href="classifier.xml#id(15833)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Run cts:classify on the Second Half of the Content Set</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055700"></A>
<A href="classifier.xml#id(25690)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Use cts:thresholds to Compute the Thresholds on the Second Half</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055705"></A>
<A href="classifier.xml#id(28466)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Evaluating Your Results, Make Changes, and Run Another Iteration</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055710"></A>
<A href="classifier.xml#id(57940)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Run the Classifier on Other Content</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1055484"></A>
<A ID="57079"></A>
Shakespeare's Plays: The Training Set</Heading-3>
<Body>
<A ID="pgfId-1055883"></A>
When you are creating a classifier, the first step is to choose some training content. In this example, we will use the plays of William Shakespeare as the training set from which to create a classifier.</Body>
<Body>
<A ID="pgfId-1055889"></A>
The Shakespeare plays are available in XML at the following URL (subject to the copyright restrictions stated in the plays):</Body>
<Body>
<A ID="pgfId-1055892"></A>
<Hyperlink>
<A href="http://www.oasis-open.org/cover/bosakShakespeare200.html" xml:link="simple" show="replace" actuate="user" CLASS="URL">http://www.oasis-open.org/cover/bosakShakespeare200.html</A></Hyperlink>
</Body>
<Body>
<A ID="pgfId-1055907"></A>
This example assumes the plays are loaded into a MarkLogic Server database under the directory <code>
/shakespeare/plays/</code>
. There are 37 plays.</Body>
<Heading-3>
<A ID="pgfId-1055882"></A>
<A ID="43922"></A>
Comedy, Tragedy, History: The Classes</Heading-3>
<Body>
<A ID="pgfId-1055488"></A>
After deciding on the training set, the next step is to choose classes in which you divide the set, as well as choosing labels for those classes. For Shakespeare, the classes are <code>
COMEDY</code>
, <code>
TRAGEDY</code>
, and <code>
HISTORY</code>
. You must decide which plays belong to each class. To determine which Shakespeare plays are comedies, tragedies, and histories, consult your favorite Shakespeare scholars (there is reasonable, but not complete agreement about which plays belong in which classes).</Body>
<Body>
<A ID="pgfId-1055936"></A>
For convenience, we will store the classes in the properties document at each play URI. To create the properties for each document, perform something similar to the following for each play (inserting the appropriate class as the property value):</Body>
<Code>
<A ID="pgfId-1055949"></A>
xdmp:document-set-properties(&quot;/shakespeare/plays/hamlet.xml&quot;, 
&#160;&#160;&#160;&#160;&#160;&#160;&lt;playtype&gt;TRAGEDY&lt;/playtype&gt;)</Code>
<Body>
<A ID="pgfId-1055968"></A>
For details on properties in MarkLogic Server, see <A href="../dev_guide/properties.xml#id(78944)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Properties Documents and Directories</Hyperlink>
</A> in the <Emphasis>
Application Developer's Guide</Emphasis>
.</Body>
<Heading-3>
<A ID="pgfId-1055489"></A>
<A ID="43122"></A>
Partition the Training Content Set</Heading-3>
<Body>
<A ID="pgfId-1055494"></A>
Next, we will divide the training set into two parts, where we know the class of each node in both parts. We will use the first part to train and the second part to validate the classifier built from the first half of the training set. The two parts should be statistically random, and to do that we will simply take the first half in the order that the documents return from the <code>
xdmp:directory</code>
 call. You can choose a more sophisticated randomization technique if you like. </Body>
<Heading-3>
<A ID="pgfId-1055495"></A>
<A ID="29046"></A>
Create Labels on the First Half of the Training Content</Heading-3>
<Body>
<A ID="pgfId-1055982"></A>
As we are taking the first half of the play for the training content, we will need labels for each node (in this example, we are using the document node for each play as the training nodes). To create the labels on the first half of the content, run a query statement similar to the following:</Body>
<Code>
<A ID="pgfId-1056015"></A>
for $x in xdmp:directory(&quot;/shakespeare/plays/&quot;, &quot;1&quot;)[1 to 19]
return 
&lt;cts:label&gt;
&#160;&#160;&lt;cts:class name={xdmp:document-properties(xdmp:node-uri($x))
&#160;&#160;&#160;&#160;&#160;&#160;&#160;//playtype/text()}/&gt;
&lt;/cts:label&gt;</Code>
<Note>
<A ID="pgfId-1056906"></A>
For simplicity, this example uses the first 19 items of the content set as the training nodes. The samples you use should use a statistically random sample of the content for the training set, so you might want to use a slightly more complicated method (that is, one that ensures randomness) for choosing the training set.</Note>
<Heading-3>
<A ID="pgfId-1055981"></A>
<A ID="13574"></A>
Run cts:train on the First Half of the Training Content</Heading-3>
<Body>
<A ID="pgfId-1055501"></A>
Next, you run <code>
cts:train</code>
 with your training content and labels. The following code constructs the labels and runs <code>
cts:train</code>
 to generate a classifier specification:</Body>
<Code>
<A ID="pgfId-1056035"></A>
let $firsthalf := xdmp:directory(&quot;/shakespeare/plays/&quot;, &quot;1&quot;)[1 to 19]
let $labels := for $x in $firsthalf 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;return
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;cts:label&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;cts:class name={xdmp:document-properties(xdmp:node-uri($x))
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//playtype/text()}/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;/cts:label&gt;
return
cts:train($firsthalf, $labels, 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;options xmlns=&quot;cts:train&quot;&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;classifier-type&gt;supports&lt;/classifier-type&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;/options&gt;)</Code>
<Body>
<A ID="pgfId-1056159"></A>
You can either save the generated classifier specification in a document in the database or run this code dynamically in the next step.</Body>
<Heading-3>
<A ID="pgfId-1055509"></A>
<A ID="15833"></A>
Run cts:classify on the Second Half of the Content Set</Heading-3>
<Body>
<A ID="pgfId-1060796"></A>
Next, you take the classifier specification created with the first half of the training set and run <code>
cts:classify</code>
 on the second half of the content set, as follows:</Body>
<Code>
<A ID="pgfId-1060797"></A>
let $firsthalf := xdmp:directory(&quot;/shakespeare/plays/&quot;, &quot;1&quot;)[1 to 19]
let $secondhalf := xdmp:directory(&quot;/shakespeare/plays/&quot;, &quot;1&quot;)[20 to 37]
let $classifier :=  
&#160;&#160;let $labels := for $x in $firsthalf 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;cts:label&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;cts:class name={xdmp:document-properties(xdmp:node-uri($x))
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//playtype/text()}/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;/cts:label&gt;
&#160;&#160;return
&#160;&#160;cts:train($firsthalf, $labels, 
&#160;&#160;&#160;&#160;&#160;&#160;&lt;options xmlns=&quot;cts:train&quot;&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;classifier-type&gt;supports&lt;/classifier-type&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;/options&gt;)
return
cts:classify($secondhalf, $classifier, 
&#160;&#160;&#160;&#160;&#160;&#160;&lt;options xmlns=&quot;cts:classify&quot;/&gt;,
&#160;&#160;&#160;&#160;&#160;&#160;$firsthalf)</Code>
<Heading-3>
<A ID="pgfId-1055514"></A>
<A ID="25690"></A>
Use cts:thresholds to Compute the Thresholds on the Second Half</Heading-3>
<Body>
<A ID="pgfId-1055518"></A>
Next, calculate <code>
cts:label</code>
 elements for the second half of the content and use it to compute the thresholds to use with the classifier. The following code runs <code>
cts:train</code>
 and <code>
cts:classify</code>
 again for clarity, although the output of each could be stored in a document.</Body>
<Code>
<A ID="pgfId-1060755"></A>
let $firsthalf := xdmp:directory(&quot;/shakespeare/plays/&quot;, &quot;1&quot;)[1 to 19]
let $secondhalf := xdmp:directory(&quot;/shakespeare/plays/&quot;, &quot;1&quot;)[20 to 37]
let $firstlabels := for $x in $firsthalf 
        return
        &lt;cts:label&gt;
          &lt;cts:class name={xdmp:document-properties(xdmp:node-uri($x))
                                     //playtype/text()}/&gt;
        &lt;/cts:label&gt;
let $secondlabels := for $x in $secondhalf 
        return
        &lt;cts:label&gt;
          &lt;cts:class name={xdmp:document-properties(xdmp:node-uri($x))
                                     //playtype/text()}/&gt;
        &lt;/cts:label&gt;
let $classifier :=  
    cts:train($firsthalf, $firstlabels, 
      &lt;options xmlns=&quot;cts:train&quot;&gt;
        &lt;classifier-type&gt;supports&lt;/classifier-type&gt;
      &lt;/options&gt;)
let $classifysecond :=
  cts:classify($secondhalf, $classifier, 
        &lt;options xmlns=&quot;cts:classify&quot;/&gt;,
        $firsthalf)
return
cts:thresholds($classifysecond, $secondlabels)</Code>
<Body>
<A ID="pgfId-1056269"></A>
This produces output similar to the following:</Body>
<Code>
<A ID="pgfId-1060809"></A>
&lt;thresholds xmlns=&quot;http://marklogic.com/cts&quot;&gt;
&#160;&#160;&lt;class name=&quot;TRAGEDY&quot; threshold=&quot;-0.00215207&quot; precision=&quot;1&quot;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;recall=&quot;0.666667&quot; f=&quot;0.8&quot; count=&quot;3&quot;/&gt;
&#160;&#160;&lt;class name=&quot;COMEDY&quot; threshold=&quot;0.216902&quot; precision=&quot;0.916667&quot;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;recall=&quot;1&quot; f=&quot;0.956522&quot; count=&quot;11&quot;/&gt;
&#160;&#160;&lt;class name=&quot;HISTORY&quot; threshold=&quot;0.567648&quot; precision=&quot;1&quot; 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;recall=&quot;1&quot; f=&quot;1&quot; count=&quot;4&quot;/&gt;
&lt;/thresholds&gt;</Code>
<Heading-3>
<A ID="pgfId-1055519"></A>
<A ID="28466"></A>
Evaluating Your Results, Make Changes, and Run Another Iteration</Heading-3>
<Body>
<A ID="pgfId-1055676"></A>
Finally, you can analyze the results from <code>
cts:thresholds</code>
. As an ideal, the thresholds should be zero. In practice, a negative number relatively close to zero makes a good threshold. The threshold for tragedy above is quite good, but the thresholds for the other classes are not quite as good. If you want the thresholds to be better, you can try running everything again with different parameters for the kernel, for the indexing options, and so on. Also, you can change your training data (to try and find better examples of comedy, for example).</Body>
<Heading-3>
<A ID="pgfId-1055677"></A>
<A ID="57940"></A>
Run the Classifier on Other Content</Heading-3>
<Body>
<A ID="pgfId-1055681"></A>
Once you are satisfied with your classifier, you can run it on other content. For example, you can try running it on SPEECH elements in the shakespeare plays, or try it on plays by other playwrights. </Body>
</XML>
