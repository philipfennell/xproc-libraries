<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="wildcard.css" type="text/css" charset="UTF-8"?>
<XML>
<TITLE> </TITLE><Heading-1>
<A ID="pgfId-1044986"></A>
<A ID="66341"></A>
Understanding and Using Wildcard Searches</Heading-1>
<pagenum>
<A ID="pgfId-1046308"></A>
148</pagenum>
<Body>
<A ID="pgfId-1044987"></A>
This chapter describes wildcard searches in MarkLogic Server. The following sections are included:</Body>
<Body-bullet>
<A ID="pgfId-1045574"></A>
<A href="wildcard.xml#id(74842)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Wildcards in MarkLogic Server</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1045582"></A>
<A href="wildcard.xml#id(39731)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Enabling Wildcard Searches</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1045597"></A>
<A href="wildcard.xml#id(38546)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Interaction with Other Search Features</Hyperlink>
</A></Body-bullet>
<Heading-2>
<A ID="pgfId-1044989"></A>
<A ID="74842"></A>
Wildcards in MarkLogic Server</Heading-2>
<Body>
<A ID="pgfId-1045974"></A>
Wildcard searches enable MarkLogic Server to return results that match combinations of characters and wildcards. Wildcard searches are not simply exact string matches, but are based on character pattern matching between the characters specified in a query and words in documents that contain those character patterns.  This section describes wildcards and includes the following topics:</Body>
<Body-bullet>
<A ID="pgfId-1050729"></A>
<A href="wildcard.xml#id(21912)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Wildcard Characters</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1050737"></A>
<A href="wildcard.xml#id(61953)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Rules for Wildcard Searches</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1050720"></A>
<A ID="21912"></A>
Wildcard Characters</Heading-3>
<Body>
<A ID="pgfId-1044990"></A>
MarkLogic Server supports two wildcard characters: <code>
*</code>
 and <code>
?</code>
.</Body>
<Body-bullet>
<A ID="pgfId-1044991"></A>
<code>
*</code>
 matches zero or more non-space characters. </Body-bullet>
<Body-bullet>
<A ID="pgfId-1044992"></A>
<code>
?</code>
 matches exactly one non-space character.</Body-bullet>
<Body>
<A ID="pgfId-1044993"></A>
For example, <code>
he*</code>
 will match any word starting with <code>
he,</code>
 such as <code>
he</code>
, <code>
her</code>
, <code>
help</code>
, <code>
hello</code>
, <code>
helicopter</code>
, and so on. On the other hand, <code>
he?</code>
 will only match three-letter words starting with <code>
he</code>
, such as <code>
hem</code>
, <code>
hen</code>
, and so on.</Body>
<Heading-3>
<A ID="pgfId-1044994"></A>
<A ID="61953"></A>
Rules for Wildcard Searches</Heading-3>
<Body>
<A ID="pgfId-1050715"></A>
The following are the basic rules for wildcard searches in MarkLogic Server:</Body>
<Body-bullet>
<A ID="pgfId-1050748"></A>
There can be more than one wildcard in a single search term or phrase, and the two wildcard characters can be used in combination. For example, <code>
m*??</code>
 will match words starting with <code>
m</code>
 with three or more characters.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1044995"></A>
Spaces are used as word breaks, and wildcard matching only works within a single word. For example, <code>
m*th*</code>
 will match <underline>
m</underline>
<code>
e</code>
<underline>
th</underline>
<code>
od</code>
 but not <underline>
m</underline>
<code>
eet </code>
<underline>
th</underline>
<code>
ere</code>
.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1052065"></A>
If the <code>
*</code>
 wildcard is specified by itself in a value query (for example, <code>
cts:element-value-query</code>
, <code>
cts:element-value-match</code>
), it matches everything (spanning word breaks). For example, <code>
*</code>
 will match the value <code>
meet me there</code>
. </Body-bullet>
<Body-bullet>
<A ID="pgfId-1055359"></A>
If the <code>
*</code>
 wildcard is specified with a non-wildcard character, it will match in value lexicon queries (for example, <code>
cts:element-value-match</code>
), but will not match in value queries (for example, <code>
cts:element-value-query</code>
). For example, <code>
m*</code>
 will match the value <code>
meet me there </code>
for a value lexicon search (for example, <code>
cts:element-value-match</code>
) but will not match the value for a value query search (for example, <code>
cts:element-value-query</code>
), because the value query only matches the one word. A value search for <code>
m* *</code>
 will match the value (because <code>
m*</code>
 matches the first word and <code>
*</code>
 matches everything after it). </Body-bullet>
<Body-bullet>
<A ID="pgfId-1051526"></A>
If <code>
&quot;wildcarded&quot;</code>
 is explicitly specified in the <code>
cts:query</code>
 expression, then the search is performed as a wildcard search.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1051625"></A>
If neither <code>
&quot;wildcarded&quot;</code>
 nor <code>
&quot;unwildcarded&quot;</code>
 is specified in the <code>
cts:query</code>
 expression, the database configuration and query text determine wildcarding. If the database has any wildcard indexes enabled (<code>
three character searches</code>
, <code>
two character searches</code>
, <code>
one character searches</code>
, or <code>
trailing wildcard searches</code>
) and if the query text contains either of the wildcard characters <code>
?</code>
 or <code>
*</code>
, then the wildcard characters are treated as wildcards and the search is performed <code>
&quot;wildcarded&quot;</code>
. If none of the wildcard indexes are enabled, the wildcard characters are treated as punctuation and the search is performed <code>
unwildcarded</code>
 (unless <code>
&quot;wildcarded&quot;</code>
 is specified in the <code>
cts:query</code>
 expression).</Body-bullet>
<Body-bullet>
<A ID="pgfId-1056008"></A>
If the query has the <code>
punctuation-sensitive</code>
 option, then punctuation is treated as word characters for wildcard searches. For example, a <code>
punctuation-sensitive</code>
 wildcard search for <code>
d*benz</code>
 would match <code>
daimler-benz</code>
.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1056038"></A>
If the query has the <code>
whitespace-sensitive</code>
 option, then whitespace is treated as word characters. This can be useful for matching spaces in wildcarded value queries. You can use the <code>
whitespace-sensitive</code>
 option in wildcarded word queries, too, although it might not make much sense, as it will match more than you might expect.</Body-bullet>
<Heading-2>
<A ID="pgfId-1044996"></A>
<A ID="39731"></A>
Enabling Wildcard Searches</Heading-2>
<Body>
<A ID="pgfId-1044997"></A>
Wildcard searches use character indexes, lexicons, and trailing wildcard indexes to speed performance. To ensure that wildcard searches are fast, you should enable at least one wildcard index (three character searches, trailing wildcard searches, two character searches, and/or one character searches) and fast element character searches (if you want fast searches within specific elements) in the Admin Interface database configuration screen. Wildcard are disabled by default. If you enable character indexes, you should plan on allocating an additional amount of disk space approximately three times the size of the source content. </Body>
<Body>
<A ID="pgfId-1049980"></A>
This section describes the following topics:</Body>
<Body-bullet>
<A ID="pgfId-1049964"></A>
<A href="wildcard.xml#id(68337)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Specifying Wildcards in Queries</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1056153"></A>
<A href="wildcard.xml#id(14163)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Recommended Wildcard Index Settings</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1049975"></A>
<A href="wildcard.xml#id(61884)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Understanding the Different Wildcard Indexes</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1049951"></A>
<A ID="68337"></A>
Specifying Wildcards in Queries</Heading-3>
<Body>
<A ID="pgfId-1044998"></A>
If any wildcard indexes are enabled for the database, you can further control the use of wildcards at the query level. You can use wildcards with any of the MarkLogic <code>
cts:query</code>
 leaf-level functions, such as <code>
cts:word-query</code>
, <code>
cts:element-word-query, and cts:element-value-query</code>
. For details on the <code>
cts:query</code>
 functions, see <A href="cts_query.xml#id(51991)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Composing cts:query Expressions' on page&#160;56</A>. You can use the <code>
&quot;wildcarded&quot;</code>
 and <code>
&quot;unwildcarded&quot;</code>
 query option to turn wildcarding on or off explicitly in the <code>
cts:query</code>
 constructor functions. See the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
 for more details.</Body>
<Body>
<A ID="pgfId-1044999"></A>
If you leave the wildcard option unspecified and there are any wildcard indexes enabled, MarkLogic Server will perform a wildcard query if <code>
*</code>
 or <code>
?</code>
 is present in the query. For example, the following search function:</Body>
<Code>
<A ID="pgfId-1045632"></A>
<code>
cts:search(fn:doc(), cts:word-query(&quot;he*&quot;))</code>
 </Code>
<Body>
<A ID="pgfId-1045634"></A>
will result in a wildcard search. Therefore, as long as any wildcard indexes are enabled in the database, you do not have to turn on wildcarding explicitly to perform wildcard searches.</Body>
<Body>
<A ID="pgfId-1045881"></A>
When wildcard indexing is enabled in the database, the system will also deliver higher performance for<code>
 fn:contains</code>
, <code>
fn:matches</code>
, <code>
fn:starts-with</code>
 and <code>
fn:ends-with</code>
 for most query expressions.</Body>
<Note>
<A ID="pgfId-1045000"></A>
If character indexes, lexicons, and trailing wildcard indexes are all disabled in a database and wildcarding is explicitly enabled in the query (with the <code>
&quot;wildcarded&quot;</code>
 option to the leaf-level <code>
cts:query</code>
 constructor), the query will execute, but might require a lot of processing. Such queries will be fast if they are very selective and only need to do the wildcard searches over a relatively small amount of content, but can take a long time if they actually need to filter out results from a large amount of content.</Note>
<Heading-3>
<A ID="pgfId-1045009"></A>
<A ID="14163"></A>
Recommended Wildcard Index Settings</Heading-3>
<Body>
<A ID="pgfId-1056077"></A>
To enable any kind of wildcard query functionality with a good combination of performance and database size, MarkLogic recommends the following index settings:</Body>
<Body-bullet>
<A ID="pgfId-1056084"></A>
<code>
word searches</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1056139"></A>
<code>
three character word searches</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1056094"></A>
<code>
word positions</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1056101"></A>
<code>
word lexicon</code>
 in the codepoint collation</Body-bullet>
<Body-bullet>
<A ID="pgfId-1056108"></A>
<code>
three character word positions</code>
</Body-bullet>
<Body>
<A ID="pgfId-1056127"></A>
This combination will provide accurate and fast wildcard queries for a wide variety of wildcard searches, including leading and trailing wildcarded searches. If you add the <code>
trailing wildcard searches</code>
 index, you will get slightly more efficient trailing wildcard searches, but with increased database size. The next section describes the various different wildcard indexes.</Body>
<Heading-3>
<A ID="pgfId-1056066"></A>
<A ID="61884"></A>
Understanding the Different Wildcard Indexes</Heading-3>
<Body>
<A ID="pgfId-1049948"></A>
You configure the index settings at the database level, using the Admin Interface. For details on configuring database settings and on other text indexes, see the 'Databases' and Text Indexes' chapters in the <Emphasis>
Administrator's Guide</Emphasis>
. </Body>
<Body>
<A ID="pgfId-1050465"></A>
The following table describes the indexing options that apply to wildcard searches.</Body>
<TableAnchor>
<A ID="pgfId-1050125"></A>
</TableAnchor>
<TABLE>
<ROW>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1050904"></A>
Index</CellHeading>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1050906"></A>
Description</CellHeading>
</TH>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1055418"></A>
Word lexicon</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1055420"></A>
Speeds up wildcard searches. Works in combination with any other available wildcard indexes to improve search index resolution and performance. When used in conjunction with the <code>
three character search</code>
 index, improves wildcard index resolution and speeds up wildcard searches. If you have <code>
three character search</code>
 and a word lexicon enabled for a database, then there is no need for either the <code>
one character</code>
 or <code>
two character search</code>
 indexes. For best performance, the word lexicon should be in the codepoint collation (<code>
http://marklogic.com/collation/codepoint</code>
). Additionally, enabling <code>
word searches</code>
 in the database will improve the accuracy of wildcard index resolution (more accurate <code>
xdmp:estimate</code>
 queries).</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1051423"></A>
<code>
trailing wildcard searches</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1051425"></A>
Speeds up wildcard searches where the search pattern contains the wildcard character at the end (for example, <code>
abc*</code>
). Turn this index on if you want to speed wildcard searches that match a trailing wildcard. The <code>
trailing wildcard search</code>
 index will use a similar amount of space as the <code>
three character search</code>
 index, but will generally be more efficient for trailing wildcard queries. </CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1050908"></A>
<code>
three character searches</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1050910"></A>
Speeds up wildcard searches where the search pattern contains three or more consecutive non-wildcard characters (for example, <code>
*abc</code>
). Turn this index on if you want to speed wildcard searches that match three or more characters anywhere in the wildcard expression. When combined with a codepoint word lexicon, speeds the performance of any wildcard search (including searches with fewer than three consecutive non-wildcard characters). MarkLogic recommends combining the <code>
three character search</code>
 index with a codepoint collation word lexicon. </CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1050912"></A>
<code>
fast element character searches</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1050914"></A>
Speeds up wildcard searches within a specific element. Also, speeds up element-based wildcard searches. Turn this index on if you want to improve performance of wildcard searches that query specific elements.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1051457"></A>
<code>
two character searches</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1051459"></A>
Speeds up wildcard searches where the search pattern contains two or more consecutive non-wildcard characters. Turn this index on if you want to speed up wildcard searches that match two or more characters (for example, <code>
ab*</code>
). This index is not needed if you have <code>
three character searches</code>
 and a word lexicon.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1051477"></A>
Element, Attribute, and Field word lexicons</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1051479"></A>
Speeds up wildcard searches for <code>
cts:element-value-query</code>
 and <code>
cts:element-attribute-value-query</code>
 expressions. Works in combination with any other available wildcard indexes to improve search index resolution and performance. When used in conjunction with the <code>
three character search</code>
 index, improves wildcard index resolution and speeds up wildcard searches. </CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1050922"></A>
<code>
one character searches</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1050924"></A>
Speeds up wildcard searches where the search pattern contains only a single non-wildcard character. Turn this index on if you want to speed up wildcard searches that match one or more characters (for example, <code>
a*</code>
). This index is not needed if you have <code>
three character searches</code>
 and a word lexicon.</CellBody>
</CELL>
</ROW>
</TABLE>
<Body>
<A ID="pgfId-1050252"></A>
As with all indexing, choosing which indexes you need is a trade-off. More indexes provides improved query performance, but uses more disk space and increases load and reindexing time. For most environments where wildcard searches are required, MarkLogic recommends enabling the <code>
three character searches </code>
and a codepoint collation word lexicon, but disabling one and two character searches. </Body>
<Body>
<A ID="pgfId-1050255"></A>
The <code>
three character searches</code>
 index combined with the word lexicon provides the best performance for most queries, and the <code>
fast element character searches</code>
 index is useful when you submit element queries. One and two character searches indexes are only used if you submit wildcard searches that try and match only one or two characters and you do not have the combination of a word lexicon and the <code>
three character searches</code>
 index. Because one and two character searches generally return a large number of matches, they might not justify the disk space and load time trade-offs. </Body>
<Note>
<A ID="pgfId-1055498"></A>
If you have the <code>
three character searches</code>
 index enabled and two and one character indexes disabled, and if you have no word lexicon, it is still possible to issue a wildcard query that searches for a two or one character stem (for example, <code>
ab*</code>
 or <code>
a*</code>
); these searches are allowed, but will not be fast. If you have a search user interface that allows users to enter such queries, you might want to check for these two or one character wildcard search patterns and issue an error, as these searches without the corresponding indexes can be slow and resource-intensive. Alternatively, add a codepoint collation word lexicon to your database.</Note>
<Heading-2>
<A ID="pgfId-1055500"></A>
<A ID="38546"></A>
Interaction with Other Search Features</Heading-2>
<Body>
<A ID="pgfId-1045698"></A>
This section describes the interactions between wildcard, stemming, and other search features in MarkLogic Server. The following topics are included:</Body>
<Body-bullet>
<A ID="pgfId-1045704"></A>
<A href="wildcard.xml#id(66278)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Wildcarding and Stemming</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1045712"></A>
<A href="wildcard.xml#id(43108)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Wildcarding and Punctuation Sensitivity</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1045010"></A>
<A ID="66278"></A>
Wildcarding and Stemming</Heading-3>
<Body>
<A ID="pgfId-1045011"></A>
Wildcard searches can be used in combination with stemming (for details on stemming, see <A href="stemming.xml#id(90878)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Understanding and Using Stemmed Searches' on page&#160;135</A>); that is, queries can perform stemmed searches and wildcard searches at the same time. However, the system will not perform a stemmed search on words that are wildcarded. For example, assume a search phrase of <code>
running car*</code>
. The term <code>
running</code>
 will be matched based on its stem. However, <code>
car*</code>
 will be matched based on a wildcard search, and will match <code>
car</code>
, <code>
cars</code>
, <code>
carriage</code>
, <code>
carpenter</code>
 and so on; stemmed word matches for the words matching the wildcard are <Emphasis>
not</Emphasis>
 returned. </Body>
<Heading-3>
<A ID="pgfId-1045012"></A>
<A ID="43108"></A>
Wildcarding and Punctuation Sensitivity</Heading-3>
<Body>
<A ID="pgfId-1045013"></A>
Stemming and punctuation sensitivity perform independently of each other. However, there is an interaction between wildcarding and punctuation sensitivity.  This section describes this interaction and includes the following parts:</Body>
<Body-bullet>
<A ID="pgfId-1050280"></A>
<A href="wildcard.xml#id(45154)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Implicitly and Explicitly Specifying Punctuation</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1050288"></A>
<A href="wildcard.xml#id(58362)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Rules for Punctuation and Wildcarding Interaction</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1050293"></A>
<A href="wildcard.xml#id(72740)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Examples of Wildcard and Punctuation Interactions</Hyperlink>
</A></Body-bullet>
<Heading-4>
<A ID="pgfId-1045014"></A>
<A ID="45154"></A>
Implicitly and Explicitly Specifying Punctuation</Heading-4>
<Body>
<A ID="pgfId-1045015"></A>
MarkLogic Server allows you to explicitly specify whether a query is punctuation sensitive and whether it uses wildcards. You specify this in the options for the query, as in the following example:</Body>
<Code>
<A ID="pgfId-1050344"></A>
<code>
cts:search(fn:doc(), cts:word-query(&quot;hello!&quot;, &quot;punctuation-sensitive&quot;) )</code>
 </Code>
<Body>
<A ID="pgfId-1050357"></A>
If you include a wildcard character in a punctuation sensitive search, it will treat the wildcard as punctuation. For example, the following query matches <code>
hello*</code>
, but not <code>
hellothere</code>
:</Body>
<Code>
<A ID="pgfId-1050377"></A>
<code>
cts:search(fn:doc(), cts:word-query(&quot;hello*&quot;, &quot;punctuation-sensitive&quot;) )</code>
 </Code>
<Body>
<A ID="pgfId-1050367"></A>
If the punctuation sensitivity option is left unspecified, the system performs a punctuation sensitive search if there is any non-wildcard punctuation in the query terms. For example, if punctuation is not specified, the following query:</Body>
<Code>
<A ID="pgfId-1050358"></A>
<code>
cts:search(fn:doc(), cts:word-query(&quot;hello!&quot;) )</code>
 </Code>
<Body>
<A ID="pgfId-1050359"></A>
will result in a punctuation sensitive search, and the following query:</Body>
<Code>
<A ID="pgfId-1045672"></A>
<code>
cts:search(fn:doc(), cts:word-query(&quot;hello&quot;) )</code>
 </Code>
<Body>
<A ID="pgfId-1045674"></A>
will result in a punctuation insensitive search.</Body>
<Body>
<A ID="pgfId-1045016"></A>
If a search is punctuation sensitive (whether implicitly or explicitly), MarkLogic Server will match the punctuation as well as the search term. Note that punctuation is not considered to be part of a word. For example, <code>
mark!</code>
 is considered to be a word <code>
mark</code>
 next to an exclamation point. If a search is punctuation insensitive, punctuation will match spaces.</Body>
<Heading-4>
<A ID="pgfId-1045017"></A>
<A ID="58362"></A>
Rules for Punctuation and Wildcarding Interaction</Heading-4>
<Body>
<A ID="pgfId-1045018"></A>
The characters <code>
?</code>
 and <code>
*</code>
 are considered punctuation in documents loaded into the database. However, <code>
?</code>
 and <code>
*</code>
 are also treated as wildcard characters in a query. This makes for interesting (and occasionally confusing) interaction between wildcarding and punctuation sensitivity.</Body>
<Body>
<A ID="pgfId-1045019"></A>
The following are the rules for the interaction between punctuation and wildcarding. They will help you determine how the system behaves when there are interactions between the punctuation and wildcard characters.</Body>
<Number1>
<A ID="pgfId-1045020"></A>
When wildcard indexes are disabled in the database, all queries default to <code>
&quot;unwildcarded&quot;</code>
, and wildcard characters are treated as punctuation. If you specify <code>
&quot;wildcarded&quot;</code>
 in the query, the query is a wildcard query and wildcard characters are treated as wildcards.</Number1>
<NumberList>
<Number>
<A ID="pgfId-1045021"></A>
Wildcarding trumps (has precedence over) punctuation sensitivity. That is, if the <code>
*</code>
 and/or <code>
?</code>
 characters are present in a query, <code>
*</code>
 and <code>
?</code>
 are treated as wildcards and not punctuation unless wildcarding is turned off. If wildcarding is turned off in the query (<code>
&quot;unwildcarded&quot;</code>
), they are treated as punctuation.</Number>
<Number>
<A ID="pgfId-1045022"></A>
If wildcarding and punctuation sensitivity are both explicitly off and punctuation characters (including <code>
*</code>
 and <code>
?</code>
) are in the query, they are treated as spaces.</Number>
<Number>
<A ID="pgfId-1045023"></A>
Wildcarding and punctuation sensitivity can be on at the same time. In this case, punctuation in a document is treated as characters, and wildcards in the query will match any character in the query, including punctuation characters. Therefore, the following query will match both <code>
hello*</code>
 and <code>
hellothere</code>
:</Number>
</NumberList>
<Code>
<A ID="pgfId-1050407"></A>
<code>
cts:search(fn:doc(), 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cts:word-query(&quot;hello*&quot;, 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(&quot;punctuation-sensitive&quot;, &quot;wildcarded&quot;) ) 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;)</code>
 </Code>
<Heading-4>
<A ID="pgfId-1045024"></A>
<A ID="72740"></A>
Examples of Wildcard and Punctuation Interactions</Heading-4>
<Body>
<A ID="pgfId-1045717"></A>
This section contains examples of the output of queries in the following categories:</Body>
<Body-bullet>
<A ID="pgfId-1045718"></A>
<A href="wildcard.xml#id(12964)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Wildcarding and Punctuation Sensitivity Not Specified (Wildcard Indexes Enabled)</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1045726"></A>
<A href="wildcard.xml#id(27972)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Wildcarding Explicitly Off, Punctuation Sensitivity Not Specified</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1045731"></A>
<A href="wildcard.xml#id(97478)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Wildcarding Not Specified, Punctuation Sensitivity Explicitly On (Wildcard Indexes Enabled)</Hyperlink>
</A></Body-bullet>
<Heading-5>
<A ID="pgfId-1045025"></A>
<A ID="12964"></A>
Wildcarding and Punctuation Sensitivity Not Specified (Wildcard Indexes Enabled)</Heading-5>
<Body>
<A ID="pgfId-1051792"></A>
The following examples show queries that are run when at least one wildcard index is enabled and no options are explicitly set on the <code>
cts:word-query</code>
.</Body>
<Body-bullet>
<A ID="pgfId-1045026"></A>
<Bold>
Example query:</Bold>
 <code>
cts:word-query(&quot;hello world&quot;)</code>
</Body-bullet>
<Body-indent>
<A ID="pgfId-1050521"></A>
<Bold>
Actual behavior:</Bold>
 Wildcarding off, punctuation insensitive</Body-indent>
<Body-indent>
<A ID="pgfId-1050522"></A>
<Bold>
Will match: </Bold>
<code>
hello world</code>
, <code>
hello ?! world</code>
, <code>
hello? world!</code>
 and so on</Body-indent>
<Body-bullet>
<A ID="pgfId-1050523"></A>
<Bold>
Example query:</Bold>
 <code>
cts:word-query(&quot;hello?world&quot;)</code>
</Body-bullet>
<Body-indent>
<A ID="pgfId-1045030"></A>
<Bold>
Actual behavior:</Bold>
 Wildcarding on, punctuation insensitive</Body-indent>
<Body-indent>
<A ID="pgfId-1045031"></A>
<Bold>
Will match:</Bold>
 <code>
helloaworld</code>
</Body-indent>
<Body-indent>
<A ID="pgfId-1045032"></A>
<Bold>
Will not match:</Bold>
 <code>
hello world</code>
, <code>
hello!world</code>
</Body-indent>
<Body-bullet>
<A ID="pgfId-1045033"></A>
<Bold>
Example query:</Bold>
 <code>
cts:word-query(&quot;hello*world&quot;)</code>
</Body-bullet>
<Body-indent>
<A ID="pgfId-1045034"></A>
<Bold>
Actual behavior:</Bold>
 Wildcarding on, punctuation insensitive</Body-indent>
<Body-indent>
<A ID="pgfId-1045035"></A>
<Bold>
Will match:</Bold>
 <code>
helloabcworld</code>
</Body-indent>
<Body-indent>
<A ID="pgfId-1045036"></A>
<Bold>
Will not match:</Bold>
 <code>
hello to world</code>
, <code>
hello-to-world</code>
</Body-indent>
<Body-bullet>
<A ID="pgfId-1045037"></A>
<Bold>
Example query:</Bold>
 <code>
cts:word-query(&quot;hello * world&quot;)</code>
</Body-bullet>
<Body-indent>
<A ID="pgfId-1045038"></A>
<Bold>
Actual behavior:</Bold>
 Wildcarding on, punctuation insensitive</Body-indent>
<Body-indent>
<A ID="pgfId-1045848"></A>
<Bold>
Will match: </Bold>
<code>
hello to world</code>
, <code>
hello-to-world</code>
</Body-indent>
<Body-indent>
<A ID="pgfId-1045040"></A>
<Bold>
Will not match: </Bold>
<code>
helloaworld</code>
, <code>
hello world</code>
, <code>
hello ! world</code>
</Body-indent>
<Note>
<A ID="pgfId-1045861"></A>
Adjacent spaces are collapsed for string comparisons in the server. In the query phrase <code>
hello * world</code>
, the two spaces on each side of the asterisk are not collapsed for comparison since they are not adjacent to each other. Therefore, <code>
hello world</code>
 is not a match since there is only a single space between <code>
hello</code>
 and <code>
world</code>
 but <code>
hello&#160;*&#160;world</code>
 requires two spaces because the spaces were not collapsed. The phrase <code>
hello&#160;!&#160;world</code>
 is also not a match because <code>
!</code>
 is treated as a space (punctuation insensitive), and then all three consecutive spaces are collapsed to a single space before the string comparison.</Note>
<Body-bullet>
<A ID="pgfId-1045041"></A>
<Bold>
Example query:</Bold>
 <code>
cts:word-query(&quot;hello! world&quot;)</code>
</Body-bullet>
<Body-indent>
<A ID="pgfId-1045042"></A>
<Bold>
Actual behavior:</Bold>
 Wildcarding off, punctuation sensitive</Body-indent>
<Body-indent>
<A ID="pgfId-1045043"></A>
<Bold>
Will match:</Bold>
<code>
 hello! world</code>
</Body-indent>
<Body-indent>
<A ID="pgfId-1045044"></A>
<Bold>
Will not match: </Bold>
<code>
hello world</code>
, <code>
hello; world</code>
</Body-indent>
<Body-bullet>
<A ID="pgfId-1045045"></A>
<Bold>
Example query:</Bold>
 <code>
cts:word-query(&quot;hey! world?&quot;)</code>
</Body-bullet>
<Body-indent>
<A ID="pgfId-1045046"></A>
<Bold>
Actual behavior: </Bold>
Wildcarding on, punctuation sensitive</Body-indent>
<Body-indent>
<A ID="pgfId-1045047"></A>
<Bold>
Will match:</Bold>
 <code>
hey! world?</code>
, <code>
hey! world!</code>
, <code>
hey! worlds</code>
</Body-indent>
<Body-indent>
<A ID="pgfId-1045048"></A>
<Bold>
Will not match:</Bold>
 <code>
hey. world</code>
</Body-indent>
<Heading-5>
<A ID="pgfId-1045049"></A>
<A ID="27972"></A>
Wildcarding Explicitly Off, Punctuation Sensitivity Not Specified</Heading-5>
<Body>
<A ID="pgfId-1051796"></A>
The following examples show the matches for queries that specify <code>
&quot;unwildcarded&quot;</code>
 and do not specify anything about punctuation-sensitivity.</Body>
<Body-bullet>
<A ID="pgfId-1045050"></A>
Example query: <code>
cts:word-query(&quot;hello?world&quot;, &quot;unwildcarded&quot;)</code>
</Body-bullet>
<Body-indent>
<A ID="pgfId-1045051"></A>
<Bold>
Actual behavior:</Bold>
 Wildcarding off, punctuation sensitive</Body-indent>
<Body-indent>
<A ID="pgfId-1045052"></A>
<Bold>
Will match: </Bold>
<code>
hello?world</code>
</Body-indent>
<Body-indent>
<A ID="pgfId-1045053"></A>
<Bold>
Will not match:</Bold>
 <code>
hello world</code>
, <code>
hello;world</code>
</Body-indent>
<Body-bullet>
<A ID="pgfId-1045054"></A>
<Bold>
Example query: </Bold>
<code>
cts:word-query(&quot;hello*world&quot;, &quot;unwildcarded&quot;)</code>
</Body-bullet>
<Body-indent>
<A ID="pgfId-1045055"></A>
<Bold>
Actual behavior: </Bold>
Wildcarding off, punctuation sensitive</Body-indent>
<Body-indent>
<A ID="pgfId-1045056"></A>
<Bold>
Will match: </Bold>
<code>
hello*world</code>
</Body-indent>
<Body-indent>
<A ID="pgfId-1045057"></A>
<Bold>
Will not match:</Bold>
 <code>
helloabcworld</code>
</Body-indent>
<Heading-5>
<A ID="pgfId-1045058"></A>
<A ID="97478"></A>
Wildcarding Not Specified, Punctuation Sensitivity Explicitly On (Wildcard Indexes Enabled)</Heading-5>
<Body>
<A ID="pgfId-1051800"></A>
The following examples show queries that are run when at least one wildcard index is enabled and the <code>
&quot;punctuation-sensitive&quot;</code>
 option is explicitly set on the <code>
cts:word-query</code>
.</Body>
<Body-bullet>
<A ID="pgfId-1045059"></A>
<Bold>
Example query:</Bold>
 <code>
cts:word-query(&quot;hello?world&quot;, &quot;punctuation-sensitive&quot;)</code>
</Body-bullet>
<Body-indent>
<A ID="pgfId-1045060"></A>
<Bold>
Actual behavior: </Bold>
Wildcarding on, punctuation sensitive</Body-indent>
<Body-indent>
<A ID="pgfId-1045061"></A>
<Bold>
Will match:</Bold>
 <code>
hello?world</code>
, <code>
hello.world</code>
, <code>
hello*world</code>
</Body-indent>
<Body-indent>
<A ID="pgfId-1045519"></A>
<Bold>
Will not match:</Bold>
 <code>
hello world</code>
, <code>
hello ! world</code>
</Body-indent>
<Body-bullet>
<A ID="pgfId-1045520"></A>
<Bold>
Example query:</Bold>
 <code>
cts:word-query(&quot;hello * world&quot;, &quot;punctuation-sensitive&quot;)</code>
</Body-bullet>
<Body-indent>
<A ID="pgfId-1045521"></A>
<Bold>
Actual behavior:</Bold>
 Wildcarding on, punctuation sensitive</Body-indent>
<Body-indent>
<A ID="pgfId-1050627"></A>
<Bold>
Will match:</Bold>
 <code>
hello abc world</code>
, <code>
hello ! world</code>
</Body-indent>
<Body-indent>
<A ID="pgfId-1050628"></A>
<Bold>
Will not match:</Bold>
 <code>
hello-!- world</code>
</Body-indent>
<Body-bullet>
<A ID="pgfId-1050629"></A>
<Bold>
Example query: </Bold>
<code>
cts:word-query(&quot;hello? world&quot;, &quot;punctuation-sensitive&quot;)</code>
</Body-bullet>
<Body-indent>
<A ID="pgfId-1045549"></A>
<Bold>
Actual behavior:</Bold>
 Wildcarding on, punctuation sensitive</Body-indent>
<Body-indent>
<A ID="pgfId-1045069"></A>
<Bold>
Will match:</Bold>
 <code>
hello! world</code>
, <code>
(hello) world</code>
 </Body-indent>
<Note>
<A ID="pgfId-1045070"></A>
<code>
(hello) world</code>
 is a match because <code>
?</code>
 matches <code>
)</code>
 and <code>
(</code>
 is not considered part of the word <code>
hello</code>
.</Note>
<Body-indent>
<A ID="pgfId-1051822"></A>
<Bold>
Will not match: </Bold>
<code>
ahello) world</code>
, <code>
hello to world</code>
.</Body-indent>
</XML>
