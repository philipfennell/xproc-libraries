<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="hashtable.css" type="text/css" charset="UTF-8"?>
<XML>
<TITLE> </TITLE><Heading-1>
<A ID="pgfId-1053802"></A>
<A ID="86523"></A>
 Using the map Functions to Create Name-Value Maps</Heading-1>
<pagenum>
<A ID="pgfId-1053806"></A>
133</pagenum>
<Body>
<A ID="pgfId-1049471"></A>
This chapter describes how to use the map functions and includes the following sections:</Body>
<Body-bullet>
<A ID="pgfId-1053734"></A>
<A href="hashtable.xml#id(97268)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Maps: In-Memory Structures to Manipulate in XQuery</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054928"></A>
<A href="hashtable.xml#id(10829)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
map:map XQuery Primitive Type</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1053738"></A>
<A href="hashtable.xml#id(88270)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Serializing a Map to an XML Node</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054047"></A>
<A href="hashtable.xml#id(63114)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Map API</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1059038"></A>
<A href="hashtable.xml#id(71045)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Examples</Hyperlink>
</A></Body-bullet>
<Heading-2>
<A ID="pgfId-1054048"></A>
<A ID="97268"></A>
Maps: In-Memory Structures to Manipulate in XQuery</Heading-2>
<Body>
<A ID="pgfId-1054049"></A>
<Emphasis>
Maps</Emphasis>
 are in-memory structures containing name-value pairs that you can create and manipulate. In some programming languages, maps are implemented using hash tables. Maps are handy programming tools, as you can conveniently store and update name-value pairs for use later in your program. Maps provide a fast and convenient method for accessing data.</Body>
<Body>
<A ID="pgfId-1058758"></A>
MarkLogic Server has a set of XQuery functions to create manipulate maps. Like the <code>
xdmp:set</code>
 function, maps have side-effects and can change within your program. Therefore maps are not strictly functional like most other aspects of XQuery. While the map is in memory, its structure is opaque to the developer, and you access it with the built-in XQuery functions. You can persist the structure of the map as an XML node, however, if you want to save it for later use. A map is a node and therefore has an identity, and the identity remains the same as long as the map is in memory. However, if you serialize the map as XML and store it in a document, when you retrieve it will have a different node identity (that is, comparing the identity of the map and the serialized version of the map would return false). Similarly, if you store XML values retrieved from the database in a map, the node in the in-memory map will have the same identity as the node from the database while the map is in memory, but will have different identities after the map is serialized to an XML document and stored in the database. This is consistent with the way XQuery treats node identity.</Body>
<Body>
<A ID="pgfId-1058808"></A>
The keys take <code>
xs:string</code>
 types, and the values take <code>
item()*</code>
 values. Therefore, you can pass a string, an element, or a sequence of items to the values. Maps are a nice alternative to storing values an in-memory XML node and then using XPath to access the values. Maps makes it very easy to update the values.</Body>
<Heading-2>
<A ID="pgfId-1058809"></A>
<A ID="10829"></A>
map:map XQuery Primitive Type</Heading-2>
<Body>
<A ID="pgfId-1058810"></A>
Maps are defined as a <code>
map:map</code>
 XQuery primitive type. You can use this type in function or variable definitions, or in the same way as you use other primitive types in XQuery. You can also serialize it to XML, which lets you store it in a database, as described in the following section.</Body>
<Heading-2>
<A ID="pgfId-1058815"></A>
<A ID="88270"></A>
Serializing a Map to an XML Node</Heading-2>
<Body>
<A ID="pgfId-1058820"></A>
You can serialize the structure of a map to an XML node by placing the map in the context of an XML element, in much the same way as you can serialize a <code>
cts:query</code>
 (see <A href="../search-dev-guide/cts_query.xml#id(92772)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Serializing a cts:query to XML</Hyperlink>
</A> in the <A href="../search-dev-guide/cts_query.xml#id(51991)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Composing cts:query Expressions</Hyperlink>
</A> chapter of the <Emphasis>
Search Developer's Guide</Emphasis>
). Serializing the map is useful if you want to save the contents of the map by storing it in the database. The XML conforms to the <code>
&lt;</code>
<Emphasis>
marklogic-dir</Emphasis>
<code>
&gt;/Config/map.xsd</code>
 schema, and has the namespace <code>
http://marklogic.com/xdmp/map</code>
.</Body>
<Body>
<A ID="pgfId-1058856"></A>
For example, the following returns the XML serialization of the constructed map:</Body>
<Code>
<A ID="pgfId-1058864"></A>
let $map := map:map()
let $key := map:put($map, &quot;1&quot;, &quot;hello&quot;)
let $key := map:put($map, &quot;2&quot;, &quot;world&quot;)
let $node := &lt;some-element&gt;{$map}&lt;/some-element&gt;
return $node/map:map</Code>
<Body>
<A ID="pgfId-1058907"></A>
The following XML is returned:</Body>
<Code>
<A ID="pgfId-1058879"></A>
&lt;map:map xmlns:map=&quot;http://marklogic.com/xdmp/map&quot;&gt;
  &lt;map:entry&gt;
    &lt;map:key&gt;2&lt;/map:key&gt;
    &lt;map:value xsi:type=&quot;xs:string&quot;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;world&lt;/map:value&gt;
  &lt;/map:entry&gt;
  &lt;map:entry&gt;
    &lt;map:key&gt;1&lt;/map:key&gt;
    &lt;map:value xsi:type=&quot;xs:string&quot;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;hello&lt;/map:value&gt;
  &lt;/map:entry&gt;
&lt;/map:map&gt;</Code>
<Heading-2>
<A ID="pgfId-1058811"></A>
<A ID="63114"></A>
Map API</Heading-2>
<Body>
<A ID="pgfId-1054927"></A>
The map API is quite simple. You can create a map either from scratch with the <code>
map:map</code>
 function or from the XML representation (<code>
map:map</code>
) of the map. The following are the map functions. For the signatures and description of each function, see the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
.</Body>
<Body-bullet>
<A ID="pgfId-1055467"></A>
<code>
map:clear</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055471"></A>
<code>
map:count</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055479"></A>
<code>
map:delete</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055480"></A>
<code>
map:get</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055481"></A>
<code>
map:keys</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055482"></A>
<code>
map:map</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055483"></A>
<code>
map:put</code>
</Body-bullet>
<Heading-2>
<A ID="pgfId-1055455"></A>
<A ID="71045"></A>
Examples</Heading-2>
<Body>
<A ID="pgfId-1054842"></A>
This section includes example code that uses maps and includes the following examples:</Body>
<Body-bullet>
<A ID="pgfId-1058993"></A>
<A href="hashtable.xml#id(61683)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Creating a Simple Map</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1059170"></A>
<A href="hashtable.xml#id(67981)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Returning the Values in a Map</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1059008"></A>
<A href="hashtable.xml#id(88528)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Constructing a Serialized Map</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1059306"></A>
<A href="hashtable.xml#id(32942)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Add a Value that is a Sequence</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1058989"></A>
<A ID="61683"></A>
Creating a Simple Map</Heading-3>
<Body>
<A ID="pgfId-1058988"></A>
The following example creates a map, puts two key-value pairs into the map, and then returns the map.</Body>
<Code>
<A ID="pgfId-1058969"></A>
let $map := map:map()
let $key := map:put($map, &quot;1&quot;, &quot;hello&quot;)
let $key := map:put($map, &quot;2&quot;, &quot;world&quot;)
return $map</Code>
<Body>
<A ID="pgfId-1058963"></A>
This returns a map with two key-value pairs in it: the key '1' has a value 'hello', and the key '2' has a value 'world'.</Body>
<Heading-3>
<A ID="pgfId-1058977"></A>
<A ID="67981"></A>
Returning the Values in a Map</Heading-3>
<Body>
<A ID="pgfId-1059140"></A>
The following example greates a map, then returns its values ordering by the keys:</Body>
<Code>
<A ID="pgfId-1059147"></A>
let $map := map:map()
let $key := map:put($map, &quot;1&quot;, &quot;hello&quot;)
let $key := map:put($map, &quot;2&quot;, &quot;world&quot;)
return 
  for $x in map:keys($map) 
  order by $x return
  map:get($map, $x)
(: returns hello world :)</Code>
<Heading-3>
<A ID="pgfId-1059139"></A>
<A ID="88528"></A>
Constructing a Serialized Map</Heading-3>
<Body>
<A ID="pgfId-1058978"></A>
The following example creates a map like the previous examples, and then serializes the map to an XML node. It then makes a new map out of the XML node and puts another key-value pair in the map, and finally returns the new map.</Body>
<Code>
<A ID="pgfId-1058944"></A>
let $map := map:map()
let $key := map:put($map, &quot;1&quot;, &quot;hello&quot;)
let $key := map:put($map, &quot;2&quot;, &quot;world&quot;)
let $node := &lt;some-element&gt;{$map}&lt;/some-element&gt;
let $map2 := map:map($node/map:map)
let $key := map:put($map2, &quot;3&quot;, &quot;fair&quot;)
return $map2</Code>
<Body>
<A ID="pgfId-1058959"></A>
This returns a map with three key-value pairs in it: the key '1' has a value 'hello', the key '2' has a value 'world', and the key '3' has a value 'fair'. Note that the map bound to the <code>
$map</code>
 variable is not the same as the map bound to <code>
$map2</code>
. After it was serialized to XML, a new map was constructed in the <code>
$map2</code>
 variable.</Body>
<Heading-3>
<A ID="pgfId-1059265"></A>
<A ID="32942"></A>
Add a Value that is a Sequence</Heading-3>
<Body>
<A ID="pgfId-1059228"></A>
The values that you can put in a map are typed as an <code>
item()*</code>
, which means you can add arbitrary sequences as the value for a key. The following example includes some string values and a sequence value, and then outputs each results in a <code>
&lt;result&gt;</code>
 element:</Body>
<Code>
<A ID="pgfId-1059283"></A>
let $map := map:map()
let $key := map:put($map, &quot;1&quot;, &quot;hello&quot;)
let $key := map:put($map, &quot;2&quot;, &quot;world&quot;)
let $seq := (&quot;fair&quot;, 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;some-xml&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;another-tag&gt;with text&lt;/another-tag&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;/some-xml&gt;)
let $key := map:put($map, &quot;3&quot;, $seq)
return 
  for $x in map:keys($map) return
  &lt;result&gt;{map:get($map, $x)}&lt;/result&gt;</Code>
<Body>
<A ID="pgfId-1059295"></A>
This returns the following elements:</Body>
<Code>
<A ID="pgfId-1059301"></A>
&lt;result&gt;fair
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;some-xml&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;another-tag&gt;with text&lt;/another-tag&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;/some-xml&gt;
&lt;/result&gt;
&lt;result&gt;world&lt;/result&gt;
&lt;result&gt;hello&lt;/result&gt;</Code>
</XML>
