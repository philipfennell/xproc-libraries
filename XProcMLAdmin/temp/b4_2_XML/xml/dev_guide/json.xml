<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="json.css" type="text/css" charset="UTF-8"?>
<XML>
<TITLE> </TITLE><Heading-1>
<A ID="pgfId-1053802"></A>
<A ID="54271"></A>
JSON: Serializing To and Parsing From</Heading-1>
<pagenum>
<A ID="pgfId-1060423"></A>
163</pagenum>
<Body>
<A ID="pgfId-1060424"></A>
This chapter describes how to use the JSON XQuery functions to parse JSON objects to XQuery and serialize XQuery types and values to JSON, and includes the following sections:</Body>
<Body-bullet>
<A ID="pgfId-1053734"></A>
<A href="json.xml#id(57468)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Serializing and Parsing JSON To and From XQuery Types</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054928"></A>
<A href="json.xml#id(82902)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
JSON API</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1060481"></A>
<A href="json.xml#id(26560)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
JSON Parsing Restrictions</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1053738"></A>
<A href="json.xml#id(64449)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Examples</Hyperlink>
</A></Body-bullet>
<Heading-2>
<A ID="pgfId-1054048"></A>
<A ID="57468"></A>
Serializing and Parsing JSON To and From XQuery Types</Heading-2>
<Body>
<A ID="pgfId-1059732"></A>
JSON (JavaScript Object Notation) is a data-interchange format which is designed to pass data to and from JavaScript. It is very useful in a web application to pass data back and forth between XQuery and JavaScript, and JSON is a popular mechanism for such data interchange. You could also use JSON to interchange data between XQuery and other programming environments. JSON is designed so it is both machine- and human-readable. For more details about JSON, see <Hyperlink>
<A href="http://www.json.org" xml:link="simple" show="replace" actuate="user" CLASS="URL">json.org</A></Hyperlink>
.</Body>
<Body>
<A ID="pgfId-1059774"></A>
To facilitate data-interchange, MarkLogic Server includes the JSON built-in XQuery functions. These functions allow you to easily take XQuery items and create JSON representations of them, and to take a JSON string and create XQuery items from it.</Body>
<Body>
<A ID="pgfId-1059825"></A>
Most XQuery types are serialized to JSON in a way that they can be round-tripped (serialized to JSON and parsed from JSON back into a series of items in the XQuery data model) without any loss, but some types will not round-trip without loss. For example, an <code>
xs:dateTime</code>
 value will serialize to a JSON string, but that same string would have to be cast back into an <code>
xs:dateTime</code>
 value in XQuery in order for it to be equivalent to its original. </Body>
<Heading-2>
<A ID="pgfId-1058811"></A>
<A ID="82902"></A>
JSON API</Heading-2>
<Body>
<A ID="pgfId-1054927"></A>
There are two JSON API functions: one to serialize XQuery to JSON, and one to read a JSON string and create an XQuery data model from that string.</Body>
<Body-bullet>
<A ID="pgfId-1055467"></A>
<code>
xdmp:to-json</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055471"></A>
<code>
xdmp:from-json</code>
</Body-bullet>
<Body>
<A ID="pgfId-1059623"></A>
For the signatures and description of each function, see the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
.</Body>
<Heading-2>
<A ID="pgfId-1060429"></A>
<A ID="26560"></A>
JSON Parsing Restrictions</Heading-2>
<Body>
<A ID="pgfId-1060443"></A>
There is not a one-to-one mapping between everything in JSON and everything in XQuery. Note the following when converting objects back and forth between XQuery and JSON:</Body>
<Body-bullet>
<A ID="pgfId-1060450"></A>
JSON null values are mapped to an empty string in XQuery (there is no null value in XQuery).</Body-bullet>
<Body-bullet>
<A ID="pgfId-1060460"></A>
You can have codepoints in JSON that are not legal in XQuery, such as the codepoint for the codepoint 1 (<code>
\u0001</code>
). If you have illegal codepoints, <code>
xdmp:from-json</code>
 will throw an exception.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1060474"></A>
You cannot have sequences of sequences in XQuery, and attempting to parse a JSON string that has an array of arrays will flatten the arrays into a single sequence.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1060535"></A>
Any XML in a JSON string is parsed as text. If you have XML in a JSON string, you will have to use <code>
xdmp:unquote</code>
 in XQuery to turn it into XML. Additionally, there is an XQuery library on the MarkLogic developer site that might help with JSON to XML conversions (<Hyperlink>
<A href="http://developer.marklogic.com/svn/commons/trunk/json/json.xqy" xml:link="simple" show="replace" actuate="user" CLASS="URL">http://developer.marklogic.com/svn/commons/trunk/json/json.xqy</A></Hyperlink>
).</Body-bullet>
<Heading-2>
<A ID="pgfId-1059617"></A>
<A ID="64449"></A>
Examples</Heading-2>
<Body>
<A ID="pgfId-1059618"></A>
This section includes example code that use the JSON functions and includes the following examples:</Body>
<Body-bullet>
<A ID="pgfId-1058993"></A>
<A href="json.xml#id(34739)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Serializing to a JSON String</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1059170"></A>
<A href="json.xml#id(49893)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Parsing a JSON String into a List of Items</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1058989"></A>
<A ID="34739"></A>
Serializing to a JSON String</Heading-3>
<Body>
<A ID="pgfId-1058988"></A>
The following code returns a JSON string that includes a map, a string, and an integer.</Body>
<Code>
<A ID="pgfId-1059873"></A>
let $map := map:map()
let $put := map:put($map, &quot;some-key&quot;, 45683)
let $string := &quot;this is a string&quot;
let $int := 123
return
xdmp:to-json(($map, $string, $int))

(: 
returns:
[{&quot;some-key&quot;:45683}, &quot;this is a string&quot;, 123]
:)</Code>
<Body>
<A ID="pgfId-1058963"></A>
For details on maps, see <A href="hashtable.xml#id(86523)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Using the map Functions to Create Name-Value Maps' on page&#160;130</A>.</Body>
<Heading-3>
<A ID="pgfId-1059706"></A>
<A ID="49893"></A>
Parsing a JSON String into a List of Items</Heading-3>
<Body>
<A ID="pgfId-1059707"></A>
Consider the following, which is the inverse of the previous example:</Body>
<Code>
<A ID="pgfId-1059980"></A>
let $json := 
  '[{&quot;some-key&quot;:45683}, &quot;this is a string&quot;, 123]'
return
xdmp:from-json($json)</Code>
<Body>
<A ID="pgfId-1059709"></A>
This returns the following items:</Body>
<Code>
<A ID="pgfId-1060036"></A>
map:map(
&#160;&lt;map:map xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
&#160;&#160;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
&#160;&#160;xmlns:map=&quot;http://marklogic.com/xdmp/map&quot;&gt;
&#160;&#160;&lt;map:entry key=&quot;some-key&quot;&gt;
&#160;&#160;&#160;&#160;&lt;map:value xsi:type=&quot;xs:integer&quot;&gt;45683&lt;/map:value&gt;
&#160;&#160;&lt;/map:entry&gt;
&#160;&lt;/map:map&gt;)
this is a string
123</Code>
<Body>
<A ID="pgfId-1060025"></A>
Note that what is shown above is the serialization of the XQuery items. You can also use some or all of the items in the XQuery data model. For example, consider the following, which adds to the map based on the other values:</Body>
<Code>
<A ID="pgfId-1060125"></A>
xquery version &quot;1.0-ml&quot;;
let $json := 
  '[{&quot;some-key&quot;:45683}, &quot;this is a string&quot;, 123]'
let $items := xdmp:from-json($json)
let $put := map:put($items[1], xs:string($items[3]), $items[2]) 
return
$items[1]

(: returns the following map:
map:map(
&#160;&lt;map:map xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
&#160;&#160;&#160;&#160;&#160;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
&#160;&#160;&#160;&#160;&#160;xmlns:map=&quot;http://marklogic.com/xdmp/map&quot;&gt;
&#160;&#160;&#160;&#160;&lt;map:entry key=&quot;123&quot;&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;map:value xsi:type=&quot;xs:string&quot;&gt;this is a string&lt;/map:value&gt;
&#160;&#160;&#160;&#160;&lt;/map:entry&gt;
&#160;&#160;&#160;&#160;&lt;map:entry key=&quot;some-key&quot;&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;map:value xsi:type=&quot;xs:integer&quot;&gt;45683&lt;/map:value&gt;
&#160;&#160;&#160;&#160;&lt;/map:entry&gt;
&#160;&lt;/map:map&gt;)
:)</Code>
<Body>
<A ID="pgfId-1060292"></A>
In the above query, the first item (<code>
$items[1]</code>
) returned from the <code>
xdmp:from-json</code>
 call is a map, and the map is then modified, and then the modified map is returned. For details on maps, see <A href="hashtable.xml#id(86523)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Using the map Functions to Create Name-Value Maps' on page&#160;130</A>.</Body>
</XML>
