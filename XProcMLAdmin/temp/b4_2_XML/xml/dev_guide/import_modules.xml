<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="import_modules.css" type="text/css" charset="UTF-8"?>
<XML>
<TITLE> </TITLE><Heading-1>
<A ID="pgfId-1053802"></A>
<A ID="68169"></A>
Importing XQuery Modules, XSLT Stylesheets, and Resolving Paths</Heading-1>
<pagenum>
<A ID="pgfId-1053806"></A>
63</pagenum>
<Body>
<A ID="pgfId-1049471"></A>
You can import XQuery modules from other XQuery modules in MarkLogic Server. Similarly, you can import XSLT stylesheets into other stylesheets, you can import XQuery modules into XSLT styleshhets, and you can import XSLT stylesheets into XQuery modules. This chapter describes the two types of XQuery modules and specifies the rules for importing modules and resolving URI references. It includes the following sections:</Body>
<Body-bullet>
<A ID="pgfId-1053734"></A>
<A href="import_modules.xml#id(45509)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
XQuery Library Modules and Main Modules</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1053738"></A>
<A href="import_modules.xml#id(29407)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Rules for Resolving Import, Invoke, and Spawn Paths</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1053739"></A>
<A href="import_modules.xml#id(60423)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Example Import Module Scenario</Hyperlink>
</A></Body-bullet>
<Body>
<A ID="pgfId-1059038"></A>
For details on importing XQuery library modules into XSLT stylesheets and vice-versa, see <A href="../xquery/xslt.xml#id(95467)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Notes on Importing Stylesheets With &lt;xsl:import&gt;</Hyperlink>
</A> and <A href="../xquery/enhanced.xml#id(56907)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Importing a Stylesheet Into an XQuery Module</Hyperlink>
</A> in the <Emphasis>
XQuery and XSLT Reference Guide</Emphasis>
.</Body>
<Heading-2>
<A ID="pgfId-1053740"></A>
<A ID="45509"></A>
XQuery Library Modules and Main Modules</Heading-2>
<Body>
<A ID="pgfId-1053759"></A>
There are two types of XQuery modules (as defined in the XQuery specification, <Hyperlink>
<A href="http://www.w3.org/TR/xquery/#id-query-prolog" xml:link="simple" show="replace" actuate="user" CLASS="URL">http://www.w3.org/TR/xquer//#id-query-prolog</A></Hyperlink>
): </Body>
<Body-bullet>
<A ID="pgfId-1054669"></A>
<A href="import_modules.xml#id(57090)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Main Modules</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054673"></A>
<A href="import_modules.xml#id(26329)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Library Modules</Hyperlink>
</A></Body-bullet>
<Body>
<A ID="pgfId-1058541"></A>
For more details about the XQuery language, see the <Emphasis>
XQuery and XSLT Reference Guide</Emphasis>
.</Body>
<Heading-3>
<A ID="pgfId-1054674"></A>
<A ID="57090"></A>
Main Modules</Heading-3>
<Body>
<A ID="pgfId-1054678"></A>
A main module can be executed as an XQuery program, and must include a query body consisting of an XQuery expression (which in turn can contain other XQuery expressions, and so on). The following is a simple example of a main module:</Body>
<Code>
<A ID="pgfId-1054752"></A>
&quot;hello world&quot;</Code>
<Body>
<A ID="pgfId-1054761"></A>
Main modules can have prologs, but the prolog is optional. As part of a prolog, a main module can have function definitions. Function definitions in a main module, however, are only available to that module; they cannot be imported to another module.</Body>
<Heading-3>
<A ID="pgfId-1054681"></A>
<A ID="26329"></A>
Library Modules</Heading-3>
<Body>
<A ID="pgfId-1054679"></A>
A library module has a namespace and is used to define functions. Library modules cannot be evaluated directly; they are imported, either from other library modules or from main modules with an <code>
import</code>
 statement. The following is a simple example of a library module:</Body>
<Code>
<A ID="pgfId-1054756"></A>
xquery version &quot;1.0-ml&quot;;
module namespace hello = &quot;helloworld&quot;;

declare function helloworld()
{
&#160;&#160;&quot;hello world&quot;
};</Code>
<Body>
<A ID="pgfId-1054779"></A>
If you save this module to a file named <code>
c:/code/helloworld.xqy</code>
, and you have an App Server with filesystem root <code>
c:/code</code>
, you can import this in either a main module or a library module and call the function as follows:</Body>
<Code>
<A ID="pgfId-1054818"></A>
xquery version &quot;1.0-ml&quot;;
import module namespace hw=&quot;helloworld&quot; at &quot;/helloworld.xqy&quot;;

hw:helloworld()</Code>
<Body>
<A ID="pgfId-1054819"></A>
This XQuery program will import the library module with the <code>
helloworld</code>
 namespace and then evaluate its <code>
helloworld()</code>
 function.</Body>
<Heading-2>
<A ID="pgfId-1053924"></A>
<A ID="29407"></A>
Rules for Resolving Import, Invoke, and Spawn Paths</Heading-2>
<Body>
<A ID="pgfId-1054559"></A>
In order to call a function that resides in an XQuery library module, you need to import the module with its namespace. MarkLogic Server resolves the library paths similar to the way other HTTP and application servers resolve their paths. Similarly, if you use <code>
xdmp:invoke</code>
 or <code>
xdmp:spawn</code>
 to run a module, you specify access to the module with a path. These rules also apply to the path to an XSLT stylesheet when using <code>
xdmp:xslt-invoke</code>
, as well as to stylesheet imports in the <code>
&lt;xsl:import&gt;</code>
 instruction.</Body>
<Body>
<A ID="pgfId-1054695"></A>
The XQuery module that is imported/invoked/spawned can reside in any of the following places:</Body>
<Body-bullet>
<A ID="pgfId-1055123"></A>
In the Modules directory.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055127"></A>
In a directory relative to the calling module.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055128"></A>
Under the App Server root, which is either the specified directory in the Modules database (when the App Server is set to a Modules database) or the specified directory on the filesystem (when the App Server is set to find modules in the filesystem). </Body-bullet>
<Body>
<A ID="pgfId-1055122"></A>
The paths in <code>
import</code>
/<code>
invoke</code>
/<code>
spawn</code>
 expressions are resolved as follows: </Body>
<Number1>
<A ID="pgfId-1054560"></A>
When an <code>
import</code>
/<code>
invoke</code>
/<code>
spawn</code>
 path starts with a leading slash, first look under the Modules directory (on Windows, typically <code>
c:\Program Files\MarkLogic\Modules</code>
). For example: </Number1>
<Code>
<A ID="pgfId-1054539"></A>
import module &quot;foo&quot; at &quot;/foo.xqy&quot;; </Code>
<Body-indent>
<A ID="pgfId-1054540"></A>
In this case, it would look for the module file with a namespace <code>
foo</code>
 in <code>
c:\Program&#160;Files\MarkLogic\Modules\foo.xqy</code>
.</Body-indent>
<NumberList>
<Number>
<A ID="pgfId-1054191"></A>
If the import/invoke/spawn path starts with a slash, and it is not found under the Modules directory, then start at the App Server root. For example, if the App Server root is <code>
/home/mydocs/</code>
, then the following import:</Number>
</NumberList>
<Code>
<A ID="pgfId-1054451"></A>
import module &quot;foo&quot; at &quot;/foo.xqy&quot;; </Code>
<Body-indent>
<A ID="pgfId-1055035"></A>
will look for a module with namespace <code>
foo</code>
 in <code>
/home/mydocs/foo.xqy</code>
. </Body-indent>
<Body-indent>
<A ID="pgfId-1055053"></A>
Note that you start at the App Server root, both for filesystem roots and Modules database roots. For example, in an App Server configured with a modules database and a root of <code>
http://foo/</code>
:</Body-indent>
<Code>
<A ID="pgfId-1055036"></A>
import module &quot;foo&quot; at &quot;/foo.xqy&quot;;</Code>
<Body-indent>
<A ID="pgfId-1055037"></A>
will look for a module with namespace <code>
foo</code>
 in the modules database with a URI <code>
http://foo/foo.xqy</code>
 (resolved by appending the App Server root to <code>
foo.xqy</code>
).</Body-indent>
<NumberList>
<Number>
<A ID="pgfId-1054497"></A>
If the import/invoke/spawn path does not start with a slash, look relative to the location of the module that called the function. For example, if a module at <code>
/home/mydocs/bar.xqy</code>
 has the following import: </Number>
</NumberList>
<Code>
<A ID="pgfId-1054498"></A>
import module &quot;foo&quot; at &quot;foo.xqy&quot;; </Code>
<Body-indent>
<A ID="pgfId-1054583"></A>
it will look for the module with namespace <code>
foo</code>
 at <code>
/home/mydocs/foo.xqy</code>
.</Body-indent>
<Body-indent>
<A ID="pgfId-1054929"></A>
Note that you start at the calling module location, both for App Servers configured to use the filesystem and for App Servers configured to use modules databases. For example, a module with a URI of <code>
http://foo/bar.xqy</code>
 that resides in the modules database and has the following <code>
import</code>
 statement:</Body-indent>
<Code>
<A ID="pgfId-1054980"></A>
import module &quot;foo&quot; at &quot;foo.xqy&quot;; </Code>
<Body-indent>
<A ID="pgfId-1054978"></A>
will look for the module with the URI <code>
http://foo/foo.xqy</code>
 in the modules database.</Body-indent>
<NumberList>
<Number>
<A ID="pgfId-1054973"></A>
If the import/invoke/spawn path contains a scheme or network location, then the server throws an exception. For example:</Number>
</NumberList>
<Code>
<A ID="pgfId-1054930"></A>
import module &quot;foo&quot; at &quot;http://foo/foo.xqy&quot;; </Code>
<Body-indent>
<A ID="pgfId-1054931"></A>
will throw an invalid path exception. Similarly:</Body-indent>
<Code>
<A ID="pgfId-1054964"></A>
import module &quot;foo&quot; at &quot;c:/foo/foo.xqy&quot;; </Code>
<Body-indent>
<A ID="pgfId-1054962"></A>
will throw an invalid path exception.</Body-indent>
<Heading-2>
<A ID="pgfId-1054143"></A>
<A ID="60423"></A>
Example Import Module Scenario</Heading-2>
<Body>
<A ID="pgfId-1054151"></A>
Consider the following scenario: </Body>
<Body-bullet>
<A ID="pgfId-1054152"></A>
There is an HTTP server with a root defined as <code>
c:/mydir</code>
.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1054153"></A>
In a file called <code>
c:/mydir/lib.xqy</code>
, there is a library module with the function to import. The contents of the library module are as follows: </Body-bullet>
<Code>
<A ID="pgfId-1054154"></A>
xquery version &quot;1.0-ml&quot;;
module namespace hw=&quot;http://marklogic.com/me/my-module&quot;; 

declare function hello()
{
&quot;hello&quot;
}; </Code>
<Body-bullet>
<A ID="pgfId-1054156"></A>
In a file called <code>
c:/mydir/main.xqy</code>
, there is an XQuery main module that imports a function from the above library module. This code is as follows: </Body-bullet>
<Code>
<A ID="pgfId-1054157"></A>
xquery version &quot;1.0-ml&quot;;

declare namespace my=&quot;http://marklogic.com/me/my-module&quot;;
import module &quot;http://marklogic.com/me/my-module&quot; at &quot;lib.xqy&quot;; 

my:hello() </Code>
<Body>
<A ID="pgfId-1054160"></A>
The library module <code>
lib.xqy</code>
 is imported relative to the App Server root (in this case, relative to <code>
c:/mydir</code>
).</Body>
</XML>
