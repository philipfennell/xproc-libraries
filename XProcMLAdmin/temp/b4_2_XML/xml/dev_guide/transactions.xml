<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="transactions.css" type="text/css" charset="UTF-8"?>
<XML>
<TITLE> </TITLE><Heading-1>
<A ID="pgfId-1053802"></A>
<A ID="44680"></A>
 Understanding Transactions in MarkLogic Server</Heading-1>
<pagenum>
<A ID="pgfId-1053806"></A>
22</pagenum>
<Body>
<A ID="pgfId-1049471"></A>
MarkLogic Server is a transactional system that ensures data integrity. This chapter describes the transaction model of MarkLogic Server, and includes the following sections:</Body>
<Body-bullet>
<A ID="pgfId-1053734"></A>
<A href="transactions.xml#id(66655)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Overview of Terminology</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1053738"></A>
<A href="transactions.xml#id(84472)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
System Timestamps and Fragment Versioning</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054047"></A>
<A href="transactions.xml#id(25761)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Query and Update Statements</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1056245"></A>
<A href="transactions.xml#id(84941)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Semi-Colon as a Transactional Separator</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1056250"></A>
<A href="transactions.xml#id(83837)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Interactions with xdmp:eval/invoke</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1057147"></A>
<A href="transactions.xml#id(87191)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Functions With Non-Transactional Side Effects</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1056254"></A>
<A href="transactions.xml#id(33250)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Example: Incrementing the System Timestamp</Hyperlink>
</A></Body-bullet>
<Heading-2>
<A ID="pgfId-1054750"></A>
<A ID="66655"></A>
Overview of Terminology</Heading-2>
<Body>
<A ID="pgfId-1054049"></A>
Although transactions are a core feature of most database systems, various systems support subtly different transactional semantics. Clearly defined terminology is key to a proper and comprehensive understanding of these semantics. To avoid confusion over the meaning of any of these terms, this section provides definitions for several terms used throughout this chapter and throughout the MarkLogic Server documentation. The definitions of the terms also provide a useful starting point for describing transactions in MarkLogic Server.</Body>
<Body-bullet>
<A ID="pgfId-1054761"></A>
system timestamp</Body-bullet>
<Body-indent>
<A ID="pgfId-1054588"></A>
The <Emphasis>
system timestamp</Emphasis>
 is a number maintained by MarkLogic Server that increments by 1 every time a change or a set of changes occurs in any of the databases in a system (including configuration changes from any host in a cluster). Each fragment stored in a database has system timestamps associated with it to determine the range of timestamps during which the fragment is valid.</Body-indent>
<Body-bullet>
<A ID="pgfId-1054486"></A>
statement</Body-bullet>
<Body-indent>
<A ID="pgfId-1054601"></A>
A <Emphasis>
statement</Emphasis>
 is a unit of XQuery code to be evaluated by MarkLogic Server.</Body-indent>
<Body-bullet>
<A ID="pgfId-1054487"></A>
transaction</Body-bullet>
<Body-indent>
<A ID="pgfId-1054605"></A>
A <Emphasis>
transaction</Emphasis>
 is a set of statements which either all fail or all succeed.</Body-indent>
<Body-bullet>
<A ID="pgfId-1054676"></A>
program</Body-bullet>
<Body-indent>
<A ID="pgfId-1054677"></A>
A <Emphasis>
program</Emphasis>
 is the expanded version of some XQuery code that is submitted to MarkLogic Server for evaluation, such as a query expression in a <code>
.xqy</code>
 file or XQuery code submitted in an <code>
xdmp:eval</code>
 statement. The program consists not only of the code in the calling module, but also any imported modules that are called from the calling module, and any modules they might call, and so on. </Body-indent>
<Body-bullet>
<A ID="pgfId-1054537"></A>
request</Body-bullet>
<Body-indent>
<A ID="pgfId-1056521"></A>
A <Emphasis>
request</Emphasis>
 is any invocation of a program, whether through an App Server, through a task server, through <code>
xdmp:eval</code>
, or through any other means. In addition, certain client calls to App Servers (for example, loading an XML document through XCC, downloading an image through HTTP, or locking a document through WebDAV) are also requests. </Body-indent>
<Body-bullet>
<A ID="pgfId-1054488"></A>
query statement</Body-bullet>
<Body-indent>
<A ID="pgfId-1054617"></A>
A <Emphasis>
query statement</Emphasis>
 is a statement that contains no update calls. The existence of any update calls is determined statically through lexical analysis prior to beginning the statement evaluation. Query statements run at a particular system timestamp, and have a read-consistent view of the database.</Body-indent>
<Body-bullet>
<A ID="pgfId-1054489"></A>
update statement</Body-bullet>
<Body-indent>
<A ID="pgfId-1054646"></A>
An <Emphasis>
update statement</Emphasis>
 is a statement that contains the potential to perform updates (that is, it contains one or more update calls). The existence of any update calls is determined statically through lexical analysis prior to beginning the statement evaluation. Consequently, a statement may be categorized as an update statement regardless of whether the statement actually performs any updates. Update statements run with readers/writers locks, obtaining locks as needed for documents accessed in the statement.</Body-indent>
<Body-bullet>
<A ID="pgfId-1054665"></A>
readers/writers locks</Body-bullet>
<Body-indent>
<A ID="pgfId-1054638"></A>
During update statements, MarkLogic Server uses <Emphasis>
readers/writers locks</Emphasis>
, which are a set of read and write locks that lock documents for reading and update only when the documents are accessed, not at the beginning of a transaction. Because update statements only obtain locks as they are needed, update statements might see a newer version of a document than the time when the update statement began. The view will be still be consistent for any given document from the time the document is locked. Once a document is locked, any update statements in other transactions will have to wait for the lock to be released before reading or updating the document. For more details, see <A href="transactions.xml#id(41520)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Update Statements--Readers/Writers Locks' on page&#160;15</A>.</Body-indent>
<Heading-2>
<A ID="pgfId-1055487"></A>
<A ID="84472"></A>
System Timestamps and Fragment Versioning</Heading-2>
<Body>
<A ID="pgfId-1056566"></A>
To understand how transactions work in MarkLogic Server, it is important to understand something about how documents are stored. Documents are made up of one or more fragments. After a document is created, each of its fragments are stored in one or more stands. The stands are part of a forest, and the forest is part of a database. A database contains one or more forests.</Body>
<Body>
<A ID="pgfId-1056571"></A>
Each fragment in a stand has system timestamps associated with it, which correspond to the range of system timestamps in which that version of the fragment is valid. When a document is updated, the update process creates new versions of any fragments that are changed. The new versions of the fragments are stored in a new stand and have a new set of valid system timestamps associated with them. Eventually, the system merges the old and new stands together and creates a new stand with only the latest versions of the fragments. Point-in-time queries will also effect which versions of fragments are stored and preserved during a merge. After the merge, the old stands are deleted.</Body>
<Body>
<A ID="pgfId-1055463"></A>
The range of valid system timestamps associated with fragments are used when a statement determines which version of a document to use during a transaction. The next section describes how query statements and update statements work. For more details about how merges work, see the 'Understanding and Controlling Database Merges' chapter of the <Emphasis>
Administrator's Guide</Emphasis>
. For more details on how point-in-time queries effect which versions of documents are stored, see <A href="point_in_time.xml#id(65723)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Point-In-Time Queries' on page&#160;112</A>. For an example of how system timestamps change as updates occur to the system, see <A href="transactions.xml#id(33250)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Example: Incrementing the System Timestamp' on page&#160;22</A>.</Body>
<Heading-2>
<A ID="pgfId-1055389"></A>
<A ID="25761"></A>
Query and Update Statements</Heading-2>
<Body>
<A ID="pgfId-1054911"></A>
As defined in the previous section, a statement in MarkLogic Server is either a <Emphasis>
query statement</Emphasis>
 or an <Emphasis>
update statement</Emphasis>
. To ensure maximum concurrency and minimum contention for resources, query statements and update statements are optimized differently. Query statements are read-only and never obtain any locks on documents. Update statements must ensure transactional integrity and obtain locks on documents. This section describes the semantics of these two types of statements and includes the following parts:</Body>
<Body-bullet>
<A ID="pgfId-1054926"></A>
<A href="transactions.xml#id(87276)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Query Statements</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054948"></A>
<A href="transactions.xml#id(41520)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Update Statements--Readers/Writers Locks</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054949"></A>
<A href="transactions.xml#id(53869)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Example Scenario</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1054910"></A>
<A ID="87276"></A>
Query Statements</Heading-3>
<Body>
<A ID="pgfId-1053759"></A>
If there are no updates found in a statement during lexical analysis, then the statement is a query statement. This section describes query statements and has the following parts:</Body>
<Body-bullet>
<A ID="pgfId-1054794"></A>
<A href="transactions.xml#id(21322)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Queries Run at a Timestamp (No Locks)</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054798"></A>
<A href="transactions.xml#id(23994)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Queries See Latest Version of Documents Up To Timestamp of Query</Hyperlink>
</A></Body-bullet>
<Heading-4>
<A ID="pgfId-1054799"></A>
<A ID="21322"></A>
Queries Run at a Timestamp (No Locks)</Heading-4>
<Body>
<A ID="pgfId-1054904"></A>
Query statements run at the system timestamp corresponding to the time in which the query statement initiates. Calls to <code>
xdmp:request-timestamp</code>
 will return the same system timestamp at any point during a query statement; they will not return the empty sequence. Query statements do not obtain locks on any documents, so other transactions can read or update the document while the query is executing.</Body>
<Heading-4>
<A ID="pgfId-1054907"></A>
<A ID="23994"></A>
Queries See Latest Version of Documents Up To Timestamp of Query</Heading-4>
<Body>
<A ID="pgfId-1054821"></A>
At the beginning of a query statement evaluation, MarkLogic Server gets the current system timestamp (the number returned when calling the <code>
xdmp:request-timestamp</code>
 function) and uses only the latest versions of documents whose timestamp is less than or equal to that number. Even if any of the documents that the query is accessing are updated or deleted while the query is being executed, the use of timestamps ensures that a query statement always sees a consistent view of the documents it accesses. </Body>
<Heading-3>
<A ID="pgfId-1054813"></A>
<A ID="41520"></A>
Update Statements--Readers/Writers Locks</Heading-3>
<Body>
<A ID="pgfId-1055630"></A>
If the potential for updates is found in a statement during lexical analysis, then the statement is an update statement. Depending on the specific logic of the statement, an update statement might not actually end up updating anything, but a statement that is determined (during lexical analysis) to be an update statement is run as an update statement, not a query statement. </Body>
<Body>
<A ID="pgfId-1054881"></A>
Update statements run with readers/writers locks, not at a timestamp like query statements. Because update statements do not run at a set timestamp, they see the latest view of any given document at the time it is first accessed by the statement. Because an update statement must successfully obtain locks on all documents it reads or writes in order to complete evaluation, there is no chance that a given update statement will see 'half' or 'some' of the updates made by some other transactions; the statement is indeed transactional.</Body>
<Body>
<A ID="pgfId-1054380"></A>
Calls to <code>
xdmp:request-timestamp</code>
 will always return the empty sequence during an update statement; that is, if <code>
xdmp:request-timestamp</code>
 returns a value, the statement is a query statement, not an update statement. </Body>
<Body>
<A ID="pgfId-1055659"></A>
During the update statement evaluation, any updates the statement performs are not visible to itself or to other transactions. The updates only become visible once the transaction commits, which occurs automatically when the statement completes. If you want a transaction to use a newly-updated document, you must separate that transaction into two transactions, first updating the document in one transaction and then accessing the new version in a subsequent transaction. </Body>
<Body>
<A ID="pgfId-1061492"></A>
An update statement cannot perform an update to the same document that will conflict with other updates occurring in the same statement (for example, you cannot update a node and add a child element to that node in the same statement). Any attempts to perform such conflicting updates to the same document in a single update statement will fail with an <code>
XDMP-CONFLICTINGUPDATES</code>
 exception.</Body>
<Heading-3>
<A ID="pgfId-1053924"></A>
<A ID="53869"></A>
Example Scenario</Heading-3>
<Body>
<A ID="pgfId-1054954"></A>
The following figure shows three different transactions, T1, T2, and T3, and how the transactional semantics work for each one:</Body>
<Body>
<A ID="pgfId-1055294"></A>
<IMAGE xml:link="simple" href="transactions-1.gif" show="embed" actuate="auto"/>
</Body>
<Body>
<A ID="pgfId-1055297"></A>
Assume T1 is a long-running update transaction which starts when the system is at timestamp 10 and ends up committing at timestamp 40 (meaning there were 30 updates or other changes to the system while this update statement runs). When T2 reads the document being updated by T1 (<code>
doc.xml</code>
), it sees the latest version that has a system timestamp of 20 or less, which turns out to be the same version T1 uses before its update. When T3 tries to update the document, it finds that T1 has readers/writers locks on it, so it waits for them to be released. After T1 commits and releases the locks, then T3 sees the newly updated version of the document, and performs its update which is committed at a new timestamp of 41.</Body>
<Heading-2>
<A ID="pgfId-1055506"></A>
<A ID="84941"></A>
Semi-Colon as a Transactional Separator</Heading-2>
<Body>
<A ID="pgfId-1055531"></A>
MarkLogic Server has extended the XQuery language to include the semi-colon (&#160;<code>
;</code>
&#160;) in the XQuery body as a separator between transactions in an XQuery module. Each part of the program separated by a semi-colon is evaluated as its own transaction. It is possible to have a program where some semi-colon separated parts are evaluated as query statements and some are evaluated as update statements. The statements are evaluated in the order in which they appear, and in the case of update statements, a statement will commit before the next one begins.</Body>
<Body>
<A ID="pgfId-1055517"></A>
Note that semi-colon separated statements are not multi-statement transactions. Although static analysis is performed on the entire module first and will catch some errors (syntax errors, for example), it will not catch any runtime errors that might occur during execution. If one update statement commits and the next one throws a runtime error, the first transaction is not rolled back. If you have logic that requires a rollback if subsequent transactions fail, you must either add that logic to your XQuery code or use a pre-commit trigger. For information about triggers, see <A href="triggers.xml#id(17020)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Using Triggers to Spawn Actions' on page&#160;164</A>.</Body>
<Heading-2>
<A ID="pgfId-1055711"></A>
<A ID="83837"></A>
Interactions with xdmp:eval/invoke</Heading-2>
<Body>
<A ID="pgfId-1055712"></A>
The <code>
xdmp:eval</code>
 and <code>
xdmp:invoke</code>
 functions allow you to start one transaction from the context of another. The <code>
xdmp:eval</code>
 function submits a string to be evaluated and the <code>
xdmp:invoke</code>
 function evaluates a stored module. You can control the semantics of <code>
xdmp:eval</code>
 and <code>
xdmp:invoke</code>
 with options to the functions, and this can subtly change the transactional semantics of your program. This section describes some of those subtleties and includes the following parts:</Body>
<Body-bullet>
<A ID="pgfId-1055725"></A>
<A href="transactions.xml#id(24388)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Isolation Option to xdmp:eval/invoke</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055730"></A>
<A href="transactions.xml#id(85082)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Preventing Undetectable Deadlocks</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1056260"></A>
<A href="transactions.xml#id(37369)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Seeing Updates From eval/invoke Later in the Transaction</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1055726"></A>
<A ID="24388"></A>
Isolation Option to xdmp:eval/invoke</Heading-3>
<Body>
<A ID="pgfId-1055739"></A>
The <code>
xdmp:eval</code>
 and <code>
xdmp:invoke</code>
 functions take an options node as the optional third parameter. The <code>
isolation</code>
 option determines the behavior of the transaction that results from the eval/invoke operation, and it must be one of the following values:</Body>
<Body-bullet>
<A ID="pgfId-1055745"></A>
<code>
same-statement</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055746"></A>
<code>
different-transaction</code>
</Body-bullet>
<Body>
<A ID="pgfId-1055761"></A>
When you set the <code>
isolation</code>
 to <code>
same-statement</code>
, the code that is run when you call <code>
xdmp:eval</code>
 or <code>
xdmp:invoke</code>
 is run as part of the same statement as the calling statement, which means it is also run as part of the same transaction (if the calling statement is an update statement). The effect is that any updates done in the eval/invoke operation with <code>
same-statement</code>
 isolation are performed as part of the same statement, and therefore are not visible to subsequent parts of the statement. Because query statements run at a timestamp, you cannot run update statements with <code>
same-statement</code>
 isolation in eval/invoke operations that are called from query statements. Doing so would specify that the statement switch between timestamp mode and readers/writers locks mode in the middle of a transaction, and that is not allowed; statements that do so will throw an exception. Additionally, <code>
same-statement</code>
 eval/invoke operations are not allowed when specifying a different database in which the eval/invoke operates against.</Body>
<Body>
<A ID="pgfId-1055866"></A>
When you set the <code>
isolation</code>
 to <code>
different-transaction</code>
, the code that is run when you call <code>
xdmp:eval</code>
 or <code>
xdmp:invoke</code>
 is run as a separate transaction from the calling statement, and the eval/invoke statement will commit before continuing to the rest of the calling statement. The effect is that any updates done in the eval/invoke operation with <code>
different-transaction</code>
 isolation are indeed visible to subsequent parts of the statement. However, if you use <code>
different-transaction</code>
 isolation (which is the default isolation level), you need to ensure that you do not get into an undetectable deadlock situation (see <A href="transactions.xml#id(85082)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Preventing Undetectable Deadlocks' on page&#160;18</A>).</Body>
<Body>
<A ID="pgfId-1055889"></A>
The following table shows which isolation options are allowed from query statements and update statements.</Body>
<TableAnchor>
<A ID="pgfId-1055890"></A>
</TableAnchor>
<TABLE>
<ROW>
<TH ROWSPAN="3" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1056840"></A>
Calling Statement</CellHeading>
</TH>
<TH ROWSPAN="1" COLSPAN="4">
<CellHeading>
<A ID="pgfId-1056832"></A>
Called Statement (<code>
xdmp:eval</code>
, <code>
xdmp:invoke</code>
)</CellHeading>
</TH>
</ROW>
<ROW>
<TH ROWSPAN="1" COLSPAN="2">
<CellHeading>
<A ID="pgfId-1056842"></A>
<code>
same-statement</code>
 isolation</CellHeading>
</TH>
<TH ROWSPAN="1" COLSPAN="2">
<CellHeading>
<A ID="pgfId-1056846"></A>
<code>
different-transaction</code>
 isolation</CellHeading>
</TH>
</ROW>
<ROW>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1056852"></A>
query statement</CellHeading>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1056854"></A>
update statement</CellHeading>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1056856"></A>
query statement</CellHeading>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1056858"></A>
update statement</CellHeading>
</TH>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1056860"></A>
query statement (timestamp mode)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1056862"></A>
Yes</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1056864"></A>
No (throws exception)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1056866"></A>
Yes</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1056868"></A>
Yes</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1056870"></A>
update statement (readers/writers locks mode)</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1056872"></A>
Yes*</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1056874"></A>
Yes</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1056876"></A>
Yes</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1056878"></A>
Yes (possible deadlock if updating a document with any lock)</CellBody>
</CELL>
</ROW>
</TABLE>
<Note>
<A ID="pgfId-1056926"></A>
This table is slightly simplified. For example, if an update statement calls a query statement with <code>
same-statement</code>
 isolation, the 'query statement' is actually run as part of the update statement (because it is run as part of the same transaction as the calling update statement), and it therefore runs with readers/writers locks, not in a timestamp.</Note>
<Heading-3>
<A ID="pgfId-1056928"></A>
<A ID="85082"></A>
Preventing Undetectable Deadlocks</Heading-3>
<Body>
<A ID="pgfId-1056929"></A>
A deadlock is where two processes are each waiting for the other to release a lock, and neither process can continue until the lock is released. Deadlocks are a normal part of database operations, and when a system detects them, it can deal with them (for example, by retrying one or the other transactions, by killing one or the other or both requests, and so on).</Body>
<Body>
<A ID="pgfId-1056906"></A>
There are, however, some deadlock situations that MarkLogic Server cannot detect. When you run an update statement that calls an <code>
xdmp:eval</code>
 or <code>
xdmp:invoke</code>
 statement, and the eval/invoke in turn is an update statement, you run the risk of creating an undetectable deadlock condition. These undetectable deadlocks can only occur in update statements; query statements will never cause a deadlock. </Body>
<Body>
<A ID="pgfId-1056451"></A>
An undetectable deadlock condition occurs when a transaction acquires a lock of any kind on a document and then an eval/invoke statement called from that transaction attempts to get a write lock on the same document. These undetectable deadlock conditions can only be resolved by restarting MarkLogic Server; cancelling the query does not clear the deadlock.</Body>
<Body>
<A ID="pgfId-1056005"></A>
To be completely safe, you can prevent these undetectable deadlocks from occurring by setting the <code>
prevent-deadlocks</code>
 option to <code>
true</code>
, as in the following example:</Body>
<Code>
<A ID="pgfId-1064931"></A>
xquery version &quot;1,0-ml&quot;;
(: the next line ensures this runs as an update statement :)
declare option xdmp:update &quot;true&quot;;
xdmp:eval(&quot;xdmp:node-replace(doc('/docs/test.xml')/a, &lt;b&gt;goodbye&lt;/b&gt;)&quot;,
          (),
          &lt;options xmlns=&quot;xdmp:eval&quot;&gt;
            &lt;isolation&gt;different-transaction&lt;/isolation&gt;
            &lt;prevent-deadlocks&gt;true&lt;/prevent-deadlocks&gt;
          &lt;/options&gt;) ,
doc(&quot;/docs/test.xml&quot;)</Code>
<Body>
<A ID="pgfId-1056035"></A>
This statement will then throw the following exception:</Body>
<Code>
<A ID="pgfId-1056036"></A>
XDMP-PREVENTDEADLOCKS: Processing an update from an update with different-transaction isolation could deadlock</Code>
<Body>
<A ID="pgfId-1056054"></A>
In this case, it will indeed prevent a deadlock from occurring because this statement runs as an update statement, due to the <code>
xdmp:document-insert</code>
 call, and therefore uses readers/writers locks. In line 2, a read lock is placed on the document with URI <code>
/docs/test.xml</code>
. Then, the <code>
xdmp:eval</code>
 statement attempts to get a write lock on the same document, but it cannot get the write lock until the read lock is released. This creates an undetectable deadlock condition, and the only way to clear the deadlock it to restart MarkLogic Server. Therefore the <code>
prevent-deadlocks</code>
 option stopped the deadlock from occurring. </Body>
<Body>
<A ID="pgfId-1056075"></A>
If you remove the <code>
prevent-deadlocks</code>
 option, then it defaults to <code>
false</code>
 (that is, it will <Emphasis>
allow</Emphasis>
 deadlocks). Therefore, the following statement results in a deadlock:</Body>
<WarningList>
<Warning>
<A ID="pgfId-1056076"></A>
This code is for demonstration purposes; if you run this code, it will cause an undetectable deadlock and you will have to restart MarkLogic Server to clear the deadlock.</Warning>
</WarningList>
<Code>
<A ID="pgfId-1056080"></A>
(: the next line ensures this runs as an update statement :)
if ( 1 = 2) then ( xdmp:document-insert(&quot;foobar&quot;, &lt;a/&gt;) ) else (),
doc(&quot;/docs/test.xml&quot;),
xdmp:eval(&quot;xdmp:node-replace(doc('/docs/test.xml')/a, &lt;b&gt;goodbye&lt;/b&gt;)&quot;,
          (),
          &lt;options xmlns=&quot;xdmp:eval&quot;&gt;
            &lt;isolation&gt;different-transaction&lt;/isolation&gt;
          &lt;/options&gt;) ,
doc(&quot;/docs/test.xml&quot;)</Code>
<Body>
<A ID="pgfId-1056269"></A>
This is a deadlock condition, and the only way to clear the deadlock it to restart MarkLogic Server. Note that if you take out the first call to <code>
doc(&quot;/docs/test.xml&quot;)</code>
 in line 2 of the above example, the statement will not deadlock because the read lock on <code>
/docs/test.xml</code>
 is not called until after the <code>
xdmp:eval</code>
 statement completes.</Body>
<Heading-3>
<A ID="pgfId-1056272"></A>
<A ID="37369"></A>
Seeing Updates From eval/invoke Later in the Transaction</Heading-3>
<Body>
<A ID="pgfId-1056116"></A>
If you are sure that your update statement in an eval/invoke operation does not try to update any documents that are referenced earlier in the calling statement (and therefore does not result in an undetectable deadlock condition, as described in <A href="transactions.xml#id(85082)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Preventing Undetectable Deadlocks' on page&#160;18</A>), then you can set up your statement so updates from an eval/invoke are visible from the calling transaction. This is most useful in transactions that have the eval/invoke statement before the code that accesses the newly updated documents. </Body>
<Note>
<A ID="pgfId-1056156"></A>
If you want to see the updates from an eval/invoke operation later in your statement, the statement must be an update statement. If the statement is a query statement, it runs in timestamp mode and will always see the version of the document that existing before the eval/invoke operation committed.</Note>
<Body>
<A ID="pgfId-1056155"></A>
For example, consider the following example, where <code>
doc(&quot;/docs/test.xml&quot;)</code>
 returns <code>
&lt;a&gt;hello&lt;/a&gt;</code>
 before the transaction begins:</Body>
<Code>
<A ID="pgfId-1056180"></A>
(: doc(&quot;/docs/test.xml&quot;) returns &lt;a&gt;hello&lt;/a&gt; before running this :)
(: the next line ensures this runs as an update statement :)
if ( 1 = 2 ) then ( xdmp:document-insert(&quot;fake.xml&quot;, &lt;a/&gt;) ) else (),
xdmp:eval(&quot;xdmp:node-replace(doc('/docs/test.xml')/node(), &lt;b&gt;goodbye&lt;/b&gt;)&quot;, (),
          &lt;options xmlns=&quot;xdmp:eval&quot;&gt;
            &lt;isolation&gt;different-transaction&lt;/isolation&gt;
            &lt;prevent-deadlocks&gt;false&lt;/prevent-deadlocks&gt;
          &lt;/options&gt;) ,
doc(&quot;/docs/test.xml&quot;)</Code>
<Body>
<A ID="pgfId-1056199"></A>
The call to <code>
doc(&quot;/docs/test.xml&quot;)</code>
 in the last line of the example returns <code>
&lt;a&gt;goodbye&lt;/a&gt;</code>
, which is the new version that was updated by the <code>
xdmp:eval</code>
 operation.</Body>
<Heading-2>
<A ID="pgfId-1054542"></A>
<A ID="87191"></A>
Functions With Non-Transactional Side Effects</Heading-2>
<Body>
<A ID="pgfId-1057149"></A>
Update statements use various update built-in functions which, at the time the transaction completes, update documents in a database. These updates are technically known as <Emphasis>
side effects</Emphasis>
, because they cause a change to happen outside of what the statement returns. The side effects from the update built-in functions (<code>
xdmp:node-replace</code>
, <code>
xdmp:document-insert</code>
, and so on) are transactional in nature; that is, they either complete fully or are rolled back to the state at the beginning of the update statement.</Body>
<Body>
<A ID="pgfId-1057282"></A>
There are several functions that evaluate asynchronously as soon as they are called, regardless of whether called from an update statement or a query statement. Examples of these functions are <code>
xdmp:spawn</code>
, <code>
xdmp:http-get</code>
, and <code>
xdmp:log</code>
. These functions have side effects outside the scope of the transaction (<Emphasis>
non-transactional</Emphasis>
 side effects).</Body>
<Body>
<A ID="pgfId-1057173"></A>
When evaluating an XQuery module that performs an update transaction, it is possible for the update to either fail or retry. That is the normal, transactional behavior, and the database will always be left in a consistent state if a transaction fails or retries. If your update statement calls one of these functions with non-transactional side effects, however, that function will evaluate even if the calling update statement fails and rolls back. </Body>
<Body>
<A ID="pgfId-1057190"></A>
Use care or avoid calling any of these functions from an update statement, as they are not guaranteed to only evaluate once (or to not evaluate if the transaction rolls back). If you are logging some information with <code>
xdmp:log</code>
 in your transaction, it might or might not be appropriate for that statement to be logged on retries (for example, if the transaction is retried because a deadlock is detected). Even if it is not what you intended, it might not do any harm.</Body>
<Body>
<A ID="pgfId-1057238"></A>
Other side effects, however, can cause problems in updates. For example, if you use <code>
xdmp:spawn</code>
 in this context, the action might be spawned multiple times if the calling statement retries, or the action might be spawned even if the transaction fails; the <code>
xdmp:spawn</code>
 call evaluates asyncronously as soon as it is called. Similarly, if you are calling a web service with <code>
xdmp:http-get</code>
 from an update statement, it might evaluate when you did not mean for it to evaluate. If you do use these functions in updates, your application logic must handle the side effects appropriately. These types of use cases are usually better suited to triggers and the Content Processing Framework. For details, see <A href="triggers.xml#id(17020)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Using Triggers to Spawn Actions' on page&#160;164</A> and the <Emphasis>
Content Processing Framework Guide</Emphasis>
 manual.</Body>
<Heading-2>
<A ID="pgfId-1057148"></A>
<A ID="33250"></A>
Example: Incrementing the System Timestamp</Heading-2>
<Body>
<A ID="pgfId-1054543"></A>
The following example shows how updates to the system increment the system timestamp. For background on system timestamps, see <A href="transactions.xml#id(84472)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'System Timestamps and Fragment Versioning' on page&#160;13</A>.</Body>
<Code>
<A ID="pgfId-1054544"></A>
&lt;results&gt;{
  &lt;start-of-query&gt;{xdmp:request-timestamp()}&lt;/start-of-query&gt;,
for $x in (1 to 10)
return
(xdmp:eval(&quot;xdmp:document-insert('test.xml', &lt;test/&gt;)&quot;),
 xdmp:eval(&quot;xdmp:document-delete('test.xml')&quot; ) ),
&lt;end-of-query&gt;{xdmp:eval('xdmp:request-timestamp()')}&lt;/end-of-query&gt;,
  &lt;number-of-transactions&gt;{xdmp:eval('xdmp:request-timestamp()') -
&#160;&#160;xdmp:request-timestamp()}&lt;/number-of-transactions&gt;,
&lt;elapsed-time&gt;{xdmp:query-meters()/*:elapsed-time/text()}
&#160;&#160;&lt;/elapsed-time&gt;
}
&lt;/results&gt;</Code>
<Body>
<A ID="pgfId-1054545"></A>
This XQuery program executes as a query statement, which runs at a timestamp. Each of the <code>
xdmp:eval</code>
 statements is evaluated as a separate transaction, and they are each update statements. The query starts off by printing out the system timestamp, then it starts a FLWOR expression which evaluates 10 times. Each iteration of the FLWOR creates a document called <code>
test.xml</code>
 in a separate transaction, then deletes the document in another transaction. Finally, it calculates the number of transactions that have occurred since the query started by starting a new transaction to get the current system timestamp and subtracting that from the timestamp in which the query runs. Therefore, this query produces the following results, which show that 20 transactions have occurred.</Body>
<Code>
<A ID="pgfId-1054546"></A>
&lt;results&gt;
&#160;&#160;&lt;start-of-query&gt;382638&lt;/start-of-query&gt;
&#160;&#160;&lt;end-of-query&gt;382658&lt;/end-of-query&gt;
&#160;&#160;&lt;number-of-transactions&gt;20&lt;/number-of-transactions&gt;
&#160;&#160;&lt;elapsed-time&gt;PT0.102211S&lt;/elapsed-time&gt;
&lt;/results&gt;</Code>
<Note>
<A ID="pgfId-1054547"></A>
This example executes 20 update statements with <code>
xdmp:eval</code>
, each of which starts its own transaction, and each of which increments the system timestamp by 1. If there are other transactions happening concurrently on the system while these transactions are executing, those transactions might also increment the system timestamp, and it is possible that the last <code>
xdmp:eval</code>
 statement which executes the <code>
xdmp:request-timestamp</code>
 function might return a number more that 20 greater than the first call to <code>
xdmp:request-timestamp</code>
. </Note>
</XML>
