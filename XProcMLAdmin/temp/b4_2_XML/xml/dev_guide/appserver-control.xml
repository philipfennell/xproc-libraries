<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="appserver-control.css" type="text/css" charset="UTF-8"?>
<XML>
<TITLE> </TITLE><Heading-1>
<A ID="pgfId-1053802"></A>
<A ID="86523"></A>
 Controlling App Server Access, Output, and Errors</Heading-1>
<Body>
<A ID="pgfId-1058965"></A>
MarkLogic Server evaluates XQuery programs against App Servers. This chapter describes ways of controlling the output, both by App Server configuration and with XQuery built-in functions. Primarily, the features described in this chapter apply to HTTP App Servers, although some of them are also valid with XDBC Servers and with the Task Server. This chapter contains the following sections:</Body>
<Body-bullet>
<A ID="pgfId-1058971"></A>
<A href="appserver-control.xml#id(89735)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Creating Custom HTTP Server Error Pages</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1059969"></A>
<A href="appserver-control.xml#id(13050)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Setting Up URL Rewriting for an HTTP App Server</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1058975"></A>
<A href="appserver-control.xml#id(28091)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Outputting SGML Entities</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1059114"></A>
<A href="appserver-control.xml#id(99082)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Specifying the Output Encoding</Hyperlink>
</A></Body-bullet>
<Heading-2>
<A ID="pgfId-1058961"></A>
<A ID="89735"></A>
Creating Custom HTTP Server Error Pages</Heading-2>
<pagenum>
<A ID="pgfId-1053806"></A>
160</pagenum>
<Body>
<A ID="pgfId-1049471"></A>
This section describes how to use the HTTP Server error pages and includes the following parts:</Body>
<Body-bullet>
<A ID="pgfId-1059166"></A>
<A href="appserver-control.xml#id(75119)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Overview of Custom HTTP Error Pages</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1059322"></A>
<A href="appserver-control.xml#id(77265)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Error XML Format</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1053734"></A>
<A href="appserver-control.xml#id(87072)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Configuring Custom Error Pages</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1063531"></A>
<A href="appserver-control.xml#id(84264)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Execute Permissions Are Needed On Error Handler Document for Modules Databases</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054928"></A>
<A href="appserver-control.xml#id(64195)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Example of Custom Error Pages</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1054048"></A>
<A ID="75119"></A>
Overview of Custom HTTP Error Pages</Heading-3>
<Body>
<A ID="pgfId-1059196"></A>
A custom HTTP Server error page is a way to redirect application exceptions to an XQuery program. When any 400 or 500 HTTP exception is thrown (except for a 503 error), an XQuery module is evaluated and the results are returned to the client. Custom error pages typically provide more user-friendly messages to the end-user, but because the error page is an XQuery module, you can make it perform arbitrary work.</Body>
<Body>
<A ID="pgfId-1059229"></A>
The XQuery module can get the HTTP error code and the contents of the HTTP response using the <code>
xdmp:get-response-code</code>
 API. The XQuery module for the error handler also has access to the XQuery stack trace, if there is one; the XQuery stack trace is passed to the module as an external variable with the name <code>
$error:errors</code>
 in the XQuery <code>
1.0-ml</code>
 dialect and as <code>
$err:errors</code>
 in the XQuery <code>
0.9-ml</code>
 dialect (they are both bound to the same namespace, but the <code>
err</code>
 prefix is predefined in <code>
0.9-ml</code>
 and <code>
error</code>
 prefix is predefined in <code>
1.0-ml</code>
). </Body>
<Body>
<A ID="pgfId-1059206"></A>
If the error is a 503 (unavailable) error, then the error handler is not invoked and the 503 exception is returned to the client.</Body>
<Body>
<A ID="pgfId-1059205"></A>
If the error page itself throws an exception, that exception is passed to the client with the error code from the error page. It will also include a stack trace that includes the original error code and exception. </Body>
<Heading-3>
<A ID="pgfId-1059198"></A>
<A ID="77265"></A>
Error XML Format</Heading-3>
<Body>
<A ID="pgfId-1059324"></A>
Error messages are thrown with an XML error stack trace that uses the <code>
error.xsd</code>
 schema. Stack trace includes any exceptions thrown, line numbers, and XQuery Version. Stack trace is accessible from custom error pages through the <code>
$error:errors</code>
 external variable. The following is a sample error XML output for an XQuery module with a syntax error:</Body>
<Code>
<A ID="pgfId-1059331"></A>
&lt;error:error xsi:schemaLocation=&quot;http://marklogic.com/xdmp/error
&#160;&#160;&#160;error.xsd&quot; 
&#160;&#160;&#160;xmlns:error=&quot;http://marklogic.com/xdmp/error&quot;
&#160;&#160;&#160;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;
&#160;&#160;&lt;error:code&gt;XDMP-CONTEXT&lt;/error:code&gt;
&#160;&#160;&lt;error:name&gt;err:XPDY0002&lt;/error:name&gt;
&#160;&#160;&lt;error:xquery-version&gt;1.0-ml&lt;/error:xquery-version&gt;
&#160;&#160;&lt;error:message&gt;Expression depends on the context where none 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;is defined&lt;/error:message&gt;
&#160;&#160;&lt;error:format-string&gt;XDMP-CONTEXT: (err:XPDY0002) Expression 
&#160;&#160;&#160;&#160;depends on the context where none is defined&lt;/error:format-string&gt; 
&#160;&#160;&lt;error:retryable&gt;false&lt;/error:retryable&gt; 
&#160;&#160;&lt;error:expr/&gt; &lt;error:data/&gt; 
&#160;&#160;&lt;error:stack&gt; 
&#160;&#160;&#160;&#160;&lt;error:frame&gt; 
&#160;&#160;&#160;&#160;&#160;&lt;error:uri&gt;/blaz.xqy&lt;/error:uri&gt; 
&#160;&#160;&#160;&#160;&#160;&lt;error:line&gt;1&lt;/error:line&gt;
&#160;&#160;&#160;&#160;&#160;&lt;error:xquery-version&gt;1.0-ml&lt;/error:xquery-version&gt;
&#160;&#160;&#160;&#160;&lt;/error:frame&gt; 
&#160;&#160;&lt;/error:stack&gt; 
&lt;/error:error&gt;</Code>
<Heading-3>
<A ID="pgfId-1059323"></A>
<A ID="87072"></A>
Configuring Custom Error Pages</Heading-3>
<Body>
<A ID="pgfId-1055449"></A>
To configure a custom error page for an HTTP App Server, enter the name of the XQuery module in the Error Handler field of an HTTP Server. If the path does not start with a slash (<code>
/</code>
), then it is relative to the App Server root. If it does start with a slash (<code>
/</code>
), then it follows the import rules described in <A href="import_modules.xml#id(68169)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Importing XQuery Modules, XSLT Stylesheets, and Resolving Paths' on page&#160;59</A>.</Body>
<Heading-3>
<A ID="pgfId-1063517"></A>
<A ID="84264"></A>
Execute Permissions Are Needed On Error Handler Document for Modules Databases</Heading-3>
<Body>
<A ID="pgfId-1063504"></A>
If your App Server is configured to use a modules database (that is, it stores and executes its XQuery code in a database) then you should put an execute permission on the error handler module document. The execute permission is paired to a role, and all users of the App Server must have that role in order to execute the error handler; if a user does not have the role, then that user will not be able to execute the error handler module, and it will get a 401 (unauthorized) error instead of having the error be caught and handled by the error handler. </Body>
<Body>
<A ID="pgfId-1063556"></A>
As a consequence of needing the execute permission on the error handler, if a user who is actually not authorized to run the error handler attempts to access the App Server, that user runs as the default user configured for the App Server until authentication. If authentication fails, then the error handler is called as the default user, but because that default user does not have permission to execute the error handler, the user is not able to find the error handler and a 404 error (not found) is returned. Therefore, if you want all users (including unauthorized users) to have permission to run the error handler, you should give the default user a role (it does not need to have any privileges on it) and assign an execute permission to the error handler paired with that role. </Body>
<Heading-3>
<A ID="pgfId-1055555"></A>
<A ID="64195"></A>
Example of Custom Error Pages</Heading-3>
<Body>
<A ID="pgfId-1059256"></A>
The following XQuery module is an extremely simple XQuery error handler.</Body>
<Code>
<A ID="pgfId-1059266"></A>
xquery version &quot;1.0-ml&quot;;

declare variable $error:errors as node()* external;

xdmp:set-response-content-type(&quot;text/plain&quot;),
xdmp:get-response-code(),
$error:errors</Code>
<Body>
<A ID="pgfId-1059985"></A>
This simply returns all of the information from the page that throws the exception. In a typical error page, you would use some or all of the information and make a user-friendly representation of it to display to the users. Because you can write arbitrary XQuery in the error page, you can do a wide variety of things, including sending an email to the application administrator, redirecting it to a different page, and so on.</Body>
<Heading-2>
<A ID="pgfId-1059987"></A>
<A ID="13050"></A>
Setting Up URL Rewriting for an HTTP App Server</Heading-2>
<Body>
<A ID="pgfId-1061242"></A>
This section describes how to use the HTTP Server URL Rewriter feature and includes the following parts:</Body>
<Body-bullet>
<A ID="pgfId-1061272"></A>
<A href="appserver-control.xml#id(38264)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Overview of URL Rewriting</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1061276"></A>
<A href="appserver-control.xml#id(61417)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Creating a URL Rewrite Script</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1061280"></A>
<A href="appserver-control.xml#id(15655)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Configuring an HTTP App Server to use the URL Rewrite Script</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1061284"></A>
<A href="appserver-control.xml#id(82244)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
More URL Rewrite Script Examples</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1061447"></A>
<A href="appserver-control.xml#id(31820)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Prohibiting Access to Internal URLs</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1061367"></A>
<A href="appserver-control.xml#id(97644)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
URL Rewriting and Page-Relative URLs</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1061230"></A>
<A ID="38264"></A>
Overview of URL Rewriting</Heading-3>
<Body>
<A ID="pgfId-1060290"></A>
You can access any MarkLogic Server resource with a URL, which is a fundamental characteristic of Representational state transfer (REST) services. In its raw form, the URL must either reflect the physical location of the resource (if it's a document in the database), or it must be of the form:</Body>
<Code>
<A ID="pgfId-1062897"></A>
http://&lt;dispatcher-program.xqy&gt;?instructions=foo</Code>
<Body>
<A ID="pgfId-1060582"></A>
Users of web applications typically prefer short, neat URLs to raw query string parameters. A concise URL, also referred to as a 'clean URL,' is easy to remember, and less time-consuming to type in. If the URL can be made to relate clearly to the content of the page, then errors are less likely to happen. Also crawlers and search engines often use the URL of a web page to determine whether or not to index the URL and the ranking it receives. For example, a search engine may give a better ranking to a well-structured URL such as:</Body>
<Code>
<A ID="pgfId-1060583"></A>
http://marklogic.com/technical/features.html</Code>
<Body>
<A ID="pgfId-1060570"></A>
than to a less-structured, less-informative URL like the following:</Body>
<Code>
<A ID="pgfId-1060577"></A>
http://marklogic.com/document?id=43759</Code>
<Body>
<A ID="pgfId-1062753"></A>
In a 'RESTful' environment, URLs should be well-structured, predictable, and decoupled from the physical location of a document or program. When an HTTP server receives an HTTP request with a well-structured, clean URL, it must be able to transparently map that to the internal URL of a document or program.</Body>
<Body>
<A ID="pgfId-1062825"></A>
The URL Rewriter feature allows you to configure your HTTP App Server to enable the rewriting of internal URLs to clean URLs, giving you the flexibility to use any URL to point to any resource (web page, document, XQuery program and arguments). The URL Rewriter implemented by MarkLogic Server operates similarly to the Apache mod_rewrite module, only you write an XQuery program to perform the rewrite operation.</Body>
<Body>
<A ID="pgfId-1062687"></A>
The URL rewriting happens through an internal redirect mechanism so the client is not aware of how the URL was rewritten. This makes the inner workings of a web site's address opaque to visitors. The internal URLs can also be blocked or made inaccessible directly if desired by rewriting them to non-existent URLs, as described in <A href="appserver-control.xml#id(31820)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Prohibiting Access to Internal URLs' on page&#160;155</A>.</Body>
<Body>
<A ID="pgfId-1064019"></A>
For information about creating a URL rewriter to directly invoke XSLT stylesheets, see <A href="../xquery/xslt.xml#id(70125)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Invoking Stylesheets Directly Using the XSLT Rewriter</Hyperlink>
</A> in the <Emphasis>
XQuery and XSLT Reference Guide</Emphasis>
.</Body>
<Note>
<A ID="pgfId-1063873"></A>
If your application code is in a modules database, the URL rewriter needs to have permissions for the default App Server user (nobody by default) to execute the module.  This is the same as with an error handler that is stored in the database, as described in <A href="appserver-control.xml#id(84264)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Execute Permissions Are Needed On Error Handler Document for Modules Databases' on page&#160;148</A>. </Note>
<Heading-3>
<A ID="pgfId-1060713"></A>
<A ID="61417"></A>
Creating a URL Rewrite Script</Heading-3>
<Body>
<A ID="pgfId-1060714"></A>
Your first step in rewriting a URL is to create a URL rewrite script that reads the clean URL given to the server by the bowser and converts it to the raw URL recognized by the server.</Body>
<Body>
<A ID="pgfId-1060730"></A>
For example, if you configured an HTTP App Server for the <Hyperlink>
<A href="http://xqzone.marklogic.com/svn/bill/trunk/" xml:link="simple" show="replace" actuate="user" CLASS="URL">Shakespeare Demo Application</A></Hyperlink>
 at port 8060, you can access the demo with the URL:</Body>
<Code>
<A ID="pgfId-1060731"></A>
http://localhost:8060/frames.html</Code>
<Body>
<A ID="pgfId-1060732"></A>
A 'cleaner,' more descriptive URL would be something like:</Body>
<Code>
<A ID="pgfId-1060733"></A>
http://localhost:8060/Shakespeare</Code>
<Body>
<A ID="pgfId-1060683"></A>
To accomplish this URL rewrite, create script named <code>
url_rewrite.xqy</code>
 that uses the <code>
xdmp:get-request-url</code>
 function to read the URL given by the user and the <code>
fn:replace</code>
 function to convert <code>
/Shakespeare</code>
 to<code>
 /frames.html</code>
:</Body>
<Code>
<A ID="pgfId-1060684"></A>
xquery version &quot;1.0-ml&quot;;</Code>
<Code>
<A ID="pgfId-1060685"></A>
let $url := xdmp:get-request-url() 
return fn:replace($url, &quot;^/Shakespeare$&quot;, &quot;/frames.html&quot;)</Code>
<Body>
<A ID="pgfId-1062924"></A>
Though the URL is converted by the server to <code>
/frames.html</code>
, <code>
/Shakespeare</code>
 is displayed in the browser's URL field after the page is opened.</Body>
<Body>
<A ID="pgfId-1063319"></A>
The <code>
xdmp:get-request-url</code>
 function returns the portion of the URL following the scheme and network location (domain name or host_name:port_number). In the above example, <code>
xdmp:get-request-url </code>
returns /frames.html. Unlike, <code>
xdmp:get-request-path</code>
, which returns only the query string, the <code>
xdmp:get-request-url</code>
 function returns the query string and any anchors in the URL, all of which can be modified by your URL rewrite script.</Body>
<Body>
<A ID="pgfId-1060827"></A>
You can create more elaborate URL rewrite scripts, as described in <A href="appserver-control.xml#id(82244)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'More URL Rewrite Script Examples' on page&#160;154</A> and <A href="appserver-control.xml#id(31820)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Prohibiting Access to Internal URLs' on page&#160;155</A>.</Body>
<Heading-3>
<A ID="pgfId-1060658"></A>
<A ID="15655"></A>
Configuring an HTTP App Server to use the URL Rewrite Script</Heading-3>
<Body>
<A ID="pgfId-1064043"></A>
Perform the following steps to configure an HTTP App Server for URL rewriting:</Body>
<Number1>
<A ID="pgfId-1060611"></A>
Click the Groups icon in the left frame.</Number1>
<NumberList>
<Number>
<A ID="pgfId-1060612"></A>
Click the group in which you want to define the HTTP server (for example, Default).</Number>
<Number>
<A ID="pgfId-1060613"></A>
Click the App Servers icon on the left tree menu. and either select an exiting HTTP server or create a new one.</Number>
<Number>
<A ID="pgfId-1060842"></A>
In the Root field, specify the root directory in which your executable files are located. for example, if your modules field is set to <code>
(file system)</code>
 and the <code>
.xqy</code>
 files for your Shakespeare demo are located in <code>
C:\Program Files\MarkLogic\bill</code>
, your root would be <code>
bill</code>
. </Number>
<Number>
<A ID="pgfId-1060944"></A>
If Modules is set to <code>
(file system)</code>
, then place the URL rewrite script, <code>
url_rewrite.xqy</code>
, in the root directory. If Modules is set to a database, then load <code>
url_rewrite.xqy</code>
 into that database under the root <code>
bill</code>
. For example, if using <code>
xdmp:document-load</code>
, the URI option would look like: <code>
&lt;uri&gt;bill/url_rewrite.xqy&lt;/uri&gt;</code>
</Number>
</NumberList>
<Body-indent>
<A ID="pgfId-1060970"></A>
<IMAGE xml:link="simple" href="images/App_server_root.gif" show="embed" actuate="auto"/>
</Body-indent>
<NumberList>
<Number>
<A ID="pgfId-1060988"></A>
In the URL Rewriter field, specify the name of your URL rewrite script:</Number>
</NumberList>
<Body-indent>
<A ID="pgfId-1060974"></A>
<IMAGE xml:link="simple" href="images/url_rewriter.gif" show="embed" actuate="auto"/>
</Body-indent>
<NumberList>
<Number>
<A ID="pgfId-1060975"></A>
Click OK to save your changes.</Number>
<Number>
<A ID="pgfId-1063024"></A>
From your browser, test the clean URL:</Number>
</NumberList>
<Body-indent>
<A ID="pgfId-1061396"></A>
<IMAGE xml:link="simple" href="images/test_url_rewriter.gif" show="embed" actuate="auto"/>
</Body-indent>
<Heading-3>
<A ID="pgfId-1060074"></A>
<A ID="82244"></A>
More URL Rewrite Script Examples</Heading-3>
<Body>
<A ID="pgfId-1061432"></A>
You can use the pattern matching features in regular expressions to create more flexible URL rewrite scripts. </Body>
<Body>
<A ID="pgfId-1061584"></A>
For example, you want the user to only have to enter <code>
/</code>
 after the scheme and network location portions of the URL (for example, <code>
http://localhost:8060/</code>
) and have it rewritten as <code>
/frames.html</code>
:</Body>
<Code>
<A ID="pgfId-1060129"></A>
xquery version &quot;1.0-ml&quot;;</Code>
<Code>
<A ID="pgfId-1060173"></A>
let $url := xdmp:get-request-url() 
return fn:replace($url,&quot;^/$&quot;, &quot;/frames.html&quot;)</Code>
<Body>
<A ID="pgfId-1062458"></A>
In this example, you hide the <code>
.xqy</code>
 extension from the browser's address bar and convert a static URL into a dynamic URL (containing a <code>
? </code>
character), you could do something like:</Body>
<Code>
<A ID="pgfId-1061724"></A>
let $url := xdmp:get-request-url()</Code>
<Code>
<A ID="pgfId-1061725"></A>
return fn:replace($url, 
&#160;&#160;&#160;&#160;&#160;&#160;&quot;^/product-([0-9]+)\.html$&quot;,
&#160;&#160;&#160;&#160;&#160;&#160;&quot;/product.xqy?id=$1&quot;)</Code>
<Body>
<A ID="pgfId-1061607"></A>
The product ID can be any number. For example, the URL <code>
/product-12.html</code>
 is converted to <code>
/product.xqy?id=12</code>
 and <code>
/product-25.html</code>
 is converted to <code>
/product.xqy?id=25</code>
. </Body>
<Body>
<A ID="pgfId-1061789"></A>
Search engine optimization experts suggest displaying the main keyword in the URL. In the following URL rewriting technique you can display the name of the product in the URL:</Body>
<Code>
<A ID="pgfId-1061802"></A>
let $url := xdmp:get-request-url()</Code>
<Code>
<A ID="pgfId-1061769"></A>
return fn:replace($url,
&#160;&#160;&#160;&#160;&#160;&#160;&quot;^/product/([a-zA-Z0-9_-]+)/([0-9]+)\.html$&quot;,
&#160;&#160;&#160;&#160;&#160;&#160;&quot;/product.xqy?id=$2&quot;)</Code>
<Body>
<A ID="pgfId-1061861"></A>
The product name can be any string. For example,<code>
 /product/canned_beans/12.html</code>
 is converted to<code>
 /product.xqy?id=12</code>
 and <code>
/product/cola_6_pack/8.html</code>
 is converted to <code>
/product.xqy?id=8</code>
.</Body>
<Body>
<A ID="pgfId-1063345"></A>
If you need to rewrite multiple pages on your HTTP server, you can create a URL rewrite script like the following:</Body>
<Code>
<A ID="pgfId-1063364"></A>
let $url := xdmp:get-request-url()</Code>
<Code>
<A ID="pgfId-1063366"></A>
let $url := fn:replace($url, &quot;^/Shaw$&quot;, '/frames1.html&quot;)
let $url := fn:replace($url, &quot;^/Shakespeare$&quot;, &quot;/frames2.html&quot;)
let $url := fn:replace($url, &quot;^/Browning$&quot;, &quot;/frames3.html&quot;)</Code>
<Code>
<A ID="pgfId-1063374"></A>
return $url</Code>
<Heading-3>
<A ID="pgfId-1061092"></A>
<A ID="31820"></A>
Prohibiting Access to Internal URLs</Heading-3>
<Body>
<A ID="pgfId-1061099"></A>
The URL Rewriter feature also enables you to block user's from accessing internal URLs. For example, to prohibit direct access to <code>
customer_list.html</code>
, your URL rewrite script might look like the following:</Body>
<Code>
<A ID="pgfId-1061068"></A>
let $url := xdmp:get-request-url()</Code>
<Code>
<A ID="pgfId-1061159"></A>
return if (fn:matches($url,&quot;^/customer_list.html$&quot;)) 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;then &quot;/nowhere.html&quot; 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;else fn:replace($url,&quot;^/Shakespeare$&quot;, &quot;/frames.html&quot;)</Code>
<Body>
<A ID="pgfId-1061069"></A>
Where<code>
 /nowhere.html</code>
 is a non-existent page for which the browser returns a '404 Not Found' error. Alternatively, you could redirect to a URL consisting of a random number generated using <code>
xdmp:random</code>
 or some other scheme that is guaranteed to generate non-existent URLs.</Body>
<Heading-3>
<A ID="pgfId-1061213"></A>
<A ID="97644"></A>
URL Rewriting and Page-Relative URLs</Heading-3>
<Body>
<A ID="pgfId-1061214"></A>
You may encounter problems when rewriting a URL to a page that makes use of page-relative URLs because relative URLs are resolved by the client. If the directory path of the clean URL used by the client differs from the raw URL at the server, then the page-relative links are incorrectly resolved. </Body>
<Body>
<A ID="pgfId-1062505"></A>
If you are going to rewrite a URL to a page that uses page-relative URLs, convert the page-relative URLs to server-relative or canonical URLs. For example, if your application is located in <code>
C:\Program Files\MarkLogic\myapp</code>
 and the page builds a frameset with page-relative URLs, like:</Body>
<Code>
<A ID="pgfId-1062506"></A>
&lt;frame src=&quot;top.html&quot; name=&quot;headerFrame&quot;&gt;</Code>
<Body>
<A ID="pgfId-1062340"></A>
You should change the URLs to server-relative:</Body>
<Code>
<A ID="pgfId-1062265"></A>
&lt;frame src=&quot;/myapp/top.html&quot; name=&quot;headerFrame&quot;&gt;</Code>
<Body>
<A ID="pgfId-1062360"></A>
or canonical:</Body>
<Code>
<A ID="pgfId-1062351"></A>
&lt;frame src=&quot;http://127.0.0.1:8000/myapp/top.html&quot; name=&quot;headerFrame&quot;&gt;</Code>
<Heading-3>
<A ID="pgfId-1062131"></A>
Using the URL Rewrite Trace Event</Heading-3>
<Body>
<A ID="pgfId-1062543"></A>
You can use the URL Rewrite trace event to help you debug your URL Rewrite scripts. To use the URL Rewrite trace event, you must enable tracing (at the group level) for your configuration and set the event:</Body>
<Number1>
<A ID="pgfId-1062544"></A>
Log into the Admin Interface.</Number1>
<NumberList>
<Number>
<A ID="pgfId-1062545"></A>
Select Groups &gt; <Emphasis>
group_name</Emphasis>
 &gt; Diagnostics.</Number>
</NumberList>
<Body-indent>
<A ID="pgfId-1062546"></A>
The Diagnostics Configuration page appears.</Body-indent>
<NumberList>
<Number>
<A ID="pgfId-1062547"></A>
Click the <code>
true</code>
 button for <code>
trace events activated</code>
.</Number>
<Number>
<A ID="pgfId-1062551"></A>
In the [add] field, enter: <code>
URL Rewrite</code>
</Number>
<Number>
<A ID="pgfId-1062552"></A>
Click the OK button to activate the event.</Number>
</NumberList>
<Body-indent>
<A ID="pgfId-1062657"></A>
<IMAGE xml:link="simple" href="images/URL_Rewrite_Event.gif" show="embed" actuate="auto"/>
</Body-indent>
<EndList-root>
<A ID="pgfId-1062553"></A>
After you configure the URL Rewrite trace event, when any URL Rewrite script is invoked, a line, like that shown below, is added to the <code>
ErrorLog.txt</code>
 file, indicating the URL received from the client and the converted URL from the URL rewriter:</EndList-root>
<Code>
<A ID="pgfId-1063230"></A>
2009-02-11 12:06:32.587 Info: [Event:id=URL Rewrite] Rewriting URL /Shakespeare to /frames.html</Code>
<Note>
<A ID="pgfId-1062554"></A>
The trace events are designed as development and debugging tools, and they might slow the overall performance of MarkLogic Server. Also, enabling many trace events will produce a large quantity of messages, especially if you are processing a high volume of documents. When you are not debugging, disable the trace event for maximum performance.</Note>
<Heading-2>
<A ID="pgfId-1061216"></A>
<A ID="28091"></A>
Outputting SGML Entities</Heading-2>
<Body>
<A ID="pgfId-1059991"></A>
This section describes the SGML entity output controls in MarkLogic Server, and includes the following parts:</Body>
<Body-bullet>
<A ID="pgfId-1059015"></A>
<A href="appserver-control.xml#id(83388)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Understanding the Different SGML Mapping Settings</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1059019"></A>
<A href="appserver-control.xml#id(31668)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Configuring SGML Mapping in the App Server Configuration</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1059814"></A>
<A href="appserver-control.xml#id(21695)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Specifying SGML Mapping in an XQuery Program</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1058987"></A>
<A ID="83388"></A>
Understanding the Different SGML Mapping Settings</Heading-3>
<Body>
<A ID="pgfId-1058988"></A>
An SGML character entity is a name separated by an ampersand ( <code>
&amp;</code>
 ) character at the beginning and a semi-colon ( <code>
;</code>
 ) character at the end. The entity maps to a particular character. This markup is used in SGML, and sometimes is carried over to XML. MarkLogic Server allows you to control if SGML character entities upon serialization of XML on output, either at the App Server level using the Output SGML Character Entites drop down list or using the <code>
&lt;output-sgml-character-entities&gt;</code>
 option to the built-in functions <code>
xdmp:quote</code>
 or <code>
xdmp:save</code>
. When SGML characters are mapped (for an App Server or with the built-in functions), any unicode characters that have an SGML mapping will be output as the corresponding SGML entity. The default is <code>
none</code>
, which does not output any characters as SGML entites.</Body>
<Body>
<A ID="pgfId-1059021"></A>
The mappings are based on the W3C XML Entities for Characters specification:</Body>
<Body-bullet>
<A ID="pgfId-1059419"></A>
<Hyperlink>
<A href="http://www.w3.org/TR/2008/WD-xml-entity-names-20080721/" xml:link="simple" show="replace" actuate="user" CLASS="URL">http://www.w3.org/TR/2008/WD-xml-entity-names-20080721/</A></Hyperlink>
</Body-bullet>
<Body>
<A ID="pgfId-1059462"></A>
with the following modifications to the specification:</Body>
<Body-bullet>
<A ID="pgfId-1059478"></A>
Entities that map to multiple codepoints are not output, unless there is an alternate single-codepoint mapping available. Most of these entities are negated mathematical symbols (<code>
nrarrw</code>
 from <code>
isoamsa</code>
 is an example). </Body-bullet>
<Body-bullet>
<A ID="pgfId-1059493"></A>
The <code>
gcedil</code>
 set is also included (it is not included in the specification).</Body-bullet>
<Body>
<A ID="pgfId-1059497"></A>
The following table describes the different SGML character mapping settings:</Body>
<TABLE>
<ROW>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1059511"></A>
SGML Character Mapping Setting</CellHeading>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<CellHeading>
<A ID="pgfId-1059513"></A>
Description</CellHeading>
</TH>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1059515"></A>
<code>
none</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1059517"></A>
The default. No SGML entity mapping is performed on the output.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1059519"></A>
<code>
normal</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1059521"></A>
Converts unicode codepoints to SGML entities on output. The conversions are made in the default order. The only difference between <code>
normal</code>
 and the <code>
math</code>
 and <code>
pub</code>
 settings is the order that it chooses to map entities, which only affects the mapping of entities where there are multiple entities mapped to a particular codepoint.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1059523"></A>
<code>
math</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1059525"></A>
Converts unicode codepoints to SGML entities on output. The conversions are made in an order that favors math-related entities. The only difference between <code>
math</code>
 and the <code>
normal</code>
 and <code>
pub</code>
 settings is the order that it chooses to map entities, which only affects the mapping of entities where there are multiple entities mapped to a particular codepoint.</CellBody>
</CELL>
</ROW>
<ROW>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1059527"></A>
<code>
pub</code>
</CellBody>
</CELL>
<CELL ROWSPAN="1" COLSPAN="1">
<CellBody>
<A ID="pgfId-1059529"></A>
Converts unicode codepoints to SGML entities on output. The conversions are made in an order favoring entities commonly used by publishers. The only difference between <code>
pub</code>
 and the <code>
normal</code>
 and <code>
math</code>
 settings is the order that it chooses to map entities, which only affects the mapping of entities where there are multiple entities mapped to a particular codepoint.</CellBody>
</CELL>
</ROW>
</TABLE>
<Note>
<A ID="pgfId-1059836"></A>
In general, the <code>
&lt;repair&gt;full&lt;/repair&gt;</code>
 option on <code>
xdmp:document-load</code>
 and the <code>
&quot;repair-full&quot;</code>
 option on <code>
xdmp:unquote</code>
 do the opposite of the Output SGML Character Entites settings, as the ingestion APIs map SGML entities to their codepoint equivalents (one or more codepoints). The difference with the output options is that the output options perform only single-codepoint to entity mapping, not multiple codepoint to entity mapping. </Note>
<Heading-3>
<A ID="pgfId-1059399"></A>
<A ID="31668"></A>
Configuring SGML Mapping in the App Server Configuration</Heading-3>
<Body>
<A ID="pgfId-1059400"></A>
To configure SGML output mapping for an App Server, perform the following steps:</Body>
<Number1>
<A ID="pgfId-1059676"></A>
In the Admin Interface, navigate to the App Server you want to configure (for example, Groups &gt; Default &gt; App Servers &gt; MyAppServer).</Number1>
<NumberList>
<Number>
<A ID="pgfId-1059700"></A>
Scroll down to the Output SGML Entity Characters drop list (it is towards the bottom).</Number>
<Number>
<A ID="pgfId-1059701"></A>
Select the setting you want. The settings are described in the table in the previous section.</Number>
<Number>
<A ID="pgfId-1059703"></A>
Click OK.</Number>
</NumberList>
<EndList-root>
<A ID="pgfId-1059704"></A>
Codepoints that map to an SGML entity will now be serialized as the entity by default for requests against this App Server.</EndList-root>
<Heading-3>
<A ID="pgfId-1059401"></A>
<A ID="21695"></A>
Specifying SGML Mapping in an XQuery Program</Heading-3>
<Body>
<A ID="pgfId-1059402"></A>
You can specify SGML mappings for XML output in an XQuery program using the <code>
&lt;output-sgml-character-entities&gt;</code>
 option to the following XML-serializing APIs:</Body>
<Body-bullet>
<A ID="pgfId-1059403"></A>
<code>
xdmp:quote</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1059404"></A>
<code>
xdmp:save</code>
</Body-bullet>
<Body>
<A ID="pgfId-1059684"></A>
For details, see the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
 for these functions.</Body>
<Heading-2>
<A ID="pgfId-1059023"></A>
<A ID="99082"></A>
Specifying the Output Encoding</Heading-2>
<Body>
<A ID="pgfId-1059062"></A>
By default, MarkLogic Server outputs content in utf-8. You can specify a different output encodings, both on an App Server basis and on a per-query basis. This section describes those techniques, and includes the following parts:</Body>
<Body-bullet>
<A ID="pgfId-1059068"></A>
<A href="appserver-control.xml#id(86940)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Configuring App Server Output Encoding Setting</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1059072"></A>
<A href="appserver-control.xml#id(73416)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
XQuery Built-In For Specifying the Output Encoding</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1059024"></A>
<A ID="86940"></A>
Configuring App Server Output Encoding Setting</Heading-3>
<Body>
<A ID="pgfId-1059076"></A>
You can set the output encoding for an App Server using the Admin Interface or with the Admin API. You can set it to any supported character set (see <A href="../search-dev-guide/encodings_collations.xml#id(40354)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Collations and Character Sets By Language</Hyperlink>
</A> in the <A href="../search-dev-guide/encodings_collations.xml#id(40505)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Encodings and Collations</Hyperlink>
</A> chapter of the <Emphasis>
Search Developer's Guide</Emphasis>
).</Body>
<Body>
<A ID="pgfId-1059768"></A>
To configure output encoding for an App Server using the Admin Interface, perform the following steps:</Body>
<Number1>
<A ID="pgfId-1059769"></A>
In the Admin Interface, navigate to the App Server you want to configure (for example, Groups &gt; Default &gt; App Servers &gt; MyAppServer).</Number1>
<NumberList>
<Number>
<A ID="pgfId-1059770"></A>
Scroll down to the Output Encoding drop list (it is towards the bottom).</Number>
<Number>
<A ID="pgfId-1059771"></A>
Select the encoding you want. The settings correspond to different languages, as described in the table in <A href="../search-dev-guide/encodings_collations.xml#id(40354)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Collations and Character Sets By Language</Hyperlink>
</A> in the <A href="../search-dev-guide/encodings_collations.xml#id(40505)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Encodings and Collations</Hyperlink>
</A> chapter of the <Emphasis>
Search Developer's Guide</Emphasis>
.</Number>
<Number>
<A ID="pgfId-1059772"></A>
Click OK.</Number>
</NumberList>
<EndList-root>
<A ID="pgfId-1059773"></A>
By default, queries against this App Server will now be output in the specified encoding.</EndList-root>
<Heading-3>
<A ID="pgfId-1059077"></A>
<A ID="73416"></A>
XQuery Built-In For Specifying the Output Encoding</Heading-3>
<Body>
<A ID="pgfId-1059081"></A>
Use the following built-in functions to get and set the output encoding on a per-request basis:</Body>
<Body-bullet>
<A ID="pgfId-1059090"></A>
<code>
xdmp:get-response-encoding</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1059082"></A>
<code>
xdmp:set-response-encoding</code>
</Body-bullet>
<Body>
<A ID="pgfId-1059129"></A>
Additionally, you can specify the output encoding for XML output in an XQuery program using the <code>
&lt;output-encoding&gt;</code>
 option to the following XML-serializing APIs:</Body>
<Body-bullet>
<A ID="pgfId-1059130"></A>
<code>
xdmp:quote</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1059131"></A>
<code>
xdmp:save</code>
</Body-bullet>
<Body>
<A ID="pgfId-1059731"></A>
For details, see the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
 for these functions.</Body>
</XML>
