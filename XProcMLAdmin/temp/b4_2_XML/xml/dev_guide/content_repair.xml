<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="content_repair.css" type="text/css" charset="UTF-8"?>
<XML>
<TITLE> </TITLE><Heading-1>
<A ID="pgfId-1043425"></A>
Content Repair</Heading-1>
<pagenum>
<A ID="pgfId-1044427"></A>
47</pagenum>
<Body>
<A ID="pgfId-1043427"></A>
MarkLogic Server includes the ability to correct content that is not well-formed (according to the XML specification) at load time. MarkLogic Server can also be used to fix poorly or inconsistently structured content. This section discusses each of the MarkLogic Server native content repair capabilities and how they can be used in your environment.</Body>
<Body>
<A ID="pgfId-1043428"></A>
MarkLogic Server supports five different content repair models:</Body>
<Body-bullet>
<A ID="pgfId-1043429"></A>
<A href="content_repair.xml#id(38809)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
General-Purpose Tag Repair</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1043430"></A>
<A href="content_repair.xml#id(18755)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Empty Tag Auto-Close</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1043431"></A>
<A href="content_repair.xml#id(25903)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Schema-Driven Tag Repair</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1043432"></A>
<A href="content_repair.xml#id(16362)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Load-Time Default Namespace Assignment</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1043433"></A>
<A href="content_repair.xml#id(90924)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Load-Time Namespace Prefix Binding</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1043434"></A>
<A href="content_repair.xml#id(70220)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Query-Driven Content Repair</Hyperlink>
</A></Body-bullet>
<Body>
<A ID="pgfId-1043435"></A>
MarkLogic Server does not validate content against predetermined XSchema or DTDs.</Body>
<Heading-2>
<A ID="pgfId-1043436"></A>
<A ID="38809"></A>
General-Purpose Tag Repair</Heading-2>
<Body>
<A ID="pgfId-1043437"></A>
By default, MarkLogic Server applies a general-purpose stack-driven tag repair algorithm to every XML document loaded from an external source. The algorithm is triggered whenever the loader encounters a closing tag (for example, <code>
&lt;/tag&gt;</code>
) that does not match the most recently opened tag on the stack.</Body>
<Heading-3>
<A ID="pgfId-1043438"></A>
How General-Purpose Tag Repair Works</Heading-3>
<Body>
<A ID="pgfId-1043439"></A>
For example, consider the following simple markup document example:</Body>
<Code>
<A ID="pgfId-1043440"></A>
&lt;p&gt;This is &lt;b&gt;bold and &lt;i&gt;italic&lt;/i&gt;&lt;/b&gt; within the paragraph.&lt;/p&gt;</Code>
<Body>
<A ID="pgfId-1043441"></A>
Each of the variations below introduces a tagging error common to hand-coded markup:</Body>
<Code>
<A ID="pgfId-1043442"></A>
&lt;p&gt;This is &lt;b&gt;bold and &lt;i&gt;italic&lt;/b&gt; within the paragraph.&lt;/p&gt;</Code>
<Code>
<A ID="pgfId-1043443"></A>
&lt;p&gt;This is &lt;b&gt;bold and &lt;i&gt;italic&lt;/i&gt;&lt;/b&gt;&lt;/u&gt; within the paragraph.&lt;/p&gt;</Code>
<Body>
<A ID="pgfId-1043444"></A>
In the first variation, the italic element is never closed. And in the second, the underline element is never opened.</Body>
<Body>
<A ID="pgfId-1043445"></A>
When the MarkLogic Server encounters an unexpected closing tag, it performs one of the following actions:</Body>
<Number1>
<A ID="pgfId-1043446"></A>
If the QName of the unexpected closing tag (ie. both the tag's namespace and its localname) matches the QName of a tag opened earlier and not yet closed, the loader will automatically close all tags until the matching opening tag is closed.</Number1>
<Body-indent>
<A ID="pgfId-1043447"></A>
Consequently, in the first sample tagging error shown above, the loader will automatically close the italic element when it encounters the tag closing the bold element:</Body-indent>
<Code>
<A ID="pgfId-1043448"></A>
&lt;p&gt;This is &lt;b&gt;bold and &lt;i&gt;italic&lt;/i&gt;&lt;/b&gt; within the paragraph.&lt;/p&gt;</Code>
<Body-indent>
<A ID="pgfId-1043449"></A>
The bold characters in the markup shown above indicate the close tag dynamically inserted by the loader.</Body-indent>
<NumberList>
<Number>
<A ID="pgfId-1043450"></A>
If there is no match between the QName of the unexpected closing tag and all previously opened tags, the loader ignores the closing tag and proceeds.</Number>
</NumberList>
<Body-indent>
<A ID="pgfId-1043451"></A>
Consequently, in the second sample tagging error shown above, the loader will ignore the &quot;extra&quot; underline closing tag and proceed as if it were not present:</Body-indent>
<Code>
<A ID="pgfId-1043452"></A>
&lt;p&gt;This is &lt;b&gt;bold and &lt;i&gt;italic&lt;/i&gt;&lt;/b&gt;<Emphasis>
&lt;/u&gt;</Emphasis>
 within the paragraph.&lt;/p&gt;</Code>
<Body-indent>
<A ID="pgfId-1043453"></A>
 The italic tag shown above indicates the closing tag that the loader is ignoring.</Body-indent>
<EndList-root>
<A ID="pgfId-1043454"></A>
Both rules work together to repair even more complex situations. Consider the following variation, in which the bold and italic closing tags are mis-ordered:</EndList-root>
<Code>
<A ID="pgfId-1043455"></A>
&lt;p&gt;This is &lt;b&gt;bold and &lt;i&gt;italic&lt;/b&gt;&lt;/i&gt; within the paragraph.&lt;/p&gt;</Code>
<Body>
<A ID="pgfId-1043456"></A>
In this circumstance, the first rule automatically closes the italic element when the closing bold tag is encountered. When the closing italic tag is encountered, it is simply discarded as there are no previously opened italic tags still on the loader's stack. The result is more than likely what the markup author intended:</Body>
<Code>
<A ID="pgfId-1043457"></A>
&lt;p&gt;This is &lt;b&gt;bold and &lt;i&gt;italic<Bold>
&lt;/i&gt;</Bold>
&lt;/b&gt; within the paragraph.&lt;/p&gt;</Code>
<Heading-3>
<A ID="pgfId-1043458"></A>
Pitfalls of General-Purpose Tag Repair</Heading-3>
<Body>
<A ID="pgfId-1043459"></A>
While these two general repair rules produce sound results in most situations, their application can also lead to repairs that may not match the original intent. For example, consider the following two examples.</Body>
<Number1>
<A ID="pgfId-1043460"></A>
This snippet contains a markup error - the bold element is never closed.</Number1>
<Code>
<A ID="pgfId-1043461"></A>
&lt;p&gt;This is a &lt;b&gt;bold and &lt;i&gt;italic&lt;/i&gt; part of the paragraph.&lt;/p&gt;</Code>
<Body-indent>
<A ID="pgfId-1043462"></A>
The general-purpose repair algorithm will fix this problem by inserting a closing bold tag just in front of the closing paragraph tag, because this is the point at which it becomes apparent to the system that there is a markup problem:</Body-indent>
<Code>
<A ID="pgfId-1043463"></A>
&lt;p&gt;This is a &lt;b&gt;bold and &lt;i&gt;italic&lt;/i&gt; part of the paragraph.&lt;/b&gt;&lt;/p&gt;</Code>
<Body-indent>
<A ID="pgfId-1043464"></A>
In this situation, the entire remainder of the paragraph is emboldened, because it is not otherwise apparent to the system where else the tag should have been closed. In fact, for cases other than this simple example, even a human will not always be able to make the right decision.</Body-indent>
<NumberList>
<Number>
<A ID="pgfId-1043465"></A>
Rule 1 can also cause significant 'unwinding' of the stack if a tag, opened much earlier in the document, is mistakenly closed mid-document. Consider the following mark up error where <code>
&lt;/d&gt;</code>
 is mistyped as <code>
&lt;/b&gt;</code>
.</Number>
</NumberList>
<Code>
<A ID="pgfId-1043466"></A>
&lt;a&gt;
  &lt;b&gt;
    &lt;c&gt;
      &lt;d&gt;...content intended for d...&lt;/b&gt;
      ...content intended for c...
    &lt;/c&gt;
    ...content intended for b...
  &lt;/b&gt;
  ...content intended for a...
&lt;/a&gt;</Code>
<Body-indent>
<A ID="pgfId-1043467"></A>
The erroneous <code>
&lt;/b&gt;</code>
 tag triggers rule 1 and the system closes all intervening tags between <code>
&lt;b&gt;</code>
 and <code>
&lt;d&gt;</code>
. Rule 2 then discards the actual close tags for <code>
&lt;b&gt;</code>
 and <code>
&lt;c&gt;</code>
 that have now been made redundant (since they have been closed by rule 1). This results in an incorrectly 'flattened' document as shown below (some indentation and line breaks have been added for illustrative purposes):</Body-indent>
<Code>
<A ID="pgfId-1043468"></A>
<code>
&lt;a&gt;
  &lt;b&gt;
    &lt;c&gt;
      &lt;d&gt;...content intended for d...&lt;/d&gt;
    &lt;/c&gt;
  &lt;/b&gt;
  ...content intended for c...
  ...content intended for b...
  ...content intended for a...
&lt;/a&gt;</code>
</Code>
<EndList-root>
<A ID="pgfId-1043469"></A>
General-purpose tag repair is not always able to correctly repair structure problems, as shown in the two examples above. MarkLogic Server offers more advanced content repair capabilities that can be used to repair a wider range of problems, including the examples above. These advanced content repair capabilities and techniques are described in later sections of this document. </EndList-root>
<Heading-3>
<A ID="pgfId-1043470"></A>
Scope of Application</Heading-3>
<Body>
<A ID="pgfId-1043471"></A>
General-purpose tag repair is carried out on all documents loaded from external sources. This includes documents loaded using the XQuery built-in <code>
xdmp:document-load()</code>
 and the XDBC document insertion methods. XML content loaded using <code>
xdmp:document-insert()</code>
, <code>
xdmp:node-replace()</code>
, <code>
xdmp:node-insert-before()</code>
, <code>
xdmp:node-insert-after()</code>
 and <code>
xdmp:node-insert-child()</code>
, is not processed through general-purpose tag repair. For each of these functions, the XML node provided as a parameter is either dynamically-generated by the query itself (and is consequently guaranteed to be well-formed) or is explicitly defined within the XQuery code itself (in which case the query will not successfully be parsed for execution unless it is well-formed).</Body>
<Body>
<A ID="pgfId-1048503"></A>
Note that general-purpose tag repair will not insert a missing closing root element tag into an XML document. Previous (2.0 and earlier) versions of MarkLogic Server would repair missing root elements, making it effectively impossible to identify truncated source content. MarkLogic Server reports an error in these conditions.</Body>
<Heading-3>
<A ID="pgfId-1043473"></A>
Disabling General-Purpose Tag Repair</Heading-3>
<Body>
<A ID="pgfId-1043474"></A>
By default, the server attempts general-purpose tag repair for all documents loaded from external sources.</Body>
<Body>
<A ID="pgfId-1043475"></A>
MarkLogic Server allows the developer to disable general-purpose tag repair during any individual document load through an optional parameter to <code>
xdmp:document-load()</code>
, <code>
xdmp:unquote()</code>
 and XDBC's <code>
openDocInsertStream()</code>
 method. See the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
 or the XDBC javadocs for more details.</Body>
<Heading-2>
<A ID="pgfId-1043476"></A>
<A ID="18755"></A>
Empty Tag Auto-Close</Heading-2>
<Body>
<A ID="pgfId-1043477"></A>
The server can automatically close tags that are identified as empty tags in a schema. </Body>
<Body>
<A ID="pgfId-1043478"></A>
This approach addresses a common problem found in SGML and HTML documents. SGML and HTML both regard tags as markup rather than as the hierarchical element containers defined by the XML specification. In both the SGML and HTML worlds, it is quite acceptable to use a tag as an indication of some formatting directive, without any need to close the tag.</Body>
<Body>
<A ID="pgfId-1043479"></A>
For example, an <code>
&lt;hr&gt;</code>
 tag in an HTML document indicates a horizontal rule. Because there is no sense to containing anything within a horizontal rule, the tag is interpreted by browsers as an empty tag. Consequently, while HTML documents may be littered with <code>
&lt;hr&gt;</code>
 tags, you will rarely find a <code>
&lt;/hr&gt;</code>
 tag or even a <code>
&lt;hr/&gt;</code>
 tag unless someone has converted the HTML document to be XHTML-compliant. The same can frequently be said of <code>
&lt;img&gt;</code>
 and <code>
&lt;meta&gt;</code>
 tags, to name just two. In SGML documents, you can easily find <code>
&lt;pgbrk&gt;</code>
, <code>
&lt;xref&gt;</code>
 and <code>
&lt;graphic&gt;</code>
 used similarly.</Body>
<Body>
<A ID="pgfId-1043480"></A>
MarkLogic Server enables the developer to use a specially-constructed schema to identify empty tags that should be automatically closed at load-time. Applying this type of content repair enables you to avoid the false nesting of content within otherwise-unclosed empty tags that frequently results from the liberal use of these empty tags within SGML and HTML content.</Body>
<Heading-3>
<A ID="pgfId-1043481"></A>
What Empty Tag Auto-Close Does</Heading-3>
<Body>
<A ID="pgfId-1043482"></A>
For example, consider the following simple SGML document snippet:</Body>
<Code>
<A ID="pgfId-1043483"></A>
&lt;book&gt;
&lt;para&gt;This is the first paragraph.&lt;/para&gt;
&lt;pgbrk&gt;
&lt;para&gt;This paragraph has a cross-reference &lt;xref id=&quot;f563t001&quot;&gt; in some &lt;italic&gt;italic&lt;/italic&gt; text.&lt;/para&gt;
&lt;/book&gt; </Code>
<Body>
<A ID="pgfId-1043484"></A>
This snippet incorporates two tags, <code>
&lt;pgbrk&gt;</code>
 and <code>
&lt;xref&gt;</code>
, that are traditionally viewed as empty tags. However, working under default settings, MarkLogic Server will view each of these two tags as opening tags that will at some point later in the document be closed, and will consequently incorrectly view the following content as children of those tags. This will result in a falsely nested document (indentation and line breaks added for clarification):</Body>
<Code>
<A ID="pgfId-1043485"></A>
&lt;book&gt;
  &lt;para&gt;
    This is the first paragraph.
  &lt;/para&gt;
  &lt;pgbrk&gt;
    &lt;para&gt;
      This paragraph has a cross-reference 
      &lt;xref id=&quot;f563t001&quot;&gt;
        in some
        &lt;italic&gt;italic&lt;/italic&gt;
        text.
      &lt;/xref&gt;
    &lt;/para&gt;
  &lt;/pgbrk&gt;
&lt;/book&gt;</Code>
<Body>
<A ID="pgfId-1043486"></A>
The bold characters in the markup shown above indicate closing tags automatically inserted by the general-purpose tag repair algorithm.</Body>
<Body>
<A ID="pgfId-1043487"></A>
This example demonstrates how unclosed empty tags can distort the structure of a document.  Imagine how much worse this example could get if it had fifty <code>
&lt;pgbrk&gt;</code>
 tags in it.</Body>
<Body>
<A ID="pgfId-1043488"></A>
To understand the ramifications of this, consider how the markup applied above would be processed by a query that specifies an XPath such as <code>
/doc/para</code>
. The first paragraph will match this XPath, but the second will not, because it has been loaded incorrectly as the child of a pgbrk element. While alternative XPath expressions such as <code>
/doc//para</code>
 will gloss over this difference, it would be more desirable simply to load the content correctly in the first place (indentation and line breaks added for clarification):</Body>
<Code>
<A ID="pgfId-1043489"></A>
&lt;book&gt;
  &lt;para&gt;
    This is the first paragraph.
  &lt;/para&gt;
  &lt;pgbrk/&gt;
  &lt;para&gt;
    This paragraph has a cross-reference 
    &lt;xref id=&quot;f563t001&quot;/&gt;
    in some
    &lt;italic&gt;italic&lt;/italic&gt;
    text.
  &lt;/para&gt;
&lt;/book&gt;</Code>
<Heading-3>
<A ID="pgfId-1043490"></A>
How Empty Tag Auto-Close Works</Heading-3>
<Body>
<A ID="pgfId-1043491"></A>
Empty tag auto-close is a special case of schema-driven tag repair and is supported in all versions of MarkLogic Server.</Body>
<Body>
<A ID="pgfId-1043492"></A>
To take advantage of the empty tag auto-close functionality, you must first define a schema that describes which tags should be assumed to be empty tags. Given this information, when the XML loader is loading content from an external source, it will automatically close these tags as soon as they are encountered. If some of the specified tags are in fact accompanied by closing tags, these closing tags will be discarded by the general-purpose tag repair algorithm.</Body>
<Body>
<A ID="pgfId-1043493"></A>
Here is an example of a schema that instructs the loader to treat as empty tags any <code>
&lt;xref&gt;</code>
, <code>
&lt;graphic&gt;</code>
 and <code>
&lt;pgbrk&gt;</code>
 tags found in documents governed by the <code>
http://www.mydomain.com/sgml</code>
 namespace:</Body>
<Code>
<A ID="pgfId-1043494"></A>
&lt;xs:schema
  targetNamespace=&quot;http://www.mydomain.com/sgml&quot;
  xsi:schemaLocation=&quot;http://www.w3.org/2001/XMLSchema XMLSchema.xsd&quot;
  xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;
  &lt;xs:complexType name=&quot;empty&quot;/&gt;
  &lt;xs:element name=&quot;xref&quot; type=&quot;empty&quot;/&gt;
  &lt;xs:element name=&quot;graphic&quot; type=&quot;empty&quot;/&gt;
  &lt;xs:element name=&quot;pgbrk&quot; type=&quot;empty&quot;/&gt;
&lt;/xs:schema&gt;</Code>
<Body>
<A ID="pgfId-1043495"></A>
If the sample SGML document shown earlier were to be loaded under the control of this simple schema, it would be corrected as desired.</Body>
<Body>
<A ID="pgfId-1043496"></A>
To use either of these two schemas for content repair, two things are required:</Body>
<Body-bullet>
<A ID="pgfId-1043497"></A>
The schema must be loaded into MarkLogic Server.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1043498"></A>
The content to be loaded must properly reference the schema at load-time.</Body-bullet>
<Heading-3>
<A ID="pgfId-1043499"></A>
<A ID="70579"></A>
How to Perform Empty Tag Auto-Close</Heading-3>
<Body>
<A ID="pgfId-1043500"></A>
There are multiple ways to invoke the empty tag auto-close functionality. The recommended course of action is as follows:</Body>
<Number1>
<A ID="pgfId-1043501"></A>
Author a schema that specifies which tags should be treated as empty tags.  The simple schema shown above is a good starting point.</Number1>
<NumberList>
<Number>
<A ID="pgfId-1043502"></A>
Load the schema into MarkLogic Server. See <A href="loading_schemas.xml#id(68942)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Loading Schemas' on page&#160;23</A> for instructions on properly loading schemas in MarkLogic Server.</Number>
<Number>
<A ID="pgfId-1043503"></A>
Make sure that the content to be loaded references the namespace of the schema you have loaded. For the first simple schema shown above, the root element could take one of two forms.  In the first form, the document implicitly references the schema through its namespace:</Number>
</NumberList>
<Code>
<A ID="pgfId-1043504"></A>
&lt;document
  xmlns=&quot;http://www.mydomain.com/sgml&quot;&gt;
  ...
&lt;/document&gt;</Code>
<Body-indent>
<A ID="pgfId-1043505"></A>
MarkLogic Server automatically looks for matching schema whenever a document is loaded.  See <A href="loading_schemas.xml#id(68942)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Loading Schemas' on page&#160;23</A> for an in-depth discussion of the precedence rules that are applied in the event that multiple matching schemas are found.</Body-indent>
<Body-indent>
<A ID="pgfId-1043506"></A>
The following example shows how one of multiple matching schemas can be explicitly referenced by the document being loaded:</Body-indent>
<Code>
<A ID="pgfId-1043507"></A>
&lt;document
  xmlns=&quot;http://www.mydomain.com/sgml&quot;
  xsi:schemaLocation=&quot;http://www.mydomain.com/sgml /sch/SGMLEmpty.xsd&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
  ...
&lt;/document&gt;</Code>
<Body-indent>
<A ID="pgfId-1043508"></A>
The construct shown above explicitly references the schema stored at URI <code>
/sch/SGMLEmpty.xsd</code>
 in the current schema database. If there is no schema stored at that URI, or the schema stored at that URI has a target namespace other than <code>
http://www.mydomain.com/sgml</code>
, no schema will be used.</Body-indent>
<NumberList>
<Number>
<A ID="pgfId-1043509"></A>
Load the content using <code>
xdmp:document-load()</code>
 or any of the XDBC document insertion methods.</Number>
</NumberList>
<EndList-root>
<A ID="pgfId-1043510"></A>
After the content has been loaded, you can inspect it to see that the content repair has been performed. If auto-close repair has not been carried out, then you should troubleshoot the placement, naming and cross-referencing of your schema, as this is the most likely source of the problem.</EndList-root>
<Body>
<A ID="pgfId-1043511"></A>
If it is not feasible to modify the content so that it properly references a namespace in its header, there are other approaches that will yield the same result:</Body>
<Number1>
<A ID="pgfId-1043512"></A>
Author a schema that specifies which tags should be treated as empty tags. Because the root <code>
xs:schema</code>
 element lacks a <code>
targetNamespace</code>
 attribute, the document below specifies a schema that applies to documents loaded in the unnamed namespace: </Number1>
<Code>
<A ID="pgfId-1043513"></A>
&lt;xs:schema
  xsi:schemaLocation=&quot;http://www.w3.org/2001/XMLSchema XMLSchema.xsd&quot;
  xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;
  &lt;xs:complexType name=&quot;empty&quot;/&gt;
  &lt;xs:element name=&quot;xref&quot; type=&quot;empty&quot;/&gt;
  &lt;xs:element name=&quot;graphic&quot; type=&quot;empty&quot;/&gt;
  &lt;xs:element name=&quot;pgbrk&quot; type=&quot;empty&quot;/&gt;
&lt;/xs:schema&gt;</Code>
<NumberList>
<Number>
<A ID="pgfId-1043514"></A>
Load the schema into MarkLogic Server, remembering the URI name under which you store the schema. See <A href="loading_schemas.xml#id(68942)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Loading Schemas' on page&#160;23</A> for instructions on properly loading schema in MarkLogic Server.</Number>
<Number>
<A ID="pgfId-1043515"></A>
Construct an XQuery statement that temporarily imports the schema into the appropriate namespace and loads the content within that context. Following is a simple example of importing a schema into the unnamed namespace:</Number>
</NumberList>
<Code>
<A ID="pgfId-1043516"></A>
xquery version &quot;0.9-ml&quot;
import schema namespace &quot;myNS&quot; at &quot;schema-uri-you-specified-in-step-2&quot;;
xdmp:document-load(&quot;content-to-be-repaired.sgml&quot;, ...)</Code>
<Body-indent>
<A ID="pgfId-1043517"></A>
Be careful to restrict the content loading operations you carry out within the context of this <code>
import schema</code>
 directive, as all documents loaded in the unnamed namespace will be filtered through the empty tag auto close algorithm under the control of this schema.</Body-indent>
<Note>
<A ID="pgfId-1043518"></A>
The target namespace specified in the <code>
import schema</code>
 prolog statement and in the schema document itself must be the same, otherwise the schema import will fail silently.</Note>
<NumberList>
<Number>
<A ID="pgfId-1043519"></A>
Run the query shown above to load and repair the content.</Number>
</NumberList>
<Heading-3>
<A ID="pgfId-1043520"></A>
Scope of Application</Heading-3>
<Body>
<A ID="pgfId-1043521"></A>
Once a schema has been configured and loaded for empty tag auto-closing, any content that references that schema and is loaded from an external source will automatically be repaired as directed by that schema.</Body>
<Heading-3>
<A ID="pgfId-1043522"></A>
Disabling Empty Tag Auto-Close</Heading-3>
<Body>
<A ID="pgfId-1043523"></A>
There are several ways to turn off load-time empty-tag auto-closing:</Body>
<Number1>
<A ID="pgfId-1043524"></A>
Disable content repair at load-time using the appropriate parameter to <code>
xdmp:document-load()</code>
, <code>
xdmp:unquote()</code>
 or to the XDBC <code>
openDocInsertStream()</code>
 method.</Number1>
<NumberList>
<Number>
<A ID="pgfId-1043525"></A>
Remove the corresponding schema from the database and ensure that none of the content to be loaded in the future still references that schema.</Number>
<Number>
<A ID="pgfId-1043526"></A>
Modify the referenced schema to remove the empty tag definitions.</Number>
</NumberList>
<EndList-root>
<A ID="pgfId-1043527"></A>
Removing the schema from the database will not impact documents already loaded under the rubric of that schema, at least with respect to their empty tags being properly closed. To the extent that the schema in question contains other information about the content that is used during query processing, you should consider the removal of the schema from the database carefully.</EndList-root>
<Heading-2>
<A ID="pgfId-1043528"></A>
<A ID="25903"></A>
Schema-Driven Tag Repair</Heading-2>
<Body>
<A ID="pgfId-1043529"></A>
MarkLogic Server supports the use of schemas for empty tag auto-closing and for more complex schema-driven tag repair.</Body>
<Body>
<A ID="pgfId-1043530"></A>
This functionality allows the developer to provide, through a schema, a set of general rules that govern how various elements interact hierarchically within a document. This can help with more complex content repair situations.</Body>
<Heading-3>
<A ID="pgfId-1043531"></A>
What Schema-Driven Tag Repair Does</Heading-3>
<Body>
<A ID="pgfId-1043532"></A>
For example, consider the following SGML document snippet:</Body>
<Code>
<A ID="pgfId-1043533"></A>
&lt;book&gt;
&lt;section&gt;&lt;para&gt;This is a paragraph in section 1.
&lt;section&gt;&lt;para&gt;This is a paragraph in section 2.
&lt;/book&gt;</Code>
<Body>
<A ID="pgfId-1043534"></A>
This snippet illustrates one of the key challenges created by interpreting markup languages as XML. Under default settings, the server will repair and load this content as follows (indentation and line breaks added for clarification):</Body>
<Code>
<A ID="pgfId-1043535"></A>
&lt;book&gt;
&#160;&#160;&lt;section&gt;
&#160;&#160;&#160;&#160;&lt;para&gt;
&#160;&#160;&#160;&#160;This is a paragraph in section 1.
&#160;&#160;&#160;&#160;&#160;&#160;&lt;section&gt;       
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;para&gt;This is a paragraph in section 2.<Bold>
&lt;/para&gt;
</Bold>
&#160;&#160;&#160;&#160;&#160;&#160;<Bold>
&lt;/section&gt;</Bold>
 
&#160;&#160;&#160;&#160;<Bold>
&lt;/para&gt;
</Bold>
&#160;&#160;<Bold>
&lt;/section&gt;
</Bold>
&lt;/book&gt;</Code>
<Body>
<A ID="pgfId-1043536"></A>
The repaired content shown above is almost certainly not what the author intended. However, it is all that the server can accomplish using only general-purpose tag repair.</Body>
<Body>
<A ID="pgfId-1043537"></A>
Schema-driven content repair improves the situation by allowing the developer to indicate, via a schema, constraints in the relationships between elements. In this case, the developer may indicate that a <code>
&lt;section&gt;</code>
 element may only contain <code>
&lt;para&gt;</code>
 elements. Therefore, a <code>
&lt;section&gt;</code>
 element cannot be a child of another <code>
&lt;section&gt;</code>
 element. In addition, the developer can indicate that <code>
&lt;para&gt;</code>
 element is a simple type that only contains text. Armed with this knowledge, the server can improve the quality of content repair that it performs. For example, the server can use the schema to know that it should check to see if there is an open <code>
&lt;section&gt;</code>
 element on the stack whenever it encounters a new <code>
&lt;section&gt;</code>
 element. </Body>
<Body>
<A ID="pgfId-1043538"></A>
The resulting repair of the SGML document snippet shown above will be closer to the original intent of the document author: </Body>
<Code>
<A ID="pgfId-1043539"></A>
&lt;book&gt;
  &lt;section&gt;
    &lt;para&gt;
      This is a paragraph in section 1.
    &lt;/para&gt;
  &lt;/section&gt;
  &lt;section&gt;       
    &lt;para&gt;
      This is a paragraph in section 2.
    &lt;/para&gt;
  &lt;/section&gt;   
&lt;/book&gt;How it works</Code>
<Body>
<A ID="pgfId-1043540"></A>
To take advantage of schema-driven tag repair, you must first define a schema that describes the constraints on the relationships between elements. Given this information, when the XML loader is loading content from an external source, it will automatically close tags still open on its stack when it encounters an open tag that would violate the specified constraints.</Body>
<Body>
<A ID="pgfId-1043541"></A>
Unlike general-purpose tag repair, which is triggered by unexpected closing tags, schema-driven tag repair is triggered by unexpected opening tags, so the two different repair models interoperate cleanly. In the worst case, schema-driven tag repair may, as directed by the governing schema for the document being loaded, automatically close an element sooner than that element is explicitly closed in the document itself. This case will only occur when the relationship between elements in the document is at odds with the constraints described in the schema, in which case the schema is used as the dominating decision factor.</Body>
<Body>
<A ID="pgfId-1043542"></A>
The following is an example of a schema that specifies the following constraints:</Body>
<Body-bullet>
<A ID="pgfId-1043543"></A>
<code>
&lt;book&gt;</code>
 elements in the <code>
http://www.mydomain.com/sgml</code>
 namespace can only contain <code>
&lt;section&gt;</code>
 elements.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1043544"></A>
<code>
&lt;section&gt;</code>
 elements in the <code>
http://www.mydomain.com/sgml</code>
 namespace can only contain <code>
&lt;para&gt;</code>
 elements.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1043545"></A>
<code>
&lt;para&gt;</code>
 elements in the <code>
http://www.mydomain.com/sgml</code>
 namespace can only contain text.</Body-bullet>
<Code>
<A ID="pgfId-1043546"></A>
&lt;xs:schema
  targetNamespace=&quot;http://www.mydomain.com/sgml&quot;
  xsi:schemaLocation=&quot;http://www.w3.org/2001/XMLSchema XMLSchema.xsd&quot;
  xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;

  &lt;xs:complexType name=&quot;book&quot;&gt;
    &lt;xs:choice minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;
      &lt;xs:element ref=&quot;section&quot;/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;</Code>
<Code>
<A ID="pgfId-1043547"></A>
  &lt;xs:complexType name=&quot;section&quot;&gt;
    &lt;xs:choice minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;
      &lt;xs:element ref=&quot;para&quot;/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;</Code>
<Code>
<A ID="pgfId-1043548"></A>
  &lt;xs:element name=&quot;book&quot; type=&quot;book&quot;/&gt;
  &lt;xs:element name=&quot;section&quot; type=&quot;section&quot;/&gt;
  &lt;xs:element name=&quot;para&quot; type=&quot;xs:string&quot;/&gt;
&lt;/xs:schema&gt;</Code>
<Body-indent>
<A ID="pgfId-1043549"></A>
If the sample SGML document shown above were to be loaded under the control of this simple schema, it would be corrected as desired.</Body-indent>
<Body>
<A ID="pgfId-1043550"></A>
To make this happen, two things are required:</Body>
<Body-bullet>
<A ID="pgfId-1043551"></A>
The schema must be loaded into MarkLogic Server.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1043552"></A>
The content to be loaded must properly reference this schema at load-time.</Body-bullet>
<Heading-3>
<A ID="pgfId-1043553"></A>
Loading Content with Schema-Driven Tag Repair</Heading-3>
<Body>
<A ID="pgfId-1043554"></A>
As with many such things, there are multiple ways to perform schema-driven correction. The recommended course of action is as follows:</Body>
<Number1>
<A ID="pgfId-1043555"></A>
Author a schema that describes the relationships between the elements.</Number1>
<NumberList>
<Number>
<A ID="pgfId-1043556"></A>
Load the schema into MarkLogic Server. See <A href="loading_schemas.xml#id(68942)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Loading Schemas' on page&#160;23</A> for instructions on properly loading schema in MarkLogic Server.</Number>
<Number>
<A ID="pgfId-1043557"></A>
Ensure that the root element of the content to be loaded properly references the appropriate schema. See <A href="content_repair.xml#id(70579)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'How to Perform Empty Tag Auto-Close' on page&#160;32</A> for examples of referencing schema from within content.</Number>
<Number>
<A ID="pgfId-1043558"></A>
Load the content using <code>
xdmp:document-load()</code>
 or any of the XDBC document insertion methods.</Number>
</NumberList>
<EndList-root>
<A ID="pgfId-1043559"></A>
After the content has been loaded, you can inspect it to see that the content repair has been performed. If the appropriate content repair has not occurred, then you should troubleshoot the placement, naming and cross-referencing of your schema.</EndList-root>
<Body>
<A ID="pgfId-1043560"></A>
If it is not feasible to modify the content so that it properly references the schema in its header, there are other approaches that will yield the same result:</Body>
<Number1>
<A ID="pgfId-1043561"></A>
Author a schema that describes the relationships between the elements, and omit a <code>
targetNamespace</code>
 attribute from its <code>
xs:schema</code>
 root element.</Number1>
<NumberList>
<Number>
<A ID="pgfId-1043562"></A>
Load the schema into MarkLogic Server, remembering the URI name under which you store the schema. See <A href="loading_schemas.xml#id(68942)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Loading Schemas' on page&#160;23</A> for instructions on properly loading schema in MarkLogic Server.</Number>
<Number>
<A ID="pgfId-1043563"></A>
Construct an XQuery statement that temporarily imports the schema into the appropriate namespace and loads the content within that context. Following is a simple example of importing a schema into the unnamed namespace:</Number>
</NumberList>
<Code>
<A ID="pgfId-1043564"></A>
xquery version &quot;0.9-ml&quot;
import schema namespace &quot;myNS&quot; at &quot;schema-uri-you-specified-in-step-1&quot;;
xdmp:document-load(&quot;content-to-be-repaired.sgml&quot;, ...)</Code>
<Body-indent>
<A ID="pgfId-1043565"></A>
Be careful to restrict the content loading operations you carry out within the context of this <code>
import schema</code>
 directive, as all documents loaded will be filtered through the same schema-driven content repair algorithm.</Body-indent>
<Note>
<A ID="pgfId-1043566"></A>
The target namespace specified in the <code>
import schema</code>
 prolog statement and in the schema document itself must be the same, otherwise the schema import will fail silently.</Note>
<NumberList>
<Number>
<A ID="pgfId-1043567"></A>
Run the query shown above to load and repair the content.</Number>
</NumberList>
<Heading-3>
<A ID="pgfId-1043568"></A>
Scope of Application</Heading-3>
<Body>
<A ID="pgfId-1043569"></A>
Once a schema has been configured and loaded for schema-driven tag repair, any content that references that schema and is loaded from an external source will automatically be repaired as directed by that schema.</Body>
<Heading-3>
<A ID="pgfId-1043570"></A>
Disabling Schema-Driven Tag Repair</Heading-3>
<Body>
<A ID="pgfId-1043571"></A>
There are several ways to turn off load-time schema-driven correction:</Body>
<Number1>
<A ID="pgfId-1043572"></A>
Disable content repair at load-time using the appropriate parameter to <code>
xdmp:document-load()</code>
, <code>
xdmp:unquote()</code>
 or to XDBC's <code>
openDocInsertStream()</code>
 method.</Number1>
<NumberList>
<Number>
<A ID="pgfId-1043573"></A>
Remove the corresponding schema from the database and ensure that none of the content to be loaded in the future still references that schema.</Number>
<Number>
<A ID="pgfId-1043574"></A>
Modify the referenced schema to remove the empty tag definitions.</Number>
</NumberList>
<EndList-root>
<A ID="pgfId-1043575"></A>
Removing the schema from the database will not impact documents already loaded under the rubric of that schema. To the extent that the schema in question contains other information about the content that is used during query processing, you should consider the removal of the schema from the database carefully.</EndList-root>
<Heading-2>
<A ID="pgfId-1043576"></A>
<A ID="16362"></A>
Load-Time Default Namespace Assignment</Heading-2>
<Body>
<A ID="pgfId-1043577"></A>
When documents are loaded into MarkLogic Server, every element is stored with a complete QName comprised of a namespace URI and a localname. </Body>
<Body>
<A ID="pgfId-1043578"></A>
However, many XML files are authored without specifying a default namespace or a namespace for any of their elements. When these files are loaded from external sources into MarkLogic Server, the server applies the default unnamed namespace to all the nodes that do not have an associated namespace.</Body>
<Body>
<A ID="pgfId-1043579"></A>
However, in some situations, this is not the desired result. Once the document has been loaded without a specified namespace, it is difficult to remap each QName to a different namespace. The developer would rather have the document loaded into MarkLogic Server with the desired default namespace in the first place.</Body>
<Body>
<A ID="pgfId-1043580"></A>
The best way to specify a default namespace for a document is by adding a default namespace attribute to the document's root node directly. When that is not possible, MarkLogic Server's load-time namespace substitution capability offers a good solution. You can specify a default namespace for the document at load-time, provided that the document root node does not already contain a default namespace specification.</Body>
<Note>
<A ID="pgfId-1043581"></A>
This function is performed as described below if a default namespace is specified at load time, even if content repair is turned off.</Note>
<Heading-3>
<A ID="pgfId-1043582"></A>
How Default Namespace Assignments Work</Heading-3>
<Body>
<A ID="pgfId-1043583"></A>
The <code>
xdmp:document-load()</code>
 function and the XDBC document insertion method both allow the developer to optionally specify a namespace as the default namespace for an individual document loading operation.</Body>
<Body>
<A ID="pgfId-1043584"></A>
The server uses that namespace definition as follows:</Body>
<Number1>
<A ID="pgfId-1043585"></A>
If the root node of the document does not contain the default namespace attribute, the server uses the provided namespace as the default namespace for the root node. The appropriate namespaces of descendant nodes are then determined through the standard namespace rules.</Number1>
<NumberList>
<Number>
<A ID="pgfId-1043586"></A>
If the root node of the document incorporates a default namespace attribute, the server ignores the provided namespace.</Number>
</NumberList>
<EndList-root>
<A ID="pgfId-1043587"></A>
Note that rule 2 means that the default namespace provided at load time cannot be used to override an explicitly specified default namespace at the root element</EndList-root>
<Heading-3>
<A ID="pgfId-1043588"></A>
Scope of Application</Heading-3>
<Body>
<A ID="pgfId-1043589"></A>
You can optionally specify default namespaces at load-time as a parameter to <code>
xdmp:document-load()</code>
 and to the XDBC <code>
openDocInsertStream()</code>
 method. See the corresponding documentation for further details. All other methods for loading, updating or replacing content in the database do not have access to this functionality.</Body>
<Heading-2>
<A ID="pgfId-1043590"></A>
<A ID="90924"></A>
Load-Time Namespace Prefix Binding</Heading-2>
<Body>
<A ID="pgfId-1043591"></A>
The original XML specifications allow the use of colons in element names e.g. <code>
&lt;myprefix:a&gt;</code>
. However, according to the XML Namespace specifications (developed after the initial XML specifications), the string before a colon in an element name is interpreted as a namespace prefix. The use of prefixes that are not bound to namespaces is deemed as non-compliant with the XML Namespace specifications. </Body>
<Body>
<A ID="pgfId-1044136"></A>
Prior to version 2.1, MarkLogic Server drops unresolved prefixes from documents loaded into the database in order to conform to the XML Namespace specifications. Consider a document named <code>
mybook.xml</code>
 that contains the following content:</Body>
<Code>
<A ID="pgfId-1044137"></A>
&lt;publisher:book&gt;
  &lt;section&gt;
    This is a section.
  &lt;/section&gt;
&lt;/publisher:book&gt;</Code>
<Body>
<A ID="pgfId-1043594"></A>
If publisher is not bound to any namespace, <code>
mybook.xml</code>
 will be loaded into the database as: </Body>
<Code>
<A ID="pgfId-1043595"></A>
&lt;book&gt;
  &lt;section&gt;
    This is a section.
  &lt;/section&gt;
&lt;book&gt;</Code>
<Body>
<A ID="pgfId-1044149"></A>
Starting in 2.1, MarkLogic Server supports more powerful correction of XML documents with unresolved namespace bindings. If content repair is on, <code>
mybook.xml</code>
 will be loaded with a namespace binding added for the publisher prefix.</Body>
<Code>
<A ID="pgfId-1043597"></A>
&lt;publisher:book 
 xmlns:publisher=&quot;appropriate namespace-see details below&quot;&gt;
  &lt;section&gt;
    This is a section.
  &lt;/section&gt;
&lt;/publisher:book&gt; </Code>
<Body>
<A ID="pgfId-1043598"></A>
If content repair is off, MarkLogic Server will return an error if unresolved namespace prefixes are encountered at load time.</Body>
<Heading-3>
<A ID="pgfId-1043599"></A>
How Load-Time Namespace Prefix Binding Works</Heading-3>
<Body>
<A ID="pgfId-1043600"></A>
If content repair is on, MarkLogic Server allows a developer to create namespace bindings at load time for namespace prefixes that would otherwise be unresolved.</Body>
<Body>
<A ID="pgfId-1043601"></A>
Namespace prefixes are resolved using the rules below. The rules are listed in order of precedence: </Body>
<Number1>
<A ID="pgfId-1043602"></A>
If the prefix is explicitly bounded in the document, that binding is retained. For example, in the example below, the binding for publisher to <code>
&quot;http://publisherA.com&quot;</code>
 is specified in the document and is retained.</Number1>
<Code>
<A ID="pgfId-1043603"></A>
&lt;publisher:book xmlns:publisher=&quot;http://publisherA.com&quot;&gt;
  &lt;section&gt;
    This is a section.
  &lt;/section&gt;
&lt;/publisher:book&gt; </Code>
<NumberList>
<Number>
<A ID="pgfId-1043604"></A>
If the prefix is declared in the XQuery environment, that binding is used. Suppose that <code>
mybook.xml</code>
, the document being loaded, contains the following content:</Number>
</NumberList>
<Code>
<A ID="pgfId-1043605"></A>
&lt;publisher:book&gt;
  &lt;section&gt;
    This is a section.
  &lt;/section&gt;
&lt;/publisher:book&gt;</Code>
<Body-indent>
<A ID="pgfId-1043606"></A>
In addition, suppose that publisher is bound to <code>
http://publisherB.com</code>
 in the XQuery environment:</Body-indent>
<Code>
<A ID="pgfId-1043607"></A>
declare namespace publisher = &quot;http://publisherB.com&quot;</Code>
<Code>
<A ID="pgfId-1043608"></A>
xdmp:document-load(&quot;mybook.xml&quot;)</Code>
<Body-indent>
<A ID="pgfId-1043609"></A>
The code snippet will load the <code>
mybook.xml</code>
 as:</Body-indent>
<Code>
<A ID="pgfId-1043610"></A>
&lt;publisher:book xmlns:publisher=&quot;http://publisherB.com&quot;&gt;
  &lt;section&gt;
    This is a section.
  &lt;/section&gt;
&lt;/publisher:book&gt;</Code>
<Note>
<A ID="pgfId-1043611"></A>
This does not apply for XDBC document insertion methods.</Note>
<NumberList>
<Number>
<A ID="pgfId-1043612"></A>
If the prefix is declared in the Admin Interface for the HTTP or XDBC server through which the document is loaded, that binding is used. </Number>
</NumberList>
<Body-indent>
<A ID="pgfId-1048634"></A>
For example, imagine a scenario in which the namespace prefix publisher is defined on the HTTP server named Test.</Body-indent>
<Body-indent>
<A ID="pgfId-1048635"></A>
<IMAGE xml:link="simple" href="images/namespace.gif" show="embed" actuate="auto"/>
</Body-indent>
<Body-indent>
<A ID="pgfId-1048636"></A>
Then, suppose that the following code snippet is executed on Test:</Body-indent>
<Code>
<A ID="pgfId-1043619"></A>
xdmp:document-load(&quot;mybook.xml&quot;)</Code>
<Body-indent>
<A ID="pgfId-1043620"></A>
The initial document <code>
mybook.xml</code>
 as shown in the second case will be loaded as:</Body-indent>
<Code>
<A ID="pgfId-1043621"></A>
&lt;publisher:book xmlns:publisher=&quot;http://publisherC.com&quot;&gt;
  &lt;section&gt;
    This is a section.
  &lt;/section&gt;
&lt;/publisher:book&gt;</Code>
<NumberList>
<Number>
<A ID="pgfId-1043622"></A>
If no binding for the prefix is found, the server creates a namespace that is the same as the prefix and binds it to the prefix. In this instance, <code>
mybook.xml</code>
 will be loaded as:</Number>
</NumberList>
<Code>
<A ID="pgfId-1043623"></A>
&lt;publisher:book xmlns:publisher=&quot;publisher&quot;&gt;
  &lt;section&gt;
    This is a section.
  &lt;/section&gt;
&lt;/publisher:book&gt;</Code>
<Heading-3>
<A ID="pgfId-1043624"></A>
<A ID="94092"></A>
Interaction with Load-Time Default Namespace Assignment</Heading-3>
<Body>
<A ID="pgfId-1043625"></A>
While both load-time default namespace assignment and load-time namespace prefix binding involve document namespaces, the two features work independently. The former allows the assignment of a default namespace at the root element level, while the latter creates bindings for namespaces that are otherwise unresolved. </Body>
<Body>
<A ID="pgfId-1043626"></A>
Consider the examples below:</Body>
<Number1>
<A ID="pgfId-1043627"></A>
This document has neither a binding for the <code>
publisher</code>
 prefix, nor a default namespace.</Number1>
<Code>
<A ID="pgfId-1043628"></A>
&lt;publisher:book&gt;
  &lt;section&gt;
    This is a section.
  &lt;/section&gt;
&lt;/publisher:book&gt;</Code>
<Body-indent>
<A ID="pgfId-1043629"></A>
Suppose a default namespace <code>
http://publisher.com/default-namespace</code>
 is specified at load time, and the publisher prefix resolves to <code>
http://publisher.com/prefix</code>
 according to the rules described in the previous section. The document will be loaded as:</Body-indent>
<Code>
<A ID="pgfId-1043630"></A>
&lt;publisher:book xmlns:publisher=&quot;http://publisher.com/prefix&quot; 
 xmlns=&quot;http://publisher.com/default-namespace&quot;&gt;
  &lt;section&gt;
    This is a section.
  &lt;/section&gt;
&lt;/publisher:book&gt;</Code>
<Body-indent>
<A ID="pgfId-1043631"></A>
In this case, <code>
&lt;book&gt;</code>
 is in the <code>
&quot;http://publisher.com/prefix&quot;</code>
 namespace, while <code>
&lt;section&gt;</code>
 is in the <code>
&quot;http://publisher.com/default-namespace&quot;</code>
 namespace.</Body-indent>
<NumberList>
<Number>
<A ID="pgfId-1043632"></A>
This document has a binding for the <code>
publisher</code>
 prefix, but does not specify a default namespace in the root node.</Number>
</NumberList>
<Code>
<A ID="pgfId-1043633"></A>
&lt;publisher:book xmlns:publisher=&quot;http://publisher.com/prefix&quot;&gt;
  &lt;section&gt;
    This is a section.
  &lt;/section&gt;
&lt;/publisher:book&gt;</Code>
<Body-indent>
<A ID="pgfId-1043634"></A>
If <code>
http://publisher.com/default-namespace</code>
 is specified as the default namespace at load time, the loaded document will be the same as the document loaded in the example above.</Body-indent>
<NumberList>
<Number>
<A ID="pgfId-1043635"></A>
This document specifies a default namespace, but does not contain a binding for the publisher prefix, this time, associated with the <code>
&lt;section&gt;</code>
 element.</Number>
</NumberList>
<Code>
<A ID="pgfId-1043636"></A>
&lt;book xmlns=&quot;http://publisher.com/original-namespace&quot;&gt;
  &lt;publisher:section&gt;
    This is a section.
    &lt;paragraph&gt;
      This is a paragraph.
    &lt;/paragraph&gt;
  &lt;/publisher:section&gt;
&lt;/book&gt;</Code>
<Body-indent>
<A ID="pgfId-1043637"></A>
If a default namespace <code>
http://publisher.com/default-namespace</code>
 is specified at load time, it will be ignored. Assume that publisher resolves to <code>
publisher</code>
. The document will be loaded as shown below:</Body-indent>
<Code>
<A ID="pgfId-1043638"></A>
&lt;book xmlns=&quot;http://publisher.com/original-namespace&quot;&gt;
  &lt;publisher:section xmlns:publisher=&quot;publisher&quot;&gt;
    This is a section.
    &lt;paragraph&gt;
      This is a paragraph.
    &lt;/paragraph&gt;
  &lt;/publisher:section&gt;
&lt;/book&gt;</Code>
<EndList-root>
<A ID="pgfId-1043639"></A>
In this case, the <code>
&lt;book&gt;</code>
 and <code>
&lt;paragraph&gt;</code>
 elements are in the default namespace <code>
http://publisher.com/original-namespace</code>
, while the <code>
&lt;section&gt;</code>
 element is in the <code>
publisher</code>
 namespace.</EndList-root>
<Heading-3>
<A ID="pgfId-1043640"></A>
Scope of Application</Heading-3>
<Body>
<A ID="pgfId-1043641"></A>
Load-time namespace prefix binding is carried out on all documents loaded from external sources. This includes documents loaded using the XQuery built-in <code>
xdmp:document-load()</code>
 and the XDBC document insertion methods. </Body>
<Heading-3>
<A ID="pgfId-1043642"></A>
Disabling Load-Time Namespace Prefix Binding</Heading-3>
<Body>
<A ID="pgfId-1043643"></A>
By default, the server attempts to create bindings for unresolved namespace prefixes as a form of content repair for all documents loaded from external sources.</Body>
<Body>
<A ID="pgfId-1043644"></A>
MarkLogic Server allows you to disable content repair during any individual document load through an optional parameter to <code>
xdmp:document-load()</code>
, <code>
xdmp:unquote()</code>
 and XDBC's <code>
openDocInsertStream()</code>
 method. See the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
 or the XDBC javadocs for more details.</Body>
<Heading-2>
<A ID="pgfId-1043645"></A>
<A ID="70220"></A>
Query-Driven Content Repair</Heading-2>
<Body>
<A ID="pgfId-1043646"></A>
All the content repair models described above influence the content as it is loaded, trying to ensure that the structure of the poorly or inconsistently formatted content is as close to the author's intent as possible when it is first stored in the database.</Body>
<Body>
<A ID="pgfId-1043647"></A>
When a situation requires content repair that is beyond the scope of some combination of these four approaches, it is important to remember that MarkLogic Server's schema-independent core makes XQuery itself a powerful content repair mechanism.</Body>
<Body>
<A ID="pgfId-1043648"></A>
Once a document has been loaded into MarkLogic Server, queries can be written to specifically restructure that content as required, without needing to reconfigure the database in any way. There are two fundamental approaches to query-driven content repair: point repair and document walkers:</Body>
<Heading-3>
<A ID="pgfId-1043649"></A>
Point Repair</Heading-3>
<Body>
<A ID="pgfId-1043650"></A>
Point repair uses XPath-based queries to identify document subtrees of interest, create repaired content structures from the source content, and then call <code>
xdmp:node-replace()</code>
 to replace the document subtree of interest. A simple example of such a query is shown below:</Body>
<Code>
<A ID="pgfId-1043651"></A>
for $node-to-be-repaired in doc($uri-to-be-repaired)//italic
return
  xdmp:node-replace($node-to-be-repaired,
    &lt;i&gt;{ $node-to-be-repaired/* }&lt;/i&gt;)</Code>
<Body>
<A ID="pgfId-1043652"></A>
This sample code finds every element with localname italic in the default element namespace and changes its QName to localname i in the default element namespace. All of the element's attributes and descendants are inherited as is.</Body>
<Body>
<A ID="pgfId-1043653"></A>
An important constraint of the XQuery shown above lies in its assumption that italic elements cannot be descendants of other italic elements, a constraint that should be enforced at load-time using schema-driven content repair. If such a situation occurs in the document specified by $uri-to-be-repaired, the above XQuery will generate an error.</Body>
<Heading-3>
<A ID="pgfId-1043654"></A>
Document Walkers</Heading-3>
<Body>
<A ID="pgfId-1043655"></A>
Document walkers use recursive descent document processing functions written in XQuery to traverse either the entire document or a subtree within it, create a transformed (and appropriately repaired) version of the document, and then call <code>
xdmp:document-insert()</code>
 or <code>
xdmp:node-replace()</code>
 to place the repaired content back into the database.</Body>
<Body>
<A ID="pgfId-1043656"></A>
Queries involving document traversal are typically more complex than point repair queries, because they deal with larger overall document context. Because they can also traverse the entire document, the scope of repairs that they can address is also significantly broader.</Body>
<Body>
<A ID="pgfId-1043657"></A>
The <code>
walk-tree()</code>
 function shown below uses a recursive descent parser to traverse the entire document:</Body>
<Code>
<A ID="pgfId-1053359"></A>
xquery version &quot;1.0-ml&quot;;
declare function local:walk-tree(
  $node as node())
as node()
{
  if (xdmp:node-kind($node) = &quot;element&quot;) then
    (: Reconstruct node and its attributes; descend to its children :)
    element { fn:node-name($node) }  {
      $node/@*,
      for $child-node in $node/node()
      return
        local:walk-tree($child-node)
    }
  else if (xdmp:node-kind($node) = &quot;comment&quot; or
           xdmp:node-kind($node) = &quot;processing-instruction&quot; or
           xdmp:node-kind($node) = &quot;text&quot;) then
    (: Return the node as is :)
    $node
  else if (xdmp:node-kind($node) = &quot;document&quot;) then
    document {
    (: Start descent from the document node's children :)
       for $child-node in $node/node()
       return
         local:walk-tree($child-node)
    }
  else
    (: Should never get here :) 
    fn:error(
      fn:concat(&quot;Error:  Could not process node of type '&quot;,
             xdmp:node-kind($node), &quot;'&quot;)
    )
};

let $node := text {&quot;hello&quot;}
return
local:walk-tree($node)
(: returns the text node containing the string &quot;hello&quot; :)</Code>
<Body>
<A ID="pgfId-1043659"></A>
This function can be used as the starting point for any content repair query that needs to walk the entire document in order to perform its repair. By inserting further checks in each of the various clauses at will, this function can transform both the structure and the content at will. For example, consider the following modification of the first if clause:</Body>
<Code>
<A ID="pgfId-1043660"></A>
if (xdmp:node-kind($node) = &quot;element&quot;) then
  (: Reconstruct node and its attributes; descend to its children :)
  element { 
    if (fn:local-name($node) != &quot;italic&quot;) then
      fn:node-name($node)
    else
      fn:QName(fn:namespace-uri($node), &quot;i&quot;)
  } {
    $node/@*,
    for $child-node in $node/node()
    return
      local:walk-tree($child-node)
  }</Code>
<Body>
<A ID="pgfId-1043661"></A>
Inserting this code into the <code>
walk-tree()</code>
 function will enable the function to traverse a document, finding any element whose local-name is <code>
italic</code>
, regardless of that element's namespace, and change that element's local-name to <code>
i</code>
, keeping its namespace unchanged.</Body>
<Body>
<A ID="pgfId-1043662"></A>
You can use the above document walker as the basis for complex content transformations, effecting content repair using the database itself as the repair tool once the content has been loaded into the database.</Body>
<Body>
<A ID="pgfId-1053635"></A>
Another common design pattern for recursive descent is to use a <code>
typeswitch</code>
 expression. For details, see <A href="typeswitch.xml#id(37159)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Transforming XML Structures With a Recursive typeswitch Expression' on page&#160;86</A>.</Body>
</XML>
