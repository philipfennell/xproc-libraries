<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="properties.css" type="text/css" charset="UTF-8"?>
<XML>
<TITLE> </TITLE><Heading-1>
<A ID="pgfId-1044036"></A>
<A ID="78944"></A>
Properties Documents and Directories</Heading-1>
<pagenum>
<A ID="pgfId-1048834"></A>
111</pagenum>
<Body>
<A ID="pgfId-1045598"></A>
This chapter describes properties documents and directories in MarkLogic Server. It includes the following sections:</Body>
<Body-bullet>
<A ID="pgfId-1045599"></A>
<A href="properties.xml#id(19516)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Properties Documents</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1049424"></A>
<A href="properties.xml#id(49935)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Using Properties for Document Processing</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1045603"></A>
<A href="properties.xml#id(36559)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Directories</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1048399"></A>
<A href="properties.xml#id(83257)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Permissions On Properties and Directories</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1045922"></A>
<A href="properties.xml#id(58787)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Example: Directory and Document Browser</Hyperlink>
</A></Body-bullet>
<Heading-2>
<A ID="pgfId-1045604"></A>
<A ID="19516"></A>
Properties Documents</Heading-2>
<Body>
<A ID="pgfId-1045608"></A>
A <Emphasis>
properties document</Emphasis>
 is an XML document that shares the same URI with a document in a database. Every document can have a corresponding properties document, although the properties document is only created if properties are created. The properties document is typically used to store metadata related to its corresponding document, although you can store any XML data in a properties document, as long as it conforms to the properties document schema. A document typically exists at a given URI in order to create a properties document, although it is possible to create a document and add properties to it in a single transaction, and it is also possible to create a property where no document exists. The properties document is stored in a separate fragment to its corresponding document. This section describes properties documents and the APIs for accessing them, and includes the following subsections:</Body>
<Body-bullet>
<A ID="pgfId-1046551"></A>
<A href="properties.xml#id(85728)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Properties Document Namespace and Schema</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1046559"></A>
<A href="properties.xml#id(25677)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
APIs on Properties Documents</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1049080"></A>
<A href="properties.xml#id(99881)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
XPath property Axis</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1049127"></A>
<A href="properties.xml#id(25960)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Protected Properties</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1048824"></A>
<A href="properties.xml#id(52610)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Creating Element Indexes on a Properties Document Element</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1046564"></A>
<A href="properties.xml#id(66831)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Sample Properties Documents</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1075639"></A>
<A href="properties.xml#id(10714)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Standalone Properties Documents</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1046501"></A>
<A ID="85728"></A>
Properties Document Namespace and Schema</Heading-3>
<Body>
<A ID="pgfId-1046505"></A>
Properties documents are XML documents that must conform to the <code>
properties.xsd</code>
 schema. The <code>
properties.xsd</code>
 schema is copied to the <code>
&lt;install_dir&gt;/Config</code>
 directory at installation time.</Body>
<Body>
<A ID="pgfId-1046693"></A>
The properties schema is assigned the <code>
prop</code>
 namespace prefix, which is predefined in the server:</Body>
<Code>
<A ID="pgfId-1046697"></A>
http://marklogic.com/xdmp/property</Code>
<Body>
<A ID="pgfId-1046578"></A>
The following listing shows the <code>
properties.xsd</code>
 schema:</Body>
<Code>
<A ID="pgfId-1046584"></A>
&lt;xs:schema targetNamespace=&quot;http://marklogic.com/xdmp/property&quot;
&#160;xsi:schemaLocation=&quot;http://www.w3.org/2001/XMLSchema XMLSchema.xsd
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;http://marklogic.com/xdmp/security security.xsd&quot;
&#160;xmlns=&quot;http://marklogic.com/xdmp/property&quot;
&#160;xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
&#160;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
&#160;xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;
&#160;xmlns:sec=&quot;http://marklogic.com/xdmp/security&quot;&gt;

&#160;&#160;&lt;xs:complexType name=&quot;properties&quot;&gt;
&#160;&#160;&#160;&#160;&lt;xs:annotation&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;xs:documentation&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A set of document properties.
&#160;&#160;&#160;&#160;&#160;&#160;&lt;/xs:documentation&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;xs:appinfo&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;/xs:appinfo&gt;
&#160;&#160;&#160;&#160;&lt;/xs:annotation&gt;
&#160;&#160;&#160;&#160;&lt;xs:choice minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;xs:any/&gt;
&#160;&#160;&#160;&#160;&lt;/xs:choice&gt;
&#160;&#160;&lt;/xs:complexType&gt;

&#160;&#160;&lt;xs:element name=&quot;properties&quot; type=&quot;properties&quot;&gt;
&#160;&#160;&#160;&#160;&lt;xs:annotation&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;xs:documentation&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;The container for properties.
&#160;&#160;&#160;&#160;&#160;&#160;&lt;/xs:documentation&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;xs:appinfo&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;/xs:appinfo&gt;
&#160;&#160;&#160;&#160;&lt;/xs:annotation&gt;
&#160;&#160;&lt;/xs:element&gt;

&#160;&#160;&lt;xs:simpleType name=&quot;directory&quot;&gt;
&#160;&#160;&#160;&#160;&lt;xs:annotation&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;xs:documentation&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A directory indicator.
&#160;&#160;&#160;&#160;&#160;&#160;&lt;/xs:documentation&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;xs:appinfo&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;/xs:appinfo&gt;
&#160;&#160;&#160;&#160;&lt;/xs:annotation&gt;
&#160;&#160;&#160;&#160;&lt;xs:restriction base=&quot;xs:anySimpleType&quot;&gt;
&#160;&#160;&#160;&#160;&lt;/xs:restriction&gt;
&#160;&#160;&lt;/xs:simpleType&gt;

&#160;&#160;&lt;xs:element name=&quot;directory&quot; type=&quot;directory&quot;&gt;
&#160;&#160;&#160;&#160;&lt;xs:annotation&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;xs:documentation&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;The indicator for a directory.
&#160;&#160;&#160;&#160;&#160;&#160;&lt;/xs:documentation&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;xs:appinfo&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;/xs:appinfo&gt;
&#160;&#160;&#160;&#160;&lt;/xs:annotation&gt;
&#160;&#160;&lt;/xs:element&gt;

&#160;&#160;&lt;xs:element name=&quot;last-modified&quot; type=&quot;last-modified&quot;&gt;
&#160;&#160;&#160;&#160;&lt;xs:annotation&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;xs:documentation&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;The timestamp of last document modification.
&#160;&#160;&#160;&#160;&#160;&#160;&lt;/xs:documentation&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;xs:appinfo&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;/xs:appinfo&gt;
&#160;&#160;&#160;&#160;&lt;/xs:annotation&gt;
&#160;&#160;&lt;/xs:element&gt;

&#160;&#160;&lt;xs:simpleType name=&quot;last-modified&quot;&gt;
&#160;&#160;&#160;&#160;&lt;xs:annotation&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;xs:documentation&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A timestamp of the last time something was modified.
&#160;&#160;&#160;&#160;&#160;&#160;&lt;/xs:documentation&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;xs:appinfo&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&lt;/xs:appinfo&gt;
&#160;&#160;&#160;&#160;&lt;/xs:annotation&gt;
&#160;&#160;&#160;&#160;&lt;xs:restriction base=&quot;xs:dateTime&quot;&gt;
&#160;&#160;&#160;&#160;&lt;/xs:restriction&gt;
&#160;&#160;&lt;/xs:simpleType&gt;

&lt;/xs:schema&gt;</Code>
<Heading-3>
<A ID="pgfId-1048950"></A>
<A ID="25677"></A>
APIs on Properties Documents</Heading-3>
<Body>
<A ID="pgfId-1059067"></A>
The APIs for properties documents are XQuery functions which allow you to list, add, and set properties in a properties document. The properties APIs provide access to the top-level elements in properties documents. Because the properties are XML elements, you can use XPath to navigate to any children or descendants of the top-level property elements. The properties document is tied to its corresponding document and shares its URI; when you delete a document, its properties document is also deleted.</Body>
<Body>
<A ID="pgfId-1046728"></A>
The following APIs are available to access and manipulate properties documents:</Body>
<Body-bullet>
<A ID="pgfId-1046538"></A>
<code>
xdmp:document-properties</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1046707"></A>
<code>
xdmp:document-add-properties</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1046708"></A>
<code>
xdmp:document-set-properties</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1046716"></A>
<code>
xdmp:document-set-property</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1046717"></A>
<code>
xdmp:document-remove-properties</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1047849"></A>
<code>
xdmp:document-get-properties</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1047850"></A>
<code>
xdmp:collection-properties</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1047855"></A>
<code>
xdmp:directory</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1047851"></A>
<code>
xdmp:directory-properties</code>
</Body-bullet>
<Body>
<A ID="pgfId-1046732"></A>
For the signatures and descriptions of these APIs, see the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
.</Body>
<Heading-3>
<A ID="pgfId-1049058"></A>
<A ID="99881"></A>
XPath property Axis</Heading-3>
<Body>
<A ID="pgfId-1049059"></A>
MarkLogic has extended XPath (available in both XQuery and XSLT) to include the <Emphasis>
property axis</Emphasis>
. The property axis (<code>
property::</code>
) allows you to write an XPath expression to search through items in the properties document for a given URI. These expression allow you to perform joins across the document and property axes, which is useful when storing state information for a document in a property. For details on this approach, see <A href="properties.xml#id(49935)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Using Properties for Document Processing' on page&#160;103</A>.</Body>
<Body>
<A ID="pgfId-1049060"></A>
The property axis is similar to the forward and reverse axes in an XPath expression. For example, you can use the <code>
child::</code>
 forward axis to traverse to a child element in a document. For details on the XPath axes, see the <Hyperlink>
<A href="http://www.w3.org/TR/2003/WD-xpath20-20030502/#axes" xml:link="simple" show="replace" actuate="user" CLASS="URL">XPath 2.0 specification</A></Hyperlink>
 and <A href="../xquery/xpath.xml#id(_Toc61258626)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
XPath Quick Reference</Hyperlink>
</A> in the <Emphasis>
XQuery and XSLT Reference Guide</Emphasis>
.</Body>
<Body>
<A ID="pgfId-1049062"></A>
The property axis contains all of the children of the properties document node for a given URI.</Body>
<Body>
<A ID="pgfId-1049063"></A>
The following example shows how you can use the property axis to access properties for a document while querying the document:</Body>
<Body>
<A ID="pgfId-1049064"></A>
Create a test document as follows:</Body>
<Code>
<A ID="pgfId-1049065"></A>
xdmp:document-insert(&quot;/test/123.xml&quot;,
&#160;&#160;&lt;test&gt;
&#160;&#160;&#160;&#160;&lt;element&gt;123&lt;/element&gt;
&#160;&#160;&lt;/test&gt;)</Code>
<Body>
<A ID="pgfId-1049066"></A>
Add a property to the properties document for the <code>
/test/123.xml</code>
 document:</Body>
<Code>
<A ID="pgfId-1049067"></A>
xdmp:document-add-properties(&quot;/test/123.xml&quot;, 
&#160;&#160;&lt;hello&gt;hello there&lt;/hello&gt;)</Code>
<Body>
<A ID="pgfId-1049068"></A>
If you list the properties for the <code>
/test/123.xml</code>
 document, you will see the property you just added:</Body>
<Code>
<A ID="pgfId-1049069"></A>
xdmp:document-properties(&quot;/test/123.xml&quot;)
=&gt;
&lt;prop:properties xmlns:prop=&quot;http://marklogic.com/xdmp/property&quot;&gt;
&#160;&#160;&lt;hello&gt;hello there&lt;/hello&gt;
&lt;/prop:properties&gt;</Code>
<Body>
<A ID="pgfId-1049070"></A>
You can now search through the proerty axis of the <code>
/test/123.xml</code>
 document, as follows:</Body>
<Code>
<A ID="pgfId-1049071"></A>
doc(&quot;test/123.xml&quot;)/property::hello
=&gt;
&lt;hello&gt;hello there&lt;/hello&gt;</Code>
<Heading-3>
<A ID="pgfId-1046512"></A>
<A ID="25960"></A>
Protected Properties</Heading-3>
<Body>
<A ID="pgfId-1049099"></A>
The following properties are protected, and they can only be created or modified by the system:</Body>
<Body-bullet>
<A ID="pgfId-1049102"></A>
<code>
prop:directory</code>
</Body-bullet>
<Body-bullet>
<A ID="pgfId-1049106"></A>
<code>
prop:last-modified</code>
</Body-bullet>
<Body>
<A ID="pgfId-1049114"></A>
These properties are reserved for use directly by MarkLogic Server; attempts to add or delete properties with these names fail with an exception.</Body>
<Heading-3>
<A ID="pgfId-1049098"></A>
<A ID="52610"></A>
Creating Element Indexes on a Properties Document Element</Heading-3>
<Body>
<A ID="pgfId-1048819"></A>
Because properties documents are XML documents, you can create element (range) indexes on elements within a properties document. If you use properties to store numeric or date metadata about the document to which the properties document corresponds, for example, you can create an element index to speed up queries that access the metadata.</Body>
<Heading-3>
<A ID="pgfId-1048818"></A>
<A ID="66831"></A>
Sample Properties Documents</Heading-3>
<Body>
<A ID="pgfId-1048105"></A>
Properties documents are XML documents that conform to the schema described in <A href="properties.xml#id(85728)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Properties Document Namespace and Schema' on page&#160;98</A>. You can list the contents of a properties document with the <code>
xdmp:document-properties(&quot;&lt;uri&gt;&quot;)</code>
 function. If there is no properties document at the specified URI, the function returns the empty sequence. A properties document for a directory has a single empty <code>
prop:directory</code>
 element. For example, if there exists a directory at the URI <code>
http://myDirectory/</code>
, the <code>
xdmp:document-properties</code>
 command returns a properties document as follows:</Body>
<Code>
<A ID="pgfId-1048122"></A>
xdmp:document-properties(&quot;http://myDirectory/&quot;)
=&gt;
&lt;prop:properties xmlns:prop=&quot;http://marklogic.com/xdmp/property&quot;&gt;
&#160;&#160;&lt;prop:directory/&gt;
&lt;/prop:properties&gt;</Code>
<Body>
<A ID="pgfId-1048139"></A>
You can add whatever you want to a properties document (as long as it conforms to the properties schema). If you run the function <code>
xdmp:document-properties()</code>
 with no arguments, it returns a sequence of all the properties documents in the database.</Body>
<Heading-3>
<A ID="pgfId-1075650"></A>
<A ID="10714"></A>
Standalone Properties Documents</Heading-3>
<Body>
<A ID="pgfId-1075702"></A>
Typically, properties documents are created alongside the corresponding document that shares its URI. It is possible, however, to create a properties document at a URI with no coresponding document at that URI. Such a properties document is known as a <Emphasis>
standalone properties document</Emphasis>
. To create a standalone properties document, use the <code>
xdmp:document-add-properties</code>
 or <code>
xdmp:document-set-properties</code>
 APIs, and optionally add the <code>
xdmp:document-set-permissions</code>
, <code>
xdmp:document-set-collections</code>
, and/or <code>
xdmp:document-set-quality</code>
 APIs to set the permissions, collections, and/or quality on the properties document. </Body>
<Body>
<A ID="pgfId-1075731"></A>
The following example creates a properties document and sets permissions on it:</Body>
<Code>
<A ID="pgfId-1075756"></A>
xquery version &quot;1.0-ml&quot;;

xdmp:document-set-properties(&quot;/my-props.xml&quot;, &lt;my-props/&gt;),
xdmp:document-set-permissions(&quot;/my-props.xml&quot;, 
   (xdmp:permission(&quot;dls-user&quot;, &quot;read&quot;),
    xdmp:permission(&quot;dls-user&quot;, &quot;update&quot;)))</Code>
<Body>
<A ID="pgfId-1075812"></A>
If you then run <code>
xdmp:document-properties</code>
 on the URI, it rutruns the new properties document:</Body>
<Code>
<A ID="pgfId-1075935"></A>
xquery version &quot;1.0-ml&quot;;

xdmp:document-properties(&quot;/my-props.xml&quot;)
(: returns: 
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ASCII&quot;?&gt;
&lt;prop:properties xmlns:prop=&quot;http://marklogic.com/xdmp/property&quot;&gt;
  &lt;my-props/&gt;
  &lt;prop:last-modified&gt;2010-06-18T18:19:10-07:00&lt;/prop:last-modified&gt;
&lt;/prop:properties&gt;
:)</Code>
<Body>
<A ID="pgfId-1075878"></A>
Similarly, you can pass in functions to set the collections and quality on the standalone properties document, either when you create it or after it is created.</Body>
<Heading-2>
<A ID="pgfId-1075704"></A>
<A ID="49935"></A>
Using Properties for Document Processing</Heading-2>
<Body>
<A ID="pgfId-1049363"></A>
When you need to update large numbers of documents, sometimes in multi-step processes, you often need to keep track of the current state of each document. For example, if you have a content processing application that updates millions of documents in three steps, you need to have a way of programatically determining which documents have not been processed at all, which have completed step 1, which have completed step 2, and so on. </Body>
<Body>
<A ID="pgfId-1049367"></A>
This section describes how to use properties to store metadata for use in a document processing pipeline, it includes the following subsections:</Body>
<Body-bullet>
<A ID="pgfId-1049431"></A>
<A href="properties.xml#id(36019)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Using the property Axis to Determine Document State</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1049545"></A>
<A href="properties.xml#id(51322)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Document Processing Problem</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1049550"></A>
<A href="properties.xml#id(66077)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Solution for Document Processing</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1049685"></A>
<A href="properties.xml#id(89029)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Basic Commands for Running Modules</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1049368"></A>
<A ID="36019"></A>
Using the property Axis to Determine Document State</Heading-3>
<Body>
<A ID="pgfId-1049369"></A>
You can use properties documents to store state information about documents that undergo multi-step processing. Joining across properties documents can then determine which documents have been processed and which have not. The queries that perform these joins use the <code>
property::</code>
 axis (for details, see <A href="properties.xml#id(99881)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'XPath property Axis' on page&#160;101</A>). </Body>
<Body>
<A ID="pgfId-1049535"></A>
Joins across the properties axis that have predicates are optimized for performance. For example, the following returns <code>
foo</code>
 root elements from documents that have a property <code>
bar</code>
:</Body>
<Code>
<A ID="pgfId-1049370"></A>
foo[property::bar]</Code>
<Body>
<A ID="pgfId-1049373"></A>
The following examples show the types of queries that are optimized for performance (where <code>
/a/b/c</code>
 is some XPath expression):</Body>
<Body-bullet>
<A ID="pgfId-1049374"></A>
Property axis in predicates:</Body-bullet>
<Code>
<A ID="pgfId-1049375"></A>
/a/b/c[property::bar]</Code>
<Body-bullet>
<A ID="pgfId-1049376"></A>
Negation tests on property axis:</Body-bullet>
<Code>
<A ID="pgfId-1049377"></A>
/a/b/c[not(property::bar = &quot;baz&quot;)]</Code>
<Body-bullet>
<A ID="pgfId-1049378"></A>
Continuing path expression after the <code>
property</code>
 predicate:</Body-bullet>
<Code>
<A ID="pgfId-1049379"></A>
/a/b/c[property::bar and bob = 5]/d/e</Code>
<Body-bullet>
<A ID="pgfId-1049380"></A>
Equivalent FLWOR expressions:</Body-bullet>
<Code>
<A ID="pgfId-1049381"></A>
for $f in /a/b/c 
where $f/property::bar = &quot;baz&quot;
return $f</Code>
<Body>
<A ID="pgfId-1049382"></A>
Other types of expressions will work but are not optimized for performance, including the following:</Body>
<Body-bullet>
<A ID="pgfId-1049475"></A>
If you want the bar property of documents whose root elements are <code>
foo</code>
:</Body-bullet>
<Code>
<A ID="pgfId-1049476"></A>
/foo/property::bar</Code>
<Heading-3>
<A ID="pgfId-1049383"></A>
<A ID="51322"></A>
Document Processing Problem</Heading-3>
<Body>
<A ID="pgfId-1049488"></A>
The approach outlined in this section works well for situations such as the following:</Body>
<Body-bullet>
<A ID="pgfId-1049491"></A>
'I have already loaded 1 million documents and now want to update all of them.' The psuedo-code for this is as follows:</Body-bullet>
<Code>
<A ID="pgfId-1049384"></A>
for $d in fn:doc() 
return some-update($d) </Code>
<Body-indent>
<A ID="pgfId-1049493"></A>
These types of queries will eventually run out of tree cache memory and fail.</Body-indent>
<Body-bullet>
<A ID="pgfId-1049385"></A>
When iterative calls of the following form become progressively slow:</Body-bullet>
<Code>
<A ID="pgfId-1049498"></A>
<code>
for $d in fn:doc()[k to k+10000] 
return some-update($d)</code>
</Code>
<Body>
<A ID="pgfId-1049604"></A>
For these types of scenarios, using properties to test whether a document needs processing is an effective way of being able to batch up the updates into manageable chunks.</Body>
<Heading-3>
<A ID="pgfId-1049387"></A>
<A ID="66077"></A>
Solution for Document Processing</Heading-3>
<Body>
<A ID="pgfId-1049608"></A>
This content processing technique works in a wide variety of situations This approach satisfies the following requirements: </Body>
<Body-bullet>
<A ID="pgfId-1049388"></A>
Works with large existing datasets.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1049389"></A>
Does not require you to know before you load the datasets that you are going to need to further processing to them later.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1049390"></A>
This approach works in a situations in which data is still arriving (for example, new data is added every day).</Body-bullet>
<Body-bullet>
<A ID="pgfId-1049391"></A>
Needs to be able to ultimately transition into a steady state 'content processing' enabled environment.</Body-bullet>
<Body>
<A ID="pgfId-1049631"></A>
The following are the basic steps of the document processing approach:</Body>
<Number1>
<A ID="pgfId-1049392"></A>
Take an iterative strategy, but one that does not become progressively slow.</Number1>
<NumberList>
<Number>
<A ID="pgfId-1049393"></A>
Split the reprocessing activity into multiple updates.</Number>
<Number>
<A ID="pgfId-1049394"></A>
Use properties (or lack thereof) to identify the documents that (still) need processing.</Number>
<Number>
<A ID="pgfId-1049395"></A>
Repeatedly call the same module, updating its property as well as updating the document:</Number>
</NumberList>
<Code>
<A ID="pgfId-1049396"></A>
for $p in fn:doc()/root[not(property::some-update)][1 to 10000]
return some-update($d)</Code>
<NumberList>
<Number>
<A ID="pgfId-1049751"></A>
If there are any documents that still need processing, invoke the module again.</Number>
<Number>
<A ID="pgfId-1049397"></A>
The psuedo-code for the module that processes documents that do not have a specific property is as follows:</Number>
</NumberList>
<Code>
<A ID="pgfId-1049703"></A>
let $docs := get <Emphasis>
n</Emphasis>
 documents that have no properties
return
for $processDoc in $docs
return if (empty $processDoc)
&#160;&#160;&#160;&#160;&#160;&#160;&#160;then ()
&#160;&#160;&#160;&#160;&#160;&#160;&#160;else ( process-document($processDoc),
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;update-property($processDoc) )
,
xdmp:spawn(process_module) </Code>
<Body-indent>
<A ID="pgfId-1049716"></A>
This psuedo-code does the following:</Body-indent>
<Body-bullet-2>
<A ID="pgfId-1049727"></A>
gets the URIs of documents that do not have a specific property</Body-bullet-2>
<Body-bullet-2>
<A ID="pgfId-1049731"></A>
for each URI, check if the specific property exists</Body-bullet-2>
<Body-bullet-2>
<A ID="pgfId-1049735"></A>
if the property exists, do nothing to that document (it has already been updated)</Body-bullet-2>
<Body-bullet-2>
<A ID="pgfId-1049736"></A>
if the property does not exist, do the update to the document and the update to the property</Body-bullet-2>
<Body-bullet-2>
<A ID="pgfId-1049737"></A>
continue this for all of the URIs</Body-bullet-2>
<Body-bullet-2>
<A ID="pgfId-1049741"></A>
when all of the URIs have been processed, call the module again to get any new documents (ones with no properties)</Body-bullet-2>
<NumberList>
<Number>
<A ID="pgfId-1049743"></A>
(Optional) Automate the process by setting up a Content Processing Pipeline.</Number>
</NumberList>
<Heading-3>
<A ID="pgfId-1049745"></A>
<A ID="89029"></A>
Basic Commands for Running Modules</Heading-3>
<Body>
<A ID="pgfId-1049400"></A>
The following built-in functions are needed to perform automated content processing:</Body>
<Body-bullet>
<A ID="pgfId-1049667"></A>
To put a module on Task Server Queue:</Body-bullet>
<Code>
<A ID="pgfId-1049401"></A>
xdmp:spawn($database, $root, $path)</Code>
<Body-bullet>
<A ID="pgfId-1049403"></A>
To evaluate an entire module (similar to <code>
xdmp:eval()</code>
, but for for modules):</Body-bullet>
<Code>
<A ID="pgfId-1049404"></A>
xdmp:invoke($path, $external-vars)</Code>
<Code>
<A ID="pgfId-1049405"></A>
xdmp:invoke-in($path, $database-id, $external-vars)</Code>
<Heading-2>
<A ID="pgfId-1046490"></A>
<A ID="36559"></A>
Directories</Heading-2>
<Body>
<A ID="pgfId-1046500"></A>
Directories have many uses, including organizing your document URIs and using them with WebDAV servers. This section includes the following items about directories:</Body>
<Body-bullet>
<A ID="pgfId-1048061"></A>
<A href="properties.xml#id(86551)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Properties and Directories</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1048069"></A>
<A href="properties.xml#id(96342)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Directories and WebDAV Servers</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1048074"></A>
<A href="properties.xml#id(91048)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Directories Versus Collections</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1048057"></A>
<A ID="86551"></A>
Properties and Directories</Heading-3>
<Body>
<A ID="pgfId-1048056"></A>
When you create a directory, MarkLogic Server creates a properties document with a <code>
prop:directory</code>
 element. If you run the <code>
xdmp:document-properties</code>
 command on the URI corresponding to a directory, the command returns a properties document with an empty <code>
prop:directory</code>
 element, as shown in the following example:</Body>
<Code>
<A ID="pgfId-1047615"></A>
xdmp:directory-create(&quot;/myDirectory/&quot;);</Code>
<Code>
<A ID="pgfId-1047625"></A>
xdmp:document-properties(&quot;/myDirectory/&quot;)
=&gt;
&lt;prop:properties xmlns:prop=&quot;http://marklogic.com/xdmp/property&quot;&gt;
&#160;&#160;&lt;prop:directory/&gt;
&lt;/prop:properties&gt;</Code>
<Note>
<A ID="pgfId-1046534"></A>
You can create a directory with any unique URI, but the convention is for directory URIs to end with a forward slash (<code>
/</code>
). It is possible to create a document with the same URI as a directory, but this is not recommended; the best practice is to reserve URIs ending in slashes for directories.</Note>
<Body>
<A ID="pgfId-1047702"></A>
Because <code>
xdmp:document-properties()</code>
 with no arguments returns the properties documents for all properties documents in the database, and because each directory has a <code>
prop:directory</code>
 element, you can easily write a query that returns all of the directories in the database. Use the <code>
xdmp:node-uri</code>
 function to accomplish this as follows:</Body>
<Code>
<A ID="pgfId-1047661"></A>
xquery version &quot;1.0-ml&quot;;

for $x in xdmp:document-properties()/prop:properties/prop:directory
return &lt;directory-uri&gt;{xdmp:node-uri($x)}&lt;/directory-uri&gt;</Code>
<Heading-3>
<A ID="pgfId-1047635"></A>
<A ID="96342"></A>
Directories and WebDAV Servers</Heading-3>
<Body>
<A ID="pgfId-1048052"></A>
Directories are needed for use in WebDAV servers. In order to create a document that will be accessed from a WebDAV client, the parent directory must exist. The parent directory of a document is the directory in which the URI is the prefix of the document (for example, the directory of the URI <code>
http://myserver/doc.xml</code>
 is <code>
http://myserver/</code>
). When using a database with a WebDAV server, ensure tht the <code>
directory creation</code>
 setting on the database configuration is set to <code>
automatic</code>
 (this is the default setting), which causes parent directories to be created when documents are created. For information on using directories in WebDAV servers, see 'WebDAV Servers' in the <Emphasis>
Administrator's Guide</Emphasis>
.</Body>
<Heading-3>
<A ID="pgfId-1046529"></A>
<A ID="91048"></A>
Directories Versus Collections</Heading-3>
<Body>
<A ID="pgfId-1047713"></A>
You can use both directories and collections to organize documents in a database. The following are important differences between directories and collections:</Body>
<Body-bullet>
<A ID="pgfId-1047714"></A>
Directories are hierarchical in structure (like a filesystem directory structure). Collections do not have this requirement. Because directories are hierarchical, a directory URI must contain any parent directories. Collection URIs do not need to have any relation to documents that belong to a collection. For example, a directory named <code>
http://marklogic.com/a/b/c/d/e/</code>
 (where <code>
http://marklogic.com/</code>
 is the root) requires the existence of the parent directories <code>
d</code>
, <code>
c</code>
, <code>
b</code>
, and <code>
a</code>
. With collections, any document (regardless of its URI) can belong to a collection with the given URI.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1047715"></A>
Directories are required for WebDAV clients to see documents. In other words, in order to see a document with URI <code>
/a/b/hello/goodbye</code>
 in a WebDAV server with <code>
/a/b/</code>
 as the root, directories with the following URIs must exist in the database:</Body-bullet>
<Code>
<A ID="pgfId-1047716"></A>
<code>
/a/b/</code>
</Code>
<Code>
<A ID="pgfId-1047717"></A>
<code>
/a/b/hello/</code>
</Code>
<Body>
<A ID="pgfId-1047718"></A>
Except for the fact that you can use both directories and collections to organize documents, directories are unrelated to collections. For details on collections, see <A href="../search-dev-guide/collections.xml#id(19337)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Collections</Hyperlink>
</A> in the <Emphasis>
Search Developer's Guide</Emphasis>
. For details on WebDAV servers, see 'WebDAV Servers' in the <Emphasis>
Administrator's Guide</Emphasis>
.</Body>
<Heading-2>
<A ID="pgfId-1046521"></A>
<A ID="83257"></A>
Permissions On Properties and Directories</Heading-2>
<Body>
<A ID="pgfId-1048367"></A>
Like any document in a MarkLogic Server database, a properties document can have permissions. Since a directory has a properties document (with an empty <code>
prop:directory</code>
 element), directories can also have permissions. Permissions on properties documents are the same as the permissions on their corresponding documents, and you can list the permissions with the <code>
xdmp:document-get-permissions(&quot;&lt;document-uri&gt;&quot;)</code>
 function. Similarly, you can list the permissions on a directory with the <code>
xdmp:document-get-permissions(&quot;&lt;directory-uri&gt;&quot;)</code>
 function. For details on permissions and on security, see <Emphasis>
Understanding and Using Security Guide</Emphasis>
.</Body>
<Heading-2>
<A ID="pgfId-1049189"></A>
<A ID="58787"></A>
Example: Directory and Document Browser</Heading-2>
<Body>
<A ID="pgfId-1047732"></A>
Using properties documents, you can build a simple application that lists the documents and directories under a URI. The following sample code uses the <code>
xdmp:directory</code>
 function to list the children of a directory (which correspond to the URIs of the documents in the directory), and the <code>
xdmp:directory-properties</code>
 function to find the <code>
prop:directory</code>
 element, indicating that a URI is a directory. This example has two parts:</Body>
<Body-bullet>
<A ID="pgfId-1047960"></A>
<A href="properties.xml#id(34996)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Directory Browser Code</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1047968"></A>
<A href="properties.xml#id(69734)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Setting Up the Directory Browser</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1047912"></A>
<A ID="34996"></A>
Directory Browser Code</Heading-3>
<Body>
<A ID="pgfId-1047926"></A>
The following is sample code for a very simple directory browser.</Body>
<Code>
<A ID="pgfId-1059341"></A>
xquery version &quot;1.0-ml&quot;;
(:&#160;&#160;&#160;directory&#160;browser&#160;&#160;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Place in Modules database and give execute permission :)

declare&#160;namespace&#160;prop=&quot;http://marklogic.com/xdmp/property&quot;;

(: Set the root directory of your AppServer for the 
&#160;&#160;&#160;value of $rootdir :)
let $rootdir := (xdmp:modules-root()) 
(: take all but the last part of the request path, after the 
&#160;&#160;&#160;initial slash :)
let $dirpath := fn:substring-after(fn:string-join(fn:tokenize(
                xdmp:get-request-path(), &quot;/&quot;)[1 to last() - 1], 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&quot;/&quot;), &quot;/&quot;)
let $basedir := if ( $dirpath eq &quot;&quot; )
                then ( $rootdir )
                else fn:concat($rootdir, $dirpath, &quot;/&quot;)
let $uri := xdmp:get-request-field(&quot;uri&quot;, $basedir)
return&#160;if&#160;(ends-with($uri,&#160;&quot;/&quot;)) then
&lt;html&#160;xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&#160;&#160;&#160;&lt;head&gt;
&#160;&#160;&#160;&#160;&#160;&lt;title&gt;MarkLogic&#160;Server&#160;Directory&#160;Browser&lt;/title&gt;
&#160;&#160;&#160;&lt;/head&gt;
&#160;&#160;&#160;&lt;body&gt;
&#160;&#160;&#160;&#160;&#160;&lt;h1&gt;Contents&#160;of&#160;{$uri}&lt;/h1&gt;
	&lt;h3&gt;Documents&lt;/h3&gt;
{
&#160;&#160;&#160;for&#160;$d&#160;in&#160;xdmp:directory($uri,&#160;&quot;1&quot;)
&#160;&#160;&#160;let&#160;$u&#160;:=&#160;xdmp:node-uri($d)
&#160;&#160;&#160;(:&#160;get&#160;the&#160;last&#160;two,&#160;and&#160;take&#160;the&#160;last&#160;non-empty&#160;string&#160;:)
&#160;&#160;&#160;let&#160;$basename&#160;:=
&#160;&#160;&#160;&#160;&#160;tokenize($u,&#160;&quot;/&quot;)[last(),&#160;last()&#160;-&#160;1][not(.&#160;=&#160;&quot;&quot;)][last()]
&#160;&#160;&#160;order&#160;by&#160;$basename
&#160;&#160;&#160;return&#160;element&#160;p&#160;{
&#160;&#160;&#160;&#160;&#160;element&#160;a&#160;{

(:&#160;&#160;The&#160;following&#160;should&#160;work&#160;for&#160;all&#160;$basedir&#160;values,&#160;as&#160;long&#160;
&#160;&#160;&#160;&#160;as&#160;the&#160;string&#160;represented&#160;by&#160;$basedir&#160;is&#160;unique&#160;in&#160;the&#160;
&#160;&#160;&#160;&#160;document&#160;URI&#160;:)
&#160;&#160;&#160;&#160;&#160;&#160;&#160;attribute&#160;href&#160;{&#160;substring-after($u,$basedir)&#160;},
&#160;&#160;&#160;&#160;&#160;&#160;&#160;$basename
&#160;&#160;&#160;&#160;&#160;}
&#160;&#160;&#160;}
}
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;h3&gt;Directories&lt;/h3&gt;
{
&#160;&#160;&#160;for&#160;$d&#160;in&#160;xdmp:directory-properties($uri,&#160;&quot;1&quot;)//prop:directory
&#160;&#160;&#160;let&#160;$u&#160;:=&#160;xdmp:node-uri($d)
&#160;&#160;&#160;(:&#160;get&#160;the&#160;last&#160;two,&#160;and&#160;take&#160;the&#160;last&#160;non-empty&#160;string&#160;:)
&#160;&#160;&#160;let&#160;$basename&#160;:=
&#160;&#160;&#160;&#160;&#160;tokenize($u,&#160;&quot;/&quot;)[last(),&#160;last()&#160;-&#160;1][not(.&#160;=&#160;&quot;&quot;)][last()]
&#160;&#160;&#160;order&#160;by&#160;$basename
&#160;&#160;&#160;return&#160;element&#160;p&#160;{
&#160;&#160;&#160;&#160;&#160;element&#160;a&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;attribute&#160;href&#160;{&#160;concat(
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;xdmp:get-request-path(),
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&quot;?uri=&quot;,
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$u)&#160;},
&#160;&#160;&#160;&#160;&#160;&#160;&#160;concat($basename,&#160;&quot;/&quot;)
&#160;&#160;&#160;&#160;&#160;}
&#160;&#160;&#160;}
}
&lt;/body&gt;
&lt;/html&gt;
else&#160;doc($uri)

(:&#160;browser.xqy&#160;:)</Code>
<Body>
<A ID="pgfId-1048797"></A>
This application writes out an HTML document with links to the documents and directories in the root of the server. The application finds the documents in the root directory using the <code>
xdmp:directory</code>
 function, finds the directories using the <code>
xdmp:directory-properties</code>
 function, does some string manipulation to get the last part of the URI to display, and keeps the state using the application server <code>
request</code>
 object built-in XQuery functions (<code>
xdmp:get-request-field</code>
 and <code>
xdmp:get-request-path</code>
).</Body>
<Heading-3>
<A ID="pgfId-1047929"></A>
<A ID="69734"></A>
Setting Up the Directory Browser</Heading-3>
<Body>
<A ID="pgfId-1047935"></A>
To run this directory browser application, perform the following:</Body>
<Number1>
<A ID="pgfId-1047936"></A>
Create an HTTP Server and configure it as follows:</Number1>
<NumberA1>
<A ID="pgfId-1048454"></A>
Set the Modules database to be the same database as the Documents database. For example, if the <code>
database</code>
 setting is set to the database named <code>
my-database</code>
, set the <code>
modules</code>
 database to <code>
my-database</code>
 as well.</NumberA1>
<NumberAList>
<NumberA>
<A ID="pgfId-1048461"></A>
Set the HTTP Server root to <code>
http://myDirectory/</code>
, or set the root to another value and modify the <code>
$rootdir</code>
 variable in the directory browser code so it matches your HTTP Server root.</NumberA>
<NumberA>
<A ID="pgfId-1048790"></A>
Set the port to 9001, or to a port number not currently in use.</NumberA>
<Number>
<A ID="pgfId-1047937"></A>
Copy the sample code into a file named <code>
browser.xqy</code>
. If needed, modify the <code>
$rootdir</code>
 variable to match your HTTP Server root. Using the <code>
xdmp:modules-root</code>
 function, as in the sample code, will automatically get the value of the App Server root.</Number>
<Number>
<A ID="pgfId-1047948"></A>
Load the <code>
browser.xqy</code>
 file into the Modules database at the top level of the HTTP Server root. For example, if the HTTP Server root is <code>
http://myDirectory/</code>
, load the <code>
browser.xqy</code>
 file into the database with the URI <code>
http://myDirectory/browser.xqy</code>
. You can load the document either via a WebDAV client (if you also have a WebDAV server pointed to this root) or with the <code>
xdmp:document-load</code>
 function.</Number>
<Number>
<A ID="pgfId-1047938"></A>
Make sure the <code>
browser.xqy</code>
 document has execute permissions. You can check the permissions with the following function:</Number>
</NumberAList>
<Code>
<A ID="pgfId-1047993"></A>
xdmp:document-get-permissions(&quot;http://myDirectory/browser.xqy&quot;)</Code>
<Body-indent>
<A ID="pgfId-1047997"></A>
This command returns all of the permissions on the document. It should have 'execute' capability for a role possessed by the user running the application. If it does not, you can add the permissions with a command similar to the following:</Body-indent>
<Code>
<A ID="pgfId-1048005"></A>
xdmp:document-add-permissions(&quot;http://myDirectory/browser.xqy&quot;, 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;xdmp:permission(&quot;myRole&quot;, &quot;execute&quot;))</Code>
<Body-indent>
<A ID="pgfId-1048043"></A>
where <code>
myRole</code>
 is a role possessed by the user running the application.</Body-indent>
<NumberList>
<Number>
<A ID="pgfId-1047953"></A>
Load some other documents into the HTTP Server root. For example, drag and drop some documents and folders into a WebDAV client (if you also have a WebDAV server pointed to this root).</Number>
<Number>
<A ID="pgfId-1047980"></A>
Access the <code>
browser.xqy</code>
 file with a web browser using the host and port number from the HTTP Server. For example, if you are running on your local machine and you have set the HTTP Server port to 9001, you can run this application from the URL <code>
http://localhost:9001/browser.xqy</code>
.</Number>
</NumberList>
<EndList-root>
<A ID="pgfId-1047981"></A>
You should see links to the documents and directories you loaded into the database. If you did not load any other documents, you will just see a link to the <code>
browser.xqy</code>
 file.</EndList-root>
</XML>
