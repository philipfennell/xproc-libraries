<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="perftune.css" type="text/css" charset="UTF-8"?>
<XML>
<TITLE> </TITLE><Heading-1>
<A ID="pgfId-1053802"></A>
 Tuning Query Performance in MarkLogic Server</Heading-1>
<pagenum>
<A ID="pgfId-1053806"></A>
9</pagenum>
<Body>
<A ID="pgfId-1049471"></A>
This chapter describes some general issues involving query performance in MarkLogic Server, and includes the following sections:</Body>
<Body-bullet>
<A ID="pgfId-1053734"></A>
<A href="perftune.xml#id(39959)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Overview of Query Performance</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054662"></A>
<A href="perftune.xml#id(32838)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
General Techniques to Tune Performance</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1053738"></A>
<A href="perftune.xml#id(56362)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Understanding MarkLogic Server Caches</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1054047"></A>
<A href="perftune.xml#id(42588)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Rules of Thumb for Sizing</Hyperlink>
</A></Body-bullet>
<Heading-2>
<A ID="pgfId-1054048"></A>
<A ID="39959"></A>
Overview of Query Performance</Heading-2>
<Body>
<A ID="pgfId-1055106"></A>
MarkLogic Server is designed to search extremely large content sets, while providing fine-grained control over the search and access of the content. Performance is always an important component in a search application. In many cases, applications will be extremely fast with no tuning whatsoever. There are, however, many tools and techniques to help make queries faster.</Body>
<Body>
<A ID="pgfId-1055529"></A>
There are several things to consider when looking at query performance:</Body>
<Body-bullet>
<A ID="pgfId-1055530"></A>
Application requirements: how fast does performance need to be for your application? It is often useful to quantify this at application design time. Factors such as who will be using the application, what any user expectations for performance are, and whether the application will be publicly available are important considerations in defining performance requirements.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055539"></A>
Indexing options: what indexes are defined for the database? Indexing options play an important role in how well queries can be resolved from the indexes. The fastest way to resolve a query is directly from the indexes. For details on database options, see the chapters <A href="../admin/databases.xml#id(69630)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Databases</Hyperlink>
</A> and <A href="../admin/text_index.xml#id(37170)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Text Indexing</Hyperlink>
</A> in the <Emphasis>
Administrator's Guide</Emphasis>
.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055558"></A>
XQuery code: is your code written in the most efficient way possible? Sometimes, code runs more slowly than necessary because there are redundant or unneeded function calls. Or there may be a MarkLogic XQuery built-in function that performs an equivalent task more efficiently. Functions such as <code>
xdmp:estimate</code>
, <code>
cts:search</code>
, lexicon functions, and so on are all designed for fast performance.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055577"></A>
More indexes and lexicons: can range indexes and lexicons speed up your queries? For queries that access values and/or do comparisons on those values, range indexes can greatly speed performance. Range indexes are memory mapped structures, so they can retrieve the values without ever needing to access the documents. Lexicons are lists of words or values, and they too can greatly speed up certain types of queries.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055578"></A>
Server tuning: are your server parameters set appropriately for your system? In most cases, the parameters set during installation work well for the system in which MarkLogic Server is installed. Nevertheless, there are cases where you might need to change some parameters, either for a short-term need or for ongoing needs.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055585"></A>
Scalability: is your system sufficiently large for your needs? Memory, disk space and quality, swap space, number of processors, and number of servers all contribute to the overall scalability of a MarkLogic Server system. MarkLogic Server is designed to scale to very large clusters with extremely large amounts of content.</Body-bullet>
<Body>
<A ID="pgfId-1055531"></A>
This chapter and this book, as well as the <Emphasis>
Application Developer's Guide</Emphasis>
, provide information and techniques on tuning a system for optimal performance. The nature of tuning exercises is that they tend to be content-specific, so you cannot always pinpoint a particular recipe that will work for every situation. Getting to know the tools available, the XQuery APIs, and how MarkLogic Server works is the best way to make your applications run extremely fast.</Body>
<Heading-2>
<A ID="pgfId-1055105"></A>
<A ID="32838"></A>
General Techniques to Tune Performance</Heading-2>
<Body>
<A ID="pgfId-1055143"></A>
This section lists some general techniques useful in tuning performance, and provides links to places in the documentation where there is more information on a subject. It contains the following parts:</Body>
<Body-bullet>
<A ID="pgfId-1055612"></A>
<A href="perftune.xml#id(63964)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Search Built-In APIs</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055616"></A>
<A href="perftune.xml#id(77287)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Lexicons For Unique Word or Value Lookups</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055617"></A>
<A href="perftune.xml#id(31973)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Range Queries for Constraining Searches to a Range of Values</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055618"></A>
<A href="perftune.xml#id(82329)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Positions Indexes Can Help Speed Phrase Searches</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055847"></A>
<A href="perftune.xml#id(30755)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Use Query Meters and Query Trace to Characterize Performance</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055852"></A>
<A href="perftune.xml#id(91295)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Profiler API</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055857"></A>
<A href="perftune.xml#id(94338)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Monitoring API and Status Screens</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1055862"></A>
<A href="perftune.xml#id(84435)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Index Options, Range Indexes, Fields</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1055663"></A>
<A ID="63964"></A>
Search Built-In APIs</Heading-3>
<Body>
<A ID="pgfId-1055688"></A>
The search built-in XQuery APIs are designed to provide very fast searches. The APIs (<code>
cts:search</code>
, <code>
xdmp:estimate</code>
, <code>
cts:element-values</code>
, and so on) use the indexes for fast search performance. The composable <code>
cts:query</code>
 constructors make it easy to compose complex search queries with fast performance. For details on the search built-in XQuery APIs, see <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
. For details on the constructors, see <A href="../search-dev-guide/cts_query.xml#id(51991)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Composing cts:query Expressions</Hyperlink>
</A> in the <Emphasis>
Search Developer's Guide</Emphasis>
.</Body>
<Heading-3>
<A ID="pgfId-1055689"></A>
<A ID="77287"></A>
Lexicons For Unique Word or Value Lookups</Heading-3>
<Body>
<A ID="pgfId-1055669"></A>
MarkLogic Server allows you to create lexicons, which are lists of unique words or values in a database. Lexicons allow for very fast lookups, and in the case of values, also provide very fast counts. For details on lexicons, see the chapter <A href="../search-dev-guide/lexicon.xml#id(29002)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Browsing With Lexicons</Hyperlink>
</A> in the <Emphasis>
Search Developer's Guide</Emphasis>
.</Body>
<Heading-3>
<A ID="pgfId-1055409"></A>
<A ID="31973"></A>
Range Queries for Constraining Searches to a Range of Values</Heading-3>
<Body>
<A ID="pgfId-1055642"></A>
Range queries allow you to specify queries that use range indexes in a <code>
cts:query</code>
 expression. Range queries can both improve performance and make it easier to build applications that constrain on values. For details on range queries, see <A href="../search-dev-guide/rangequery.xml#id(19990)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Using Range Queries in cts:query Expressions</Hyperlink>
</A> in the <Emphasis>
Search Developer's Guide</Emphasis>
.</Body>
<Heading-3>
<A ID="pgfId-1055478"></A>
<A ID="82329"></A>
Positions Indexes Can Help Speed Phrase Searches</Heading-3>
<Body>
<A ID="pgfId-1055718"></A>
If you specify <code>
word positions</code>
 in the database configuration, it can speed phrase searches. During the index resolution phase of query processing, MarkLogic Server determines if words are next to each other based on their positions. For example, if you search for the phrase <code>
&quot;to be or not to be&quot;</code>
, MarkLogic Server can eliminate as possible matches, based on positions, most occurrences of these common words because they do not have the proper word next to it. This speeds performance in two ways: it lowers the number of I/Os needed to retrieve candidate fragments, and it makes the filtering phase faster because there are less candidate fragments to filter. For details about how search processing works, see <A href="unfiltered.xml#id(13165)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Understanding the Search Process' on page&#160;10</A>.</Body>
<Heading-3>
<A ID="pgfId-1055519"></A>
<A ID="30755"></A>
Use Query Meters and Query Trace to Characterize Performance</Heading-3>
<Body>
<A ID="pgfId-1055738"></A>
There are two XQuery functions to help you characterize the performance of queries: <code>
xdmp:query-meters</code>
 and <code>
xdmp:query-trace</code>
. The former provides timings of a query and the latter logs details of the query evaluation to the <code>
ErrorLog.txt</code>
 file. For details on these APIs, see <A href="query_meters.xml#id(53138)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Tuning Queries with query-meters and query-trace' on page&#160;15</A> and the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
.</Body>
<Heading-3>
<A ID="pgfId-1055520"></A>
<A ID="91295"></A>
Profiler API</Heading-3>
<Body>
<A ID="pgfId-1055760"></A>
MarkLogic Server has a profiler to help determine where a query is spending time processing. For details on the profiler, see <A href="profile.xml#id(94939)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Profiling Requests to Evaluate Performance' on page&#160;32</A> and the <Emphasis>
MarkLogic XQuery and XSLT Function Reference</Emphasis>
.</Body>
<Heading-3>
<A ID="pgfId-1055773"></A>
<A ID="94338"></A>
Monitoring API and Status Screens</Heading-3>
<Body>
<A ID="pgfId-1055774"></A>
There are APIs and status screens in the Admin Interface to monitor activities on your system. These can be useful in identifying bottlenecks on your system. For details, see <A href="status.xml#id(37719)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Monitoring MarkLogic Server Performance' on page&#160;38</A>. </Body>
<Heading-3>
<A ID="pgfId-1055759"></A>
<A ID="84435"></A>
Index Options, Range Indexes, Fields</Heading-3>
<Body>
<A ID="pgfId-1055521"></A>
There are many types of index options, including several types of wildcard indexes, element indexes, stemmed indexes, element and attribute range indexes, and so on. Depending on your needs, these indexes can help speed performance. Indexes tend to take more disk space and increase loading times, but can greatly improve performance. </Body>
<Body>
<A ID="pgfId-1055812"></A>
Fields are another way of improving performance, especially if you are only interested in searching through certain included elements, or you want your searches to exclude particular elements. For details on fields, see <A href="../admin/fields.xml#id(61682)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Fields Database Settings</Hyperlink>
</A> in the <Emphasis>
Administrator's Guide</Emphasis>
.</Body>
<Heading-2>
<A ID="pgfId-1055142"></A>
<A ID="56362"></A>
Understanding MarkLogic Server Caches</Heading-2>
<Body>
<A ID="pgfId-1055870"></A>
MarkLogic Server has several caches used in query processing, defined on the group configuration page. The <Emphasis>
list cache</Emphasis>
 stores termlists in memory, the <Emphasis>
compressed tree cache</Emphasis>
 stores compressed fragment data in memory, and the <Emphasis>
expanded tree cache</Emphasis>
 stores uncompressed fragment data in memory. Additionally, there are several other caches used for security objects, modules, schemas, and so on; these other caches cannot be configured. In most cases, if the caches fill up, they will move older data out to make room for newer content. </Body>
<Body>
<A ID="pgfId-1055907"></A>
In some cases, however, it is possible to run a query that will fail because a cache was full. Particularly, when the expanded tree cache gets full, a query can fail with an <code>
XDMP-TREECACHEFULL</code>
 exception. The following are some guidelines to avoid <code>
XDMP-TREECACHEFULL</code>
 errors:</Body>
<Body-bullet>
<A ID="pgfId-1055479"></A>
Avoid queries that return the entire database. Instead, return the results in batches (a page at a time, like a classic search page, for example).</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055891"></A>
Try to rewrite the query in a more efficient way.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055483"></A>
Make sure swap space is configured properly on your server.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055484"></A>
If you do not have sufficient memory on your server, consider adding more memory to the system.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055518"></A>
You can raise the sizes of the caches, but that might be a temporary fix. </Body-bullet>
<Body-bullet>
<A ID="pgfId-1055517"></A>
64-bit systems are recommended. 64-bit systems can hold a lot more memory, and more memory means larger caches. </Body-bullet>
<Heading-2>
<A ID="pgfId-1055325"></A>
<A ID="42588"></A>
Rules of Thumb for Sizing</Heading-2>
<Body>
<A ID="pgfId-1055927"></A>
The following are some rule-of-thumb sizing recommendations. These recommendations are best practices based on experience with MarkLogic Server implementations. Also, some of these recommendations are content specific. Performing experiments on your own content is a good way to validate any expansions of these rules of thumb, but these provide a good starting point.</Body>
<Body-bullet>
<A ID="pgfId-1055421"></A>
You should have approximately 10-20 GB of forest data per 1 GB of RAM. More memory will help, too, especially if you have a lot of range indexes and/or lexicons.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055485"></A>
64-bit systems are good--they greatly increase the address space so you can address more than 4GB of RAM.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055425"></A>
Forests should not grow too much past 200GB or 32-million fragments; when a forest size approaches 200 GB or 32-million fragments, think about creating a new forest.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055428"></A>
Make sure you have at least 2x memory for swap space. This is important to make sure MarkLogic Server does not run out of memory. At query time, MarkLogic Server asks the operating system to reserve both memory and swap space. If there is not enough of either, the query can fail with <code>
SVC-MEMALLOC</code>
 messages. These messages can happen if you do not have 2x the amount of swap space. If you do have enough swap space and still get these errors, it can indicate that you either need to increase the amount of memory in the system or lower the amount of memory being used, either by modifying your queries or lowering some of the sizes of server caches, lowering the number of threads the server can service, and so on. Additionally, if you are on a 32-bit system and are getting these errors, it can indicate that you are coming to the limit of a 32-bit system, and a 64-bit system might be a good solution. While lowering the sizes of caches can act as a short-term fix, it generally means that you need to expand the size of the system.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055429"></A>
For updates, make the journal size larger if you have a lot of range index data. A symptom of this as a problem is journal-full errors.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1055430"></A>
For updates, make the journal size larger if your transactions span multiple forests. The journals must keep the lock information for all documents involved in the transaction, not just for the documents in the journal for the forest in which the document exists. A symptom of this as a problem is journal-full errors. </Body-bullet>
<Body-bullet>
<A ID="pgfId-1055449"></A>
There is a limit of 65k for the size of a string literal or a token in an XQuery program. If you need to input a string longer than 65k, use an external variable with the <code>
xdmp:invoke</code>
 API. External variables are limited to a single node or a string, and in XCC are limited to string only. In XCC, if you need to input a node as an external variable, you must quote it as a string on input and then unquote it (<code>
xdmp:unquote</code>
) into a node in your XQuery function. Note that this limit is only for the size of a string literal or a token; XQuery program sizes are limited only by the cache size.</Body-bullet>
</XML>
