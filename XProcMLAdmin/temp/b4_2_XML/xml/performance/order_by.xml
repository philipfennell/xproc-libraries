<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="order_by.css" type="text/css" charset="UTF-8"?>
<XML>
<TITLE> </TITLE><Heading-1>
<A ID="pgfId-1049467"></A>
<A ID="33564"></A>
 Optimizing Order By Expressions With Range Indexes</Heading-1>
<pagenum>
<A ID="pgfId-1049601"></A>
31</pagenum>
<Body>
<A ID="pgfId-1049471"></A>
When you have queries that include an <code>
order by</code>
 expression, you can create element or attribute (range) indexes on the element(s) or attribute(s) in the <code>
order by</code>
 expression to speed performance of those types of queries. This chapter describes this optimization and how to use it in your queries, and includes the following sections:</Body>
<Body-bullet>
<A ID="pgfId-1052974"></A>
<A href="order_by.xml#id(24125)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Speed Up Order By Performance</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1052982"></A>
<A href="order_by.xml#id(59622)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Rules for Order By Optimization</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1053019"></A>
<A href="order_by.xml#id(15336)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Creating Element or Attribute (Range) Indexes</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1057858"></A>
<A href="order_by.xml#id(11063)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Example Order By Queries</Hyperlink>
</A></Body-bullet>
<Heading-2>
<A ID="pgfId-1052964"></A>
<A ID="24125"></A>
Speed Up Order By Performance</Heading-2>
<Body>
<A ID="pgfId-1052968"></A>
MarkLogic Server allows you to create indexes on elements to speed up performance of queries that order the results based on that element. The <code>
order by</code>
 clause is the 'O' in the XQuery <code>
FLWOR</code>
 expression, and it allows you to sort the results of a query based on one ore more elements. The <code>
order by</code>
 optimization speeds up queries that order the results and then return a subset of those results (for example, the first 10 results). </Body>
<Heading-2>
<A ID="pgfId-1052969"></A>
<A ID="59622"></A>
Rules for Order By Optimization</Heading-2>
<Body>
<A ID="pgfId-1052973"></A>
The following rules apply to a query in order for the <code>
order by</code>
 optimization to apply:</Body>
<Body-bullet>
<A ID="pgfId-1049159"></A>
Optimizes subsets of <code>
order by</code>
 queries. For example:</Body-bullet>
<Code>
<A ID="pgfId-1049499"></A>
(FLWOR)[1 to 20]</Code>
<Body-indent>
<A ID="pgfId-1053240"></A>
where <code>
FLWOR</code>
 is an XQuery <code>
FLWOR</code>
 expression.</Body-indent>
<Body-bullet>
<A ID="pgfId-1049493"></A>
Uses element or attribute (range) indexes.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1049515"></A>
The sequence bound to the <code>
for</code>
 variable must be fully searchable XPath expression or a <code>
cts:search</code>
 expression. See <A href="query_meters.xml#id(17135)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Fully Searchable Paths and cts:search Operations' on page&#160;22</A>.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1053104"></A>
The order by expression must be on variables bound in the <code>
for</code>
 clause; queries that have <code>
order by</code>
 expressions on variables bound to a sequence in a <code>
let</code>
 clause are <Emphasis>
not</Emphasis>
 optimized.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1049519"></A>
There must be a range index on the last step of the order by expression. For example:</Body-bullet>
<Code>
<A ID="pgfId-1049520"></A>
order by $x/bar/foo</Code>
<Body-indent>
<A ID="pgfId-1049525"></A>
needs a range index on <code>
foo</code>
 to execute with the <code>
order by</code>
 optimization.</Body-indent>
<Body-bullet>
<A ID="pgfId-1049521"></A>
The type of the order by expression must be the type of the range index, either implicitly, through a schema, or through an explicit cast. If there is a cast in the order by expression, than it must be to the type of the range index.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1049578"></A>
You can have order by expressions with multiple items, as long as there is a range index on each item. For example:</Body-bullet>
<Code>
<A ID="pgfId-1049589"></A>
order by $x/foo, $x/bar</Code>
<Body-indent>
<A ID="pgfId-1049593"></A>
as long as there are range indexes for <code>
foo</code>
 and <code>
bar</code>
.</Body-indent>
<Body-bullet>
<A ID="pgfId-1049529"></A>
The XPath expression in the order by expression must be a simple relative path; no math or other expressions are allowed.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1049530"></A>
It does not matter what the <code>
let</code>
, <code>
where</code>
, or <code>
return</code>
 clauses are; these do not effect the optimization.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1049531"></A>
If you order by <code>
cts:score($x)</code>
, <code>
cts:confidence($x)</code>
, or <code>
cts:quality($x)</code>
, no range index is required.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1049544"></A>
You can specify either <code>
ascending</code>
 or <code>
descending</code>
 orders (optionally).</Body-bullet>
<Body-bullet>
<A ID="pgfId-1049549"></A>
You can specify either <code>
empty greatest</code>
 or <code>
empty least</code>
 (optionally, must be the last part of the <code>
order by</code>
 clause).</Body-bullet>
<Body-bullet>
<A ID="pgfId-1049559"></A>
Optimized <code>
order by</code>
 clauses implicitly add <code>
order by</code>
 expressions for <code>
cts:score</code>
 and document order to the end of the <code>
order by</code>
 expression.</Body-bullet>
<Body-bullet>
<A ID="pgfId-1049563"></A>
If you have a function that is a <code>
FLWOR</code>
 expression (with the required fully searchable path, etc.), subsets of that will be optimized. for example</Body-bullet>
<Code>
<A ID="pgfId-1049564"></A>
xquery version &quot;1.0-ml&quot;;
declare function local:foo()
{
for $x in //a/b/c
order by $x/d
return $x
};
( local:foo() )[1 to 10]</Code>
<Body-bullet>
<A ID="pgfId-1053183"></A>
The search or XPath expression must be part of the <code>
FLWOR</code>
, not bound to a variable that is referenced in the <code>
FLWOR</code>
. For example, the following will not be optimized:</Body-bullet>
<Code>
<A ID="pgfId-1057901"></A>
let $x := cts:search(/foo, &quot;hello&quot;)
return
(for $y in $x
order by $y/element
return $y)[1 to 10]</Code>
<Body-indent>
<A ID="pgfId-1057890"></A>
but the following will (given the other rules are followed):</Body-indent>
<Code>
<A ID="pgfId-1057952"></A>
(for $y in cts:search(/foo, &quot;hello&quot;)
order by $y/element
return $y)[1 to 10]</Code>
<Body-bullet>
<A ID="pgfId-1057873"></A>
You can use <code>
xdmp:query-trace</code>
 to determine if a query is using the range indexes to optimize an order by expression. For details on using <code>
xdmp:query-trace</code>
, see <A href="query_meters.xml#id(10519)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Understanding query-trace Output' on page&#160;18</A>.</Body-bullet>
<Heading-2>
<A ID="pgfId-1049565"></A>
<A ID="15336"></A>
Creating Element or Attribute (Range) Indexes</Heading-2>
<Body>
<A ID="pgfId-1053018"></A>
You must create range indexes on the elements or attributes in which you order your result by in the <code>
order by</code>
 expression. You create range indexes using the Admin interface by going to the Databases &gt; <Emphasis>
database_name</Emphasis>
 &gt; Element Indexes or Attribute Indexes page. Be sure to select the proper type for the element or attribute. For more details on creating indexes, see the <Emphasis>
Administrator's Guide</Emphasis>
.</Body>
<Heading-2>
<A ID="pgfId-1053180"></A>
<A ID="11063"></A>
Example Order By Queries</Heading-2>
<Body>
<A ID="pgfId-1057773"></A>
This section shows the following simple queries that use the order by optimizations:</Body>
<Body-bullet>
<A ID="pgfId-1057813"></A>
<A href="order_by.xml#id(12572)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Order by a Single Element</Hyperlink>
</A></Body-bullet>
<Body-bullet>
<A ID="pgfId-1057827"></A>
<A href="order_by.xml#id(21541)" xml:link="simple" show="replace" actuate="user" CLASS="XRef"><Hyperlink>
Order by Multiple Elements</Hyperlink>
</A></Body-bullet>
<Heading-3>
<A ID="pgfId-1057784"></A>
<A ID="12572"></A>
Order by a Single Element</Heading-3>
<Body>
<A ID="pgfId-1053142"></A>
The following query returns the first 100 <code>
lastname</code>
 elements. In order for this query to run optimized, there must be a range index defined on the <code>
lastname</code>
 element.</Body>
<Code>
<A ID="pgfId-1053136"></A>
(for $x in //myNode
order by $x/lastname
return
$x/lastname)[1 to 100]</Code>
<Body>
<A ID="pgfId-1057471"></A>
If you enabled query tracing on this query (by adding <code>
xdmp:query-trace(fn:true()),</code>
 to the beginning of the query, for example), the query trace output will show if the range index is being used for the optiomization. If the range index is not being used, the query-trace output looks similar to the following:</Body>
<Code>
<A ID="pgfId-1057502"></A>
2009-05-15 15:56:05.046 Info: myAppServer: line 2: xdmp:eval(&quot;xdmp:query-trace(fn:true()),&amp;#13;&amp;#10;(for $x in //myNode&amp;#13;&amp;#...&quot;, (), &lt;options xmlns=&quot;xdmp:eval&quot;&gt;&lt;database&gt;661882637959476934&lt;/database&gt;&lt;modules&gt;0&lt;/modules&gt;&lt;defa...&lt;/options&gt;)
2009-05-15 15:56:05.068 Info: myAppServer: line 2: Analyzing path for $x: collection()/descendant::myNode
2009-05-15 15:56:05.068 Info: myAppServer: line 2: Step 1 is searchable: collection()
2009-05-15 15:56:05.068 Info: myAppServer: line 2: Step 2 is searchable: descendant::myNode
2009-05-15 15:56:05.068 Info: myAppServer: line 2: Path is fully searchable.
2009-05-15 15:56:05.068 Info: myAppServer: line 2: Gathering constraints.
2009-05-15 15:56:05.068 Info: myAppServer: line 2: Step 2 test contributed 1 constraint: myNode
2009-05-15 15:56:05.068 Info: myAppServer: line 2: Executing search.
2009-05-15 15:56:05.089 Info: myAppServer: line 2: Selected 6 fragments to filter.</Code>
<Body>
<A ID="pgfId-1057750"></A>
The above output does not show that the range index is being used. This could be because the range index does not exist or it could indicate that one of the criteria for the order by optimizations is not met, as described in <A href="order_by.xml#id(59622)" xml:link="simple" show="replace" actuate="user" CLASS="XRef">'Rules for Order By Optimization' on page&#160;27</A>.</Body>
<Body>
<A ID="pgfId-1057708"></A>
When the correct range index is in place and the query is being optimized, the query-trace output will look similar to the following:</Body>
<Code>
<A ID="pgfId-1057548"></A>
2009-05-15 15:58:04.145 Info: myAppServer: line 2: xdmp:eval(&quot;xdmp:query-trace(fn:true()),&amp;#13;&amp;#10;(for $x in //myNode&amp;#13;&amp;#...&quot;, (), &lt;options xmlns=&quot;xdmp:eval&quot;&gt;&lt;database&gt;661882637959476934&lt;/database&gt;&lt;modules&gt;0&lt;/modules&gt;&lt;defa...&lt;/options&gt;)
2009-05-15 15:58:04.145 Info: myAppServer: line 2: Analyzing path for $x: collection()/descendant::myNode
2009-05-15 15:58:04.145 Info: myAppServer: line 2: Step 1 is searchable: collection()
2009-05-15 15:58:04.145 Info: myAppServer: line 2: Step 2 is searchable: descendant::myNode
2009-05-15 15:58:04.145 Info: myAppServer: line 2: Path is fully searchable.
2009-05-15 15:58:04.146 Info: myAppServer: line 2: Gathering constraints.
2009-05-15 15:58:04.146 Info: myAppServer: line 2: Step 2 test contributed 1 constraint: myNode
<Bold>
2009-05-15 15:58:04.146 Info: myAppServer: line 2: Order by clause contributed 1 range ordering constraint for $x: order by $x/lastname ascending
</Bold>
2009-05-15 15:58:04.146 Info: myAppServer: line 2: Executing search.
2009-05-15 15:58:04.183 Info: myAppServer: line 2: Selected 6 fragments to filter.</Code>
<Body>
<A ID="pgfId-1057718"></A>
Notice the line that says <code>
Order by clause contributed 1 range constraint</code>
. That line indicates that the query is being optimized by the range index (which is good).</Body>
<Heading-3>
<A ID="pgfId-1057842"></A>
<A ID="21541"></A>
Order by Multiple Elements</Heading-3>
<Body>
<A ID="pgfId-1053173"></A>
The following query returns the first 100 <code>
myNode</code>
 elements, ordered by <code>
lastname</code>
 and then <code>
firstname</code>
. For this query to run optimized, there must be a range index defined on the <code>
lastname</code>
 and <code>
firstname</code>
 elements.</Body>
<Code>
<A ID="pgfId-1053160"></A>
(for $x in //myNode
order by $x/lastname, $x/firstname
return
$x)[1 to 100]</Code>
<Body>
<A ID="pgfId-1057732"></A>
If you run query-trace with this query, that will verify whether the range indexes are being used.</Body>
</XML>
